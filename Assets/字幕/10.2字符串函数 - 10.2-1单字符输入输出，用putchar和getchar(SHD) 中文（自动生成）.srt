1
00:00:04,280 --> 00:00:05,690
我们先来看这个函数

2
00:00:05,690 --> 00:00:07,580
这个函数叫做pcr

3
00:00:07,819 --> 00:00:09,769
从他的名字你可以猜得出来

4
00:00:09,769 --> 00:00:13,308
put cha放字符放到哪儿呢

5
00:00:13,308 --> 00:00:15,660
放到标准输出

6
00:00:15,939 --> 00:00:18,998
所以这个函数会把一个字符

7
00:00:18,998 --> 00:00:21,309
输出在标准输出上

8
00:00:21,309 --> 00:00:23,920
也就是那个黑黑的窗口里头

9
00:00:25,420 --> 00:00:27,359
但是这个函数有一点点奇怪的地方

10
00:00:27,359 --> 00:00:30,960
是它的输入这个函数的参数不是差类型

11
00:00:30,960 --> 00:00:32,618
而是int类型

12
00:00:33,259 --> 00:00:36,549
但是实际上它的int所能够接受的

13
00:00:36,549 --> 00:00:38,539
只是一个字符而已

14
00:00:39,479 --> 00:00:41,149
你给他那一个char

15
00:00:41,149 --> 00:00:42,799
它放到int里头去了

16
00:00:42,799 --> 00:00:45,020
并不是说他一次能接受四个字符啊

17
00:00:45,020 --> 00:00:45,950
这是两回事

18
00:00:45,950 --> 00:00:48,418
之所以他要接收一个char

19
00:00:49,140 --> 00:00:50,810
我们后面再来展开解释

20
00:00:50,810 --> 00:00:52,609
它的返回类型也是一个int

21
00:00:52,609 --> 00:00:56,570
表示说这一次他到底写出去了几个字符

22
00:00:56,570 --> 00:00:57,890
当然你想得到

23
00:00:57,890 --> 00:00:59,929
既然每次写一个正常情况下

24
00:00:59,929 --> 00:01:01,119
它都应该返回一

25
00:01:01,119 --> 00:01:03,939
可是如果出现了某些情况

26
00:01:03,939 --> 00:01:06,129
你的这个输出不能用了

27
00:01:06,129 --> 00:01:08,170
它会返回一个特殊的符号

28
00:01:08,170 --> 00:01:09,549
叫做e o f

29
00:01:09,549 --> 00:01:11,899
意思是end of file

30
00:01:12,000 --> 00:01:13,680
文件结束

31
00:01:13,680 --> 00:01:15,209
这个e o f

32
00:01:15,209 --> 00:01:18,810
它是一个在c语言里面我们定义的宏

33
00:01:18,810 --> 00:01:22,310
这事情我们后面会展开讲这个红的值

34
00:01:22,310 --> 00:01:23,599
每个红都会有一个值

35
00:01:23,599 --> 00:01:25,250
这个值是-1

36
00:01:25,250 --> 00:01:27,019
也就是说它会返回-1

37
00:01:27,019 --> 00:01:29,500
表示说他不能再输出东西了

38
00:01:29,900 --> 00:01:31,099
正常情况下

39
00:01:31,099 --> 00:01:33,859
我们不需要去检查pcr的输出啊

40
00:01:33,859 --> 00:01:36,379
ptr函数的返回对应于put cha

41
00:01:36,379 --> 00:01:39,379
我们还有另外一个函数叫做gta

42
00:01:39,599 --> 00:01:40,439
get child

43
00:01:40,439 --> 00:01:41,760
就不需要有参数

44
00:01:41,760 --> 00:01:42,930
它返回给你

45
00:01:42,930 --> 00:01:46,459
它从标准输入读到的一个字符

46
00:01:46,540 --> 00:01:49,319
同样的它的返回也是int

47
00:01:49,700 --> 00:01:51,379
它的返回是那个字符

48
00:01:51,379 --> 00:01:53,959
他读到的那个字符为什么不是char

49
00:01:53,959 --> 00:01:55,140
而是int呢

50
00:01:55,840 --> 00:01:58,859
因为他要返回ef来

51
00:01:58,859 --> 00:02:03,099
表示说这个时候输入结束了

52
00:02:04,540 --> 00:02:06,069
输入为什么会结束

53
00:02:06,069 --> 00:02:08,240
标准输入为什么会结束

54
00:02:08,679 --> 00:02:10,538
我们先来写一个程序

55
00:02:10,538 --> 00:02:12,218
用上get chat和butcher

56
00:02:12,218 --> 00:02:14,438
然后我们来看看怎么样让标准输入结束

57
00:02:14,438 --> 00:02:17,370
我们再来解释这当中发生的事情

58
00:02:17,370 --> 00:02:19,289
我们做了这个非常简单的程序啊

59
00:02:19,289 --> 00:02:23,569
我们get char得到的那个结果交给c去变量

60
00:02:23,569 --> 00:02:26,740
然后判断一下说因为这个括号在这儿啊

61
00:02:26,740 --> 00:02:28,060
做完这个赋值以后

62
00:02:28,060 --> 00:02:28,960
这个表达式的结果

63
00:02:28,960 --> 00:02:30,219
就是c h刚刚得到的那个值

64
00:02:30,219 --> 00:02:31,539
然后我们用这个值去判断一下

65
00:02:31,539 --> 00:02:33,250
说他是不是有f

66
00:02:33,250 --> 00:02:34,870
如果他不是e o f

67
00:02:34,870 --> 00:02:37,659
那我们在循环里面就把这个c h给输出了

68
00:02:37,659 --> 00:02:39,370
如果他是e o f

69
00:02:39,370 --> 00:02:41,610
在出来程序结束之前

70
00:02:41,610 --> 00:02:43,110
我们再来输出一点东西

71
00:02:43,110 --> 00:02:47,300
我们说e o f我们读到了e f

72
00:02:47,300 --> 00:02:49,219
ok我们来执行一下这个程序

73
00:02:49,219 --> 00:02:50,810
现在我们要输入东西了

74
00:02:50,810 --> 00:02:52,340
12345

75
00:02:52,659 --> 00:02:54,039
我们随便输入点东西

76
00:02:54,039 --> 00:02:54,699
敲回车之后

77
00:02:54,699 --> 00:02:56,020
他给我们输出的这个结果

78
00:02:56,020 --> 00:02:57,219
我们又输入了点东西

79
00:02:57,219 --> 00:02:59,080
敲回车之后输出的结果有没有输出点东西

80
00:02:59,080 --> 00:03:00,649
敲回车后输入的那个结果

81
00:03:00,649 --> 00:03:01,968
什么时候才能停下来

82
00:03:01,968 --> 00:03:03,109
什么时候给我们u o f

83
00:03:03,109 --> 00:03:05,280
我们输入ef没有任何用处

84
00:03:05,280 --> 00:03:07,250
我们输入-1没有任何用处

85
00:03:07,250 --> 00:03:08,389
这是一个echo

86
00:03:08,389 --> 00:03:09,229
这是一个应声虫

87
00:03:09,229 --> 00:03:09,530
输入的

88
00:03:09,530 --> 00:03:12,469
所有东西都会被他原封不动的输出

89
00:03:12,469 --> 00:03:13,099
给我们看

90
00:03:13,099 --> 00:03:18,460
那如果这个时候我们不小心敲了ctrl c

91
00:03:21,039 --> 00:03:22,409
程序结束了

92
00:03:22,409 --> 00:03:24,900
但是我们没有看到ef

93
00:03:24,900 --> 00:03:26,430
那三个字母被打印出来

94
00:03:26,430 --> 00:03:30,810
这说明我们只是强制那个程序结束

95
00:03:30,810 --> 00:03:33,699
我们并没有正确的输入uf

96
00:03:33,699 --> 00:03:35,539
我们并没有正确的让他知道

97
00:03:35,539 --> 00:03:36,830
我们的输入结束了

98
00:03:36,830 --> 00:03:38,060
什么叫做输入结束了

99
00:03:38,060 --> 00:03:39,379
可是你程序还在运行呢

100
00:03:39,379 --> 00:03:40,610
ok我们再来试一遍

101
00:03:40,610 --> 00:03:42,740
如果我们输入点东西原封不动给我们

102
00:03:42,740 --> 00:03:45,180
现在如果我们输入control

103
00:03:48,319 --> 00:03:50,139
我们得到了uf

104
00:03:50,139 --> 00:03:52,090
我们得到了uf的输出

105
00:03:52,090 --> 00:03:57,680
表明我们的程序读到了那个e o f

106
00:03:57,680 --> 00:03:58,430
那种状态

107
00:03:58,430 --> 00:04:00,840
我们的get a chr给我们返回了e o f

108
00:04:01,060 --> 00:04:03,039
可是为什么我们输入ctrl d

109
00:04:03,039 --> 00:04:05,300
get truck会给我们uf呢

110
00:04:05,659 --> 00:04:06,379
顺便说

111
00:04:06,379 --> 00:04:07,939
如果你在windows上面

112
00:04:08,060 --> 00:04:11,030
这个时候你需要输入的是ctrl z

113
00:04:11,030 --> 00:04:12,340
而不是ctrl d

114
00:04:12,340 --> 00:04:15,939
windows和unix对于o f的定义是不一样的

115
00:04:15,939 --> 00:04:18,160
但只是具体的键不一样

116
00:04:18,160 --> 00:04:19,569
剩下的事情是一样的

117
00:04:19,569 --> 00:04:20,740
什么事情呢

118
00:04:21,860 --> 00:04:23,410
顺便你再回想一下

119
00:04:23,410 --> 00:04:24,579
我们刚才在做的

120
00:04:24,579 --> 00:04:26,569
你输入一他没有给你一

121
00:04:26,569 --> 00:04:28,370
明明get ch是读一个字符的

122
00:04:28,370 --> 00:04:29,060
对不对

123
00:04:29,060 --> 00:04:30,290
我说了很多东西

124
00:04:30,290 --> 00:04:31,759
他都没有回答我

125
00:04:31,759 --> 00:04:33,740
直到我按下回车

126
00:04:33,978 --> 00:04:37,360
他才回答我get的价值读一个嘛

127
00:04:37,360 --> 00:04:40,569
为什么要等到我回车以后再给我们回答呢

128
00:04:40,569 --> 00:04:44,490
因为之前有一次我们提到过这件事情

129
00:04:44,490 --> 00:04:50,699
你的程序和用户的键盘显示器之间

130
00:04:50,699 --> 00:04:52,699
还有另外一个程序

131
00:04:53,720 --> 00:04:55,439
那个叫做sh

132
00:04:57,199 --> 00:04:59,199
需要负责把你的程序运行起来

133
00:04:59,199 --> 00:05:02,829
键盘输给你的东西其实是先给了shell

134
00:05:02,829 --> 00:05:05,100
shell处理过以后再给你

135
00:05:05,100 --> 00:05:06,360
你显示的东西

136
00:05:06,360 --> 00:05:08,069
你print的东西给了show

137
00:05:08,069 --> 00:05:09,810
需要处理过以后再给你

138
00:05:09,810 --> 00:05:11,610
你还记得当时我们在讲什么时候

139
00:05:11,610 --> 00:05:12,660
提到过这张图呢

140
00:05:12,660 --> 00:05:13,649
我们当时在讲

141
00:05:13,649 --> 00:05:17,439
backslash b到底会变成什么样子

142
00:05:18,319 --> 00:05:20,620
这个需要做的一件事情

143
00:05:20,620 --> 00:05:22,180
非常基本的一件事情

144
00:05:22,180 --> 00:05:24,310
就是你在键盘上按的所有东西

145
00:05:24,310 --> 00:05:29,230
它给你形成一个我们叫做行编辑的工作

146
00:05:29,230 --> 00:05:32,199
也就是说你在键盘上按的字

147
00:05:32,199 --> 00:05:34,600
比如说你输了123

148
00:05:35,019 --> 00:05:37,439
在你按下回车之前

149
00:05:38,220 --> 00:05:41,990
这些字都没有被送到你的程序那里去

150
00:05:41,990 --> 00:05:44,360
这些字都还停留在笑那里

151
00:05:44,360 --> 00:05:46,120
一直到你按下回车

152
00:05:46,180 --> 00:05:47,800
你按下回车以后

153
00:05:47,800 --> 00:05:51,879
在校那里说它会有一个很大的缓冲区

154
00:05:51,879 --> 00:05:53,930
它会把你按下回车以后

155
00:05:53,930 --> 00:05:55,670
送进去的东西都填在那

156
00:05:55,670 --> 00:05:58,769
123回车

157
00:05:58,769 --> 00:06:00,180
当然它会有一个标志

158
00:06:00,180 --> 00:06:02,740
说现在这里是结束的地方

159
00:06:02,939 --> 00:06:05,250
如果你的程序还没有读

160
00:06:05,250 --> 00:06:08,699
ok用户还输入了345回车

161
00:06:08,699 --> 00:06:13,740
那接下来三会出现在这儿

162
00:06:13,740 --> 00:06:15,620
说这里有

163
00:06:19,500 --> 00:06:21,620
四五

164
00:06:22,939 --> 00:06:25,629
然后当然还有一个回车

165
00:06:25,629 --> 00:06:29,519
然后还有一接下来是你的程序的事情了

166
00:06:29,519 --> 00:06:31,439
如果你的程序用的是get a cha

167
00:06:32,459 --> 00:06:36,009
ok他会从这儿读一个东西

168
00:06:36,009 --> 00:06:37,839
从这儿读一个东西

169
00:06:37,839 --> 00:06:39,370
从这儿读一个东西

170
00:06:39,370 --> 00:06:41,120
如果你程序用了caf

171
00:06:41,360 --> 00:06:42,920
那scaf会读得多一点

172
00:06:42,920 --> 00:06:45,040
比如说scaf说我们要百分号d了

173
00:06:45,439 --> 00:06:48,220
ok那他会把这个345变成一个整数

174
00:06:48,680 --> 00:06:49,970
大概就是这样子

175
00:06:49,970 --> 00:06:53,060
那如果无论是scaf还是给发现

176
00:06:53,060 --> 00:06:55,678
说遇到这个了呃

177
00:06:55,678 --> 00:06:57,358
首先得说我只是大概表明说

178
00:06:57,358 --> 00:06:58,319
他内部可能是这样

179
00:06:58,319 --> 00:06:59,579
他可能用其他的形式来表达

180
00:06:59,579 --> 00:07:01,319
说现在到了缓冲区的结尾哈

181
00:07:01,319 --> 00:07:02,990
他不一定真的是放在这个零

182
00:07:02,990 --> 00:07:05,029
假如说get charles gf遇到他

183
00:07:05,029 --> 00:07:08,019
ok那他的意思是说我们还要继续等的

184
00:07:08,019 --> 00:07:10,500
我们还要继续等用户输入东西的

185
00:07:10,500 --> 00:07:13,319
这就是为什么在我们那个程序里面

186
00:07:13,319 --> 00:07:14,610
在不断的循环当中

187
00:07:14,610 --> 00:07:16,319
我们还看到他在继续等我们输入

188
00:07:16,319 --> 00:07:16,620
对不对

189
00:07:16,620 --> 00:07:17,759
他并没有结束

190
00:07:18,459 --> 00:07:21,579
如果用户在这按了ctrl

191
00:07:23,779 --> 00:07:27,160
那ctrl d的结果你想是谁在收呢

192
00:07:27,160 --> 00:07:28,439
是sure在收

193
00:07:29,180 --> 00:07:32,899
需要看到ctrl d k他在这里填一个-1进去

194
00:07:32,899 --> 00:07:34,639
或者他用一种别的方式

195
00:07:34,639 --> 00:07:35,959
比如说另外有一个标志

196
00:07:35,959 --> 00:07:38,360
说这里另外一个变量叫做e o f

197
00:07:38,360 --> 00:07:39,699
如果这个变量为一

198
00:07:39,699 --> 00:07:42,269
表明说现在你这个东西已经是uf了

199
00:07:42,269 --> 00:07:44,310
具体的实现方式肯定不同的

200
00:07:44,310 --> 00:07:45,389
需要不同的操作系统

201
00:07:45,389 --> 00:07:47,310
甚至可能不同的这个编译器

202
00:07:47,310 --> 00:07:48,740
产生的东西都是不一样的

203
00:07:49,399 --> 00:07:52,120
然后你的程序在用gta读的时候

204
00:07:52,120 --> 00:07:54,100
会读到这个-1的结果

205
00:07:54,579 --> 00:07:57,639
如果你在这输入了ctrl c

206
00:07:58,158 --> 00:07:59,689
那这个shell做的事情

207
00:07:59,689 --> 00:08:02,088
就不会把这个ctrl c再放到任何地方去

208
00:08:02,088 --> 00:08:03,108
再去改任何东西

209
00:08:03,108 --> 00:08:06,399
这个shell直接把你的这个程序给关闭掉了

210
00:08:06,779 --> 00:08:09,899
所以这些都是这个需要在做的

211
00:08:10,199 --> 00:08:12,180
你的一个get c h a r

212
00:08:12,180 --> 00:08:14,670
只是在需要给你的这个缓冲区里面多东西

213
00:08:14,670 --> 00:08:16,920
你的cf也是需要给你的这个缓冲区里面

214
00:08:16,920 --> 00:08:17,939
去多东西

215
00:08:18,819 --> 00:08:23,100
而你用户的输入是让需要去填这个缓冲区

216
00:08:23,459 --> 00:08:27,509
这是我们在标准输入和你的程序当中

217
00:08:27,509 --> 00:08:28,560
发生的事情

218
00:08:28,560 --> 00:08:30,459
那个show所做的事情

