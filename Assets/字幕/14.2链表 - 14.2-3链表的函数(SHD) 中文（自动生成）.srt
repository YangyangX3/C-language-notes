1
00:00:04,839 --> 00:00:07,360
ok接下来的问题是

2
00:00:07,360 --> 00:00:10,778
现在如果我们从这儿开始看

3
00:00:10,778 --> 00:00:13,388
是从这一行一直到这一行

4
00:00:13,388 --> 00:00:15,939
我们在做的事情是我们制造了一个

5
00:00:15,939 --> 00:00:17,579
我们得到了一个number本之后

6
00:00:17,919 --> 00:00:20,439
我们制造了一个新的节点

7
00:00:20,439 --> 00:00:24,420
把它挂到这个link list的尾巴上去了

8
00:00:24,420 --> 00:00:28,019
如果我们想把它抽出来作为一个函数的话

9
00:00:29,399 --> 00:00:32,039
好我们现在把它剪切出来

10
00:00:32,039 --> 00:00:34,119
说我们有个函数叫做a

11
00:00:34,280 --> 00:00:35,780
我们要给他什么东西

12
00:00:35,780 --> 00:00:36,950
它能够a进去

13
00:00:36,950 --> 00:00:38,359
当然number一定要给他的

14
00:00:38,359 --> 00:00:38,659
对不对

15
00:00:38,659 --> 00:00:40,009
我们要add这个number

16
00:00:40,009 --> 00:00:42,219
然后我们是不是给他那个head

17
00:00:44,380 --> 00:00:46,079
所以如果是这样子的话

18
00:00:46,079 --> 00:00:50,479
那我们这个代码我把它放到这里来

19
00:00:51,179 --> 00:00:53,359
然后我们把它调整成一个函数

20
00:00:53,359 --> 00:00:54,649
其实我再给你们看

21
00:00:54,649 --> 00:00:57,609
我们通常会怎么来把一个函数给制造出来

22
00:00:57,609 --> 00:00:59,409
如果我们把函数写成这个样子

23
00:00:59,409 --> 00:01:00,250
说这是一个void

24
00:01:00,250 --> 00:01:00,969
叫做a

25
00:01:00,969 --> 00:01:02,530
他要的第一个参数是node

26
00:01:02,530 --> 00:01:04,459
the star是叫做head

27
00:01:04,459 --> 00:01:06,379
然后第二个参数是那个int叫做number

28
00:01:07,459 --> 00:01:08,219
对不对

29
00:01:08,540 --> 00:01:10,459
然后我们把这个demo

30
00:01:10,459 --> 00:01:12,799
这个这个函数的原型放到前面去

31
00:01:12,799 --> 00:01:13,879
说这儿有个函数的原型

32
00:01:13,879 --> 00:01:15,290
这儿有这样一个a的函数

33
00:01:15,290 --> 00:01:16,659
如果这么说

34
00:01:16,819 --> 00:01:18,399
你觉得有问题吗

35
00:01:22,799 --> 00:01:24,319
你没看到这有一个问题

36
00:01:24,319 --> 00:01:25,519
说这个是head

37
00:01:25,519 --> 00:01:25,939
对不对

38
00:01:26,959 --> 00:01:27,560
这个是head

39
00:01:27,560 --> 00:01:28,189
对不对

40
00:01:28,189 --> 00:01:31,040
我们在这个函数里面会去改head的

41
00:01:31,040 --> 00:01:32,810
但是这样传进来的这个head

42
00:01:32,810 --> 00:01:33,950
你在这说修改

43
00:01:33,950 --> 00:01:36,379
对我们在这里的这个head有用吗

44
00:01:37,040 --> 00:01:37,840
没有用

45
00:01:37,840 --> 00:01:38,709
对不对

46
00:01:38,709 --> 00:01:40,299
是不是没有用

47
00:01:42,280 --> 00:01:45,030
因为我们在这个函数里面会要修改head

48
00:01:45,030 --> 00:01:47,370
你传进去的head是不会被修改的

49
00:01:47,370 --> 00:01:48,879
怎么解决问题

50
00:01:52,280 --> 00:01:55,359
算法书上会说哦我们这样好了

51
00:01:55,359 --> 00:01:57,400
哎呀这件事情嘛搞那么复杂

52
00:01:57,400 --> 00:01:57,700
干什么

53
00:01:57,700 --> 00:02:00,920
这个no的新这个head是在外面一个全局变量

54
00:02:01,680 --> 00:02:02,159
嗯

55
00:02:02,159 --> 00:02:06,379
哼如果仅仅作为上课说啊

56
00:02:06,379 --> 00:02:08,300
我们来说明一下这件事情是这样的

57
00:02:08,300 --> 00:02:09,639
这当然没什么错

58
00:02:10,000 --> 00:02:11,740
不过你应该还记得

59
00:02:11,740 --> 00:02:13,870
我们在讲全局变量的时候说过

60
00:02:13,870 --> 00:02:15,500
全局变量是有害的

61
00:02:15,739 --> 00:02:17,598
你这样做的这个全局变量

62
00:02:17,598 --> 00:02:19,278
你这个程序是一次性的

63
00:02:19,278 --> 00:02:20,239
你的这个a的函数

64
00:02:20,239 --> 00:02:21,990
只能对这个全局变量起作用

65
00:02:21,990 --> 00:02:23,969
你的这个add函数怎么对人家的

66
00:02:23,969 --> 00:02:25,469
如果你的程序里面有一个链表

67
00:02:25,469 --> 00:02:25,830
两个列表

68
00:02:25,830 --> 00:02:26,430
有三个列表

69
00:02:26,430 --> 00:02:27,360
四个链表呢

70
00:02:28,800 --> 00:02:31,039
所以我们保持说这个东西是传进去的

71
00:02:31,039 --> 00:02:31,819
是好的

72
00:02:31,819 --> 00:02:33,580
不要去用全局变量

73
00:02:33,859 --> 00:02:37,038
那另外一个方案是说我们能不能这样

74
00:02:37,038 --> 00:02:39,539
既然我在里面会改head

75
00:02:39,780 --> 00:02:41,400
我在这儿做一个no的心

76
00:02:41,400 --> 00:02:43,199
然后说我结束的时候呢

77
00:02:43,199 --> 00:02:44,969
我会把这个head给传出去

78
00:02:44,969 --> 00:02:47,520
因此呢使用它的地方需要做一件事情

79
00:02:47,520 --> 00:02:49,659
说head等于had had

80
00:02:52,080 --> 00:02:53,240
这是个不错的进步

81
00:02:53,240 --> 00:02:53,479
对不对

82
00:02:53,479 --> 00:02:54,620
我没有用全局变量

83
00:02:54,620 --> 00:02:54,919
然后呢

84
00:02:54,919 --> 00:02:58,360
我的这个a的函数是线程安全的

85
00:02:58,360 --> 00:02:59,800
我的add函数没有用到全局变量

86
00:02:59,800 --> 00:03:03,300
我的add函数可以针对很多不同的link list

87
00:03:05,438 --> 00:03:07,460
唯一的小缺点是

88
00:03:07,699 --> 00:03:11,120
你这样的代码是要求使用你a的函数的

89
00:03:11,120 --> 00:03:15,639
程序员必须非常小心的要去做这件事情

90
00:03:16,319 --> 00:03:17,639
如果他忘了

91
00:03:19,139 --> 00:03:21,139
你没有强迫人家做这个事情

92
00:03:21,139 --> 00:03:23,060
你没有办法强迫人家做这个事情

93
00:03:23,060 --> 00:03:28,219
如果他忘了对空链表的这个a就是错的

94
00:03:31,080 --> 00:03:32,419
所以该怎么做

95
00:03:33,800 --> 00:03:35,219
我们还有第三种方案

96
00:03:35,979 --> 00:03:40,020
第三种方案是说嗯哼我们不要穿head进去

97
00:03:40,020 --> 00:03:41,840
我们穿head的指针进去

98
00:03:42,060 --> 00:03:45,300
所以这里接收的是node的指针的指针

99
00:03:45,300 --> 00:03:46,349
这是一个p head

100
00:03:46,349 --> 00:03:47,099
于是呢

101
00:03:47,099 --> 00:03:50,348
在下面所有的地方要用到head的地方啊

102
00:03:50,348 --> 00:03:53,379
我们就要说这是新那个p head

103
00:03:54,039 --> 00:03:56,969
最后当然return return已经没关系了

104
00:03:56,969 --> 00:04:00,599
但这里要不要最后再复制也没关系了

105
00:04:00,679 --> 00:04:01,878
这是个不错的方案

106
00:04:01,878 --> 00:04:02,658
对不对

107
00:04:02,658 --> 00:04:04,219
这是个不错的方案

108
00:04:04,579 --> 00:04:07,008
我们传进了一个指向指针的指针

109
00:04:07,008 --> 00:04:09,258
这样呢能够让我们在函数内部

110
00:04:09,258 --> 00:04:10,968
对那个指针的值做修改

111
00:04:10,968 --> 00:04:12,498
这就像我们做swap的时候

112
00:04:12,498 --> 00:04:13,449
遇到的情况一样

113
00:04:13,449 --> 00:04:14,949
传两个变量进去是没有意义的

114
00:04:14,949 --> 00:04:16,449
所以我们传两个变量指针进去

115
00:04:17,709 --> 00:04:21,399
不过我还有第四种办法

116
00:04:21,399 --> 00:04:22,959
第四种办法是这样

117
00:04:22,959 --> 00:04:26,560
我们不妨呢再来定义一个东西

118
00:04:26,560 --> 00:04:31,360
说我们有一个结构叫做list

119
00:04:33,220 --> 00:04:34,709
它叫做list

120
00:04:34,709 --> 00:04:36,420
当前呢它里头没什么

121
00:04:36,420 --> 00:04:37,680
只有一个node的指针

122
00:04:37,680 --> 00:04:38,560
叫做head

123
00:04:40,339 --> 00:04:41,339
然后

124
00:04:43,220 --> 00:04:46,000
我们在这儿说我们要传进去的呢

125
00:04:46,000 --> 00:04:51,360
是一个list的指针list

126
00:04:52,120 --> 00:04:54,339
当然你也可以把它叫做p list

127
00:04:54,339 --> 00:04:56,110
用来表明这是个指针

128
00:04:56,110 --> 00:05:00,269
接下来的事情在这里就不是说等于这个了

129
00:05:00,269 --> 00:05:04,459
而是说p list所指的那个head对吧

130
00:05:04,459 --> 00:05:07,589
因为list里头有一个head嘛啊

131
00:05:07,589 --> 00:05:09,720
然后当我这里要做这个修改的时候呢

132
00:05:09,720 --> 00:05:12,750
那就是说p list所指的那head等于p

133
00:05:12,750 --> 00:05:17,060
当然这个时候呢确实我用word也无所谓了啊

134
00:05:17,060 --> 00:05:20,389
反正我也不需要有人去在外面做那个

135
00:05:20,389 --> 00:05:20,870
辅助的事情

136
00:05:20,870 --> 00:05:21,889
他忘了也就忘了

137
00:05:21,889 --> 00:05:22,850
我会强制的

138
00:05:22,850 --> 00:05:24,350
那然后在这个地方呢

139
00:05:24,350 --> 00:05:26,060
我们就不是去建立一个head了

140
00:05:26,060 --> 00:05:29,009
我们要一个list的一个结构体

141
00:05:29,009 --> 00:05:30,629
指针都不是一个list结构体

142
00:05:30,629 --> 00:05:31,779
叫做list

143
00:05:32,000 --> 00:05:34,100
那个里头会有一个head

144
00:05:34,100 --> 00:05:36,379
当然一开始我们还得做点初始化的事情

145
00:05:36,379 --> 00:05:40,839
说那个list list list这个head呢等于

146
00:05:41,720 --> 00:05:44,379
所以这个就没有了

147
00:05:44,379 --> 00:05:46,750
完了以后在这里传进去的是什么

148
00:05:46,750 --> 00:05:49,819
传进去的是那个list的指针

149
00:05:52,360 --> 00:05:53,680
这样做有什么好处

150
00:05:53,939 --> 00:05:55,800
表面上看起来这个结果现在没什么

151
00:05:55,800 --> 00:05:57,000
里头就是一个指针对吧

152
00:05:57,000 --> 00:05:59,519
所以我传这个list的指针进去

153
00:05:59,519 --> 00:06:01,699
和穿那个head指针进去是一回事嘛

154
00:06:02,860 --> 00:06:03,990
好处在于

155
00:06:03,990 --> 00:06:06,899
我们用了一种自己定义的数据结构

156
00:06:06,899 --> 00:06:09,399
list来代表整个链表

157
00:06:09,439 --> 00:06:11,120
我们现在在这个数据结构里面

158
00:06:11,120 --> 00:06:12,629
只放了一个head以后

159
00:06:12,629 --> 00:06:13,920
我们可以有各种扩充

160
00:06:13,920 --> 00:06:15,750
比方说我举个例子

161
00:06:15,750 --> 00:06:18,629
大家觉不觉得说这find next这件事情

162
00:06:18,629 --> 00:06:21,610
我们要去做这样一个while循环

163
00:06:21,610 --> 00:06:22,939
这样的一件事情

164
00:06:25,459 --> 00:06:28,060
我每一次往里头爱的东西

165
00:06:28,060 --> 00:06:31,120
每一次他都要从head开始往后走走走

166
00:06:31,120 --> 00:06:33,540
走到最后一个是不是挺烦的

167
00:06:34,060 --> 00:06:36,639
我本来可以有另外一个东西

168
00:06:36,639 --> 00:06:38,259
我可以有另外一个指针

169
00:06:38,259 --> 00:06:40,319
永远指向它的最后一个

170
00:06:40,699 --> 00:06:42,500
当我往后面加一个东西的时候

171
00:06:42,500 --> 00:06:43,939
我会把那个指针指向新的

172
00:06:43,939 --> 00:06:45,019
加进去的那个结构

173
00:06:45,019 --> 00:06:46,370
所以如果这样的话

174
00:06:46,370 --> 00:06:48,189
也许我可以在这儿说

175
00:06:48,189 --> 00:06:50,079
我有一个no的心

176
00:06:50,079 --> 00:06:55,620
tale嗯嗯然后当然一开始的时候

177
00:06:56,379 --> 00:06:58,740
这个tale和head一样

178
00:06:58,740 --> 00:06:59,730
都要等于now

179
00:06:59,730 --> 00:07:01,560
当然这个时候

180
00:07:01,560 --> 00:07:04,379
我们这里要做的事情就不一样了

181
00:07:05,379 --> 00:07:07,689
这件事情我不展开了

182
00:07:07,689 --> 00:07:09,579
留给大家自己去考虑

183
00:07:09,579 --> 00:07:11,680
当我list里头有tale以后

184
00:07:11,680 --> 00:07:12,310
怎么做

185
00:07:12,310 --> 00:07:14,199
我们先来考虑list没有tale的情况

186
00:07:14,199 --> 00:07:15,279
怎么做好

187
00:07:15,740 --> 00:07:16,399
也就是说

188
00:07:16,399 --> 00:07:19,279
我们通过定义一个自己的数据结构

189
00:07:19,279 --> 00:07:24,199
来代表整个list给我们将来升级

190
00:07:24,199 --> 00:07:27,139
将来改进我们的list带来了无限的可能

191
00:07:27,139 --> 00:07:28,639
如果没有这件事情

192
00:07:28,639 --> 00:07:31,180
那我们只是一个悬在外面的head

193
00:07:33,000 --> 00:07:37,069
大多数的教科书不曾讲到这件事情

194
00:07:37,069 --> 00:07:39,209
因为对于链表来说

195
00:07:39,209 --> 00:07:40,350
大家都觉得说啊

196
00:07:40,350 --> 00:07:41,550
我讲完那些操作就可以了

197
00:07:41,550 --> 00:07:43,019
ai的remove search

198
00:07:43,019 --> 00:07:45,089
讲完那几个基本的操作就可以了

199
00:07:45,089 --> 00:07:48,480
但是对于一个工程化的程序来说

200
00:07:48,480 --> 00:07:50,069
如果你不告诉人家说

201
00:07:50,069 --> 00:07:53,060
你怎么样来合理的安排这些东西

202
00:07:53,079 --> 00:07:54,480
那是不够的

203
00:07:54,779 --> 00:07:57,660
你光知道最基本的我怎么在里面放东西

204
00:07:57,660 --> 00:07:58,290
查东西

205
00:07:58,290 --> 00:07:59,920
那个还很简单

