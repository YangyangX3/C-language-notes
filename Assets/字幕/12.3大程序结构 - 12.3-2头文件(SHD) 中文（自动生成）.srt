1
00:00:04,480 --> 00:00:06,400
其实我们刚才这段代码当中呢

2
00:00:06,400 --> 00:00:07,960
有一个小细节啊

3
00:00:07,960 --> 00:00:09,349
我不知道大家有没有注意到

4
00:00:09,349 --> 00:00:11,240
在我们的命点c里头啊

5
00:00:11,240 --> 00:00:14,720
我们留了max的那个原型声明在这

6
00:00:15,319 --> 00:00:16,368
也就是说

7
00:00:16,368 --> 00:00:19,390
其实当编译器在编译命点c的时候

8
00:00:19,390 --> 00:00:21,609
它根据max的这个原型声明

9
00:00:21,609 --> 00:00:22,750
是可以知道

10
00:00:22,750 --> 00:00:26,280
我们在这儿对max的这个调用是正确的

11
00:00:27,399 --> 00:00:30,750
假如我们把这个原型声明给注释掉了

12
00:00:30,750 --> 00:00:33,418
那结果会怎么样呢

13
00:00:38,179 --> 00:00:39,640
没有任何问题

14
00:00:39,640 --> 00:00:41,740
运行也是对的

15
00:00:41,740 --> 00:00:42,789
为什么呢

16
00:00:42,789 --> 00:00:47,098
因为如果编译器没有看到这个圆形声明

17
00:00:47,159 --> 00:00:49,750
编译器会猜啊

18
00:00:49,750 --> 00:00:51,820
这是c语言古老的传统

19
00:00:51,820 --> 00:00:55,000
它会猜测说我们的这个max函数呢

20
00:00:55,000 --> 00:00:57,768
所有的东西都是int类型的

21
00:00:57,768 --> 00:00:59,929
a和b是int max

22
00:00:59,929 --> 00:01:01,189
返回的也是int

23
00:01:01,189 --> 00:01:06,149
它会以这个方式来猜测这些东西好

24
00:01:06,149 --> 00:01:10,379
那假如我们现在我们的max换了

25
00:01:10,379 --> 00:01:12,509
我们把这里的int改成了double

26
00:01:12,509 --> 00:01:14,659
我们把返回类型也改成double

27
00:01:15,859 --> 00:01:17,140
这个时候会怎么样呢

28
00:01:18,219 --> 00:01:20,640
这个时候我们再来编译它

29
00:01:23,400 --> 00:01:26,390
编译过了没有任何错误

30
00:01:26,390 --> 00:01:28,879
但是你想其实这里头是有问题的

31
00:01:28,879 --> 00:01:32,000
因为我们给的a和b都是int

32
00:01:32,079 --> 00:01:34,420
我们以为max返回的是int

33
00:01:34,420 --> 00:01:35,980
所以我们用了百分号d

34
00:01:35,980 --> 00:01:38,099
然后我们来执行一下

35
00:01:40,239 --> 00:01:41,939
为什么有这么奇怪的一个数字

36
00:01:41,939 --> 00:01:44,599
什么4201这什么东西

37
00:01:45,739 --> 00:01:47,079
为什么会这样呢

38
00:01:47,079 --> 00:01:50,959
因为我们现在的局面是说

39
00:01:51,200 --> 00:01:54,140
我们在编译器在编译main.c的时候

40
00:01:54,140 --> 00:01:55,539
他是猜的

41
00:01:55,540 --> 00:01:59,200
他以为你的那个max呢要两个int

42
00:01:59,200 --> 00:02:00,430
并且返回一个int

43
00:02:00,430 --> 00:02:02,290
所以他按照这种方式

44
00:02:02,290 --> 00:02:05,250
对编译产生的代码做了安排

45
00:02:05,250 --> 00:02:07,590
会在这儿把两个int传给max

46
00:02:07,590 --> 00:02:09,810
会把max返回的那个结果作为mac

47
00:02:09,810 --> 00:02:11,800
作为int传给print f

48
00:02:11,800 --> 00:02:13,000
然后他留下了

49
00:02:13,000 --> 00:02:18,770
说我要在这儿去访问那个调用那个max函数

50
00:02:18,770 --> 00:02:20,750
然后在max这边

51
00:02:20,750 --> 00:02:23,870
编译器在编译max的时候也看得很明白哦

52
00:02:23,870 --> 00:02:25,430
你的这个max呢要两个double

53
00:02:25,430 --> 00:02:26,659
并且会返回一个double

54
00:02:26,659 --> 00:02:30,530
所以max和main都各自编译完成了

55
00:02:30,530 --> 00:02:33,300
然后链接器把它们链接起来的时候

56
00:02:33,899 --> 00:02:37,699
链接器在这里会去调用那个

57
00:02:37,699 --> 00:02:39,199
会练到那个max函数

58
00:02:39,199 --> 00:02:39,979
这没有问题

59
00:02:39,979 --> 00:02:42,348
他确实练到了正确的max函数

60
00:02:42,348 --> 00:02:45,598
可是传进去的东西错了

61
00:02:45,598 --> 00:02:47,439
传出来的东西也是错的

62
00:02:50,459 --> 00:02:55,019
那怎么能够保证说我在main这边对max的使用

63
00:02:55,019 --> 00:02:56,218
和在max这边

64
00:02:56,218 --> 00:03:00,240
它所定义的那个max函数是一致的呢

65
00:03:00,240 --> 00:03:03,259
我们需要有一个中间的媒介

66
00:03:04,020 --> 00:03:06,379
这个中间的媒介就是头文件

67
00:03:07,580 --> 00:03:09,539
以点h结尾的一个头文件

68
00:03:09,699 --> 00:03:14,409
我们把max的原型放到那个头文件里头去

69
00:03:14,409 --> 00:03:17,439
然后在需要使用这个max的地方

70
00:03:17,439 --> 00:03:20,099
我们去引用它怎么做呢

71
00:03:20,099 --> 00:03:21,270
我们来试一下

72
00:03:21,270 --> 00:03:27,139
我们需要再新建一个源代码文件

73
00:03:28,158 --> 00:03:30,218
这时候呢因为我们已经有一个项目了

74
00:03:30,218 --> 00:03:32,919
他会问我要不要在项目中添加新单元

75
00:03:32,919 --> 00:03:34,149
yes样的

76
00:03:34,149 --> 00:03:36,649
所以这是在项目当中的一个新的东西

77
00:03:36,649 --> 00:03:38,359
那我们在里面放的呢

78
00:03:38,359 --> 00:03:42,659
就是原来我们在main里头的这个max的原型

79
00:03:45,899 --> 00:03:47,389
好就这么一个就够了

80
00:03:47,389 --> 00:03:48,649
我们把它保存一下

81
00:03:48,649 --> 00:03:50,740
叫做max.h

82
00:03:52,020 --> 00:03:55,189
所以现在我们有了一个新的头文件了

83
00:03:55,189 --> 00:03:56,930
接下来我们在main这里

84
00:03:56,930 --> 00:03:58,340
我们不需要这句话了

85
00:03:58,340 --> 00:04:03,500
我们需要include我们自己的这个max.h

86
00:04:03,639 --> 00:04:06,599
同样的在max.sinner

87
00:04:08,498 --> 00:04:12,099
我们也来include这个max d h

88
00:04:15,878 --> 00:04:16,559
记得吧

89
00:04:16,559 --> 00:04:17,999
我们现在的max h里面说

90
00:04:17,999 --> 00:04:19,858
这个max函数是全int的

91
00:04:19,858 --> 00:04:21,238
如果这个样子

92
00:04:21,238 --> 00:04:22,220
我们来编译

93
00:04:24,480 --> 00:04:25,579
就会出错了

94
00:04:25,579 --> 00:04:29,769
因为在这个max.c里头说max是全double的

95
00:04:29,769 --> 00:04:32,620
而点h里面说了max全int的

96
00:04:32,620 --> 00:04:35,819
于是编译器发现不一致了

97
00:04:36,980 --> 00:04:38,110
怎么会发现呢

98
00:04:38,110 --> 00:04:39,189
我们一会儿来说

99
00:04:39,189 --> 00:04:40,720
我们先把它改回来

100
00:04:40,839 --> 00:04:43,000
我们先让这个东西能够正确的跑起来

101
00:04:43,000 --> 00:04:45,759
然后我们再来说这个include

102
00:04:45,759 --> 00:04:48,060
这个头文件到底发生了什么事情

103
00:04:50,779 --> 00:04:52,329
k编译过了

104
00:04:52,329 --> 00:04:55,269
运行ok也没问题了

105
00:04:55,269 --> 00:04:58,240
假如说现在我们这样这个max呢

106
00:04:58,240 --> 00:04:59,500
真的就是double的

107
00:05:02,000 --> 00:05:04,420
真的就是double

108
00:05:04,779 --> 00:05:07,620
我们把点h里头呢相应的也改掉

109
00:05:07,620 --> 00:05:08,939
说啊我这是double的

110
00:05:08,939 --> 00:05:10,439
那么当然在命点c

111
00:05:10,439 --> 00:05:13,000
这呢我需要把百分号d改成百分号f

112
00:05:13,420 --> 00:05:15,579
至于说把两个整形变量传给他

113
00:05:15,579 --> 00:05:16,120
没有问题

114
00:05:16,120 --> 00:05:18,160
编译器会替我们自动做什么类型

115
00:05:18,160 --> 00:05:19,240
自动的转换

116
00:05:19,240 --> 00:05:19,750
对不对

117
00:05:19,750 --> 00:05:21,779
好这个时候编译器吗

118
00:05:24,399 --> 00:05:28,300
运行呢六点也没问题了

119
00:05:28,420 --> 00:05:29,680
所以我们刚才做的事情

120
00:05:29,680 --> 00:05:33,220
就是把函数的原型放到了一个头文件当中

121
00:05:33,220 --> 00:05:36,500
然后把这个头文件呢当然也放在项目当中

122
00:05:36,538 --> 00:05:39,629
所有要调用这个函数的地方

123
00:05:39,629 --> 00:05:41,759
比如说命点cd我要调用这个max

124
00:05:41,759 --> 00:05:44,480
我把这个头文件include一下

125
00:05:44,620 --> 00:05:46,120
在max.c里头

126
00:05:46,120 --> 00:05:47,740
因为定义了那个max函数

127
00:05:47,740 --> 00:05:49,600
所以我也include那个头文件

128
00:05:49,600 --> 00:05:50,709
这样的话呢

129
00:05:50,709 --> 00:05:52,839
编译器在编译这个命点c的时候

130
00:05:52,839 --> 00:05:54,100
他就能够知道哦

131
00:05:54,100 --> 00:05:55,779
原来max函数长这个样子

132
00:05:56,279 --> 00:05:57,540
要么是全double的

133
00:05:57,540 --> 00:05:58,439
要么是全印证

134
00:05:58,439 --> 00:05:59,160
然后呢

135
00:05:59,160 --> 00:06:02,180
根据这个来判断你对max的使用是不是对的

136
00:06:02,180 --> 00:06:03,740
在定义max的地方

137
00:06:03,740 --> 00:06:07,449
编译器也根据max.h里面的这个原型声明

138
00:06:07,449 --> 00:06:10,509
来决定说你的这个max函数的定义

139
00:06:10,509 --> 00:06:12,300
是不是符合这个头文件

140
00:06:13,040 --> 00:06:15,819
这个头文件形成了一个桥梁

141
00:06:15,819 --> 00:06:18,310
或者甚至可以说它是一个合同

142
00:06:18,310 --> 00:06:21,329
它是max提供给别人的一个合同

143
00:06:21,329 --> 00:06:23,850
他承诺说我的max长这个样子

144
00:06:23,850 --> 00:06:24,899
你要用我的max吗

145
00:06:24,899 --> 00:06:27,339
你就include我的max h

146
00:06:29,199 --> 00:06:32,649
这个include它是一个编译预处理指令

147
00:06:32,649 --> 00:06:33,639
和红一样

148
00:06:33,639 --> 00:06:36,029
它在编译之前就已经处理了

149
00:06:36,029 --> 00:06:39,089
他会把那个文件的全部文本内容

150
00:06:39,089 --> 00:06:42,000
原封不动的插入到它所在的地方

151
00:06:42,000 --> 00:06:44,579
这个事情我们再来看一下

152
00:06:44,579 --> 00:06:47,240
看现在我们在我们这个目录底下呢

153
00:06:47,240 --> 00:06:47,839
有命点c

154
00:06:47,839 --> 00:06:49,610
有max.c和max等于h

155
00:06:49,610 --> 00:06:51,709
那在命令行怎么样能够呃

156
00:06:51,709 --> 00:06:52,790
好像做一个项目一样

157
00:06:52,790 --> 00:06:54,410
去把他们给连接起来呢

158
00:06:54,410 --> 00:06:56,139
最简单的方式是这样的

159
00:06:56,579 --> 00:06:58,980
所有的这些点c文件放到一起

160
00:06:58,980 --> 00:07:00,480
但是不要把点a取文件放进来啊

161
00:07:00,480 --> 00:07:01,439
我就说g c c

162
00:07:01,439 --> 00:07:04,930
我要命点c和max.c这样一编译呢

163
00:07:04,930 --> 00:07:07,660
他就给我形成了一个最后的可执行的东西

164
00:07:07,660 --> 00:07:08,500
那个a.out

165
00:07:08,500 --> 00:07:09,879
当然我们执行这个a.out

166
00:07:09,879 --> 00:07:11,240
的结果还是一样的

167
00:07:11,399 --> 00:07:14,579
那我们可以用刚才的手段说

168
00:07:14,579 --> 00:07:18,839
我们要save tes呃

169
00:07:18,839 --> 00:07:22,680
我们可以先让它只编译点c文件

170
00:07:22,680 --> 00:07:25,079
加上一个选项杠c它就只做编译

171
00:07:25,079 --> 00:07:25,920
不做链接

172
00:07:25,920 --> 00:07:28,000
不去试图产生a.out

173
00:07:28,759 --> 00:07:31,538
ok这时候呢他给我们产生了命的点i

174
00:07:31,538 --> 00:07:33,218
点s.o的一些东西

175
00:07:33,218 --> 00:07:36,509
我们要关心的是那个命点i嗯

176
00:07:36,509 --> 00:07:38,189
现在有一点点小了啊

177
00:07:38,189 --> 00:07:39,149
我们这样来看

178
00:07:39,149 --> 00:07:43,379
我们还是继续用tail来看mdi的最后几行

179
00:07:45,579 --> 00:07:46,319
不够多

180
00:07:46,319 --> 00:07:47,848
我们稍微多一点

181
00:07:47,848 --> 00:07:49,468
杠n50 吧

182
00:07:49,468 --> 00:07:50,939
我们看他的武士哈

183
00:07:50,939 --> 00:07:55,939
我们看到在这个地方

184
00:07:55,939 --> 00:07:57,769
是我们的那个main内部分啊

185
00:07:57,769 --> 00:07:59,598
然后往上面走一点

186
00:07:59,598 --> 00:08:00,899
我们看到了这一行

187
00:08:00,959 --> 00:08:02,139
这是什么

188
00:08:02,139 --> 00:08:04,420
这是那个max.h

189
00:08:04,420 --> 00:08:07,300
但这里的井号开头的东西在点i文件里面

190
00:08:07,300 --> 00:08:08,860
井号开头的是注释啊

191
00:08:08,860 --> 00:08:11,279
他说呢在命点c的第二行

192
00:08:11,279 --> 00:08:13,439
他把max.h放进来了

193
00:08:13,439 --> 00:08:15,689
然后下面是max.h的第一行的东西

194
00:08:15,689 --> 00:08:17,040
就是那个double max

195
00:08:17,040 --> 00:08:18,660
这一行就是出现在max.h里面

196
00:08:18,660 --> 00:08:19,918
刚刚放进去的东西

197
00:08:19,918 --> 00:08:21,899
所以include做什么

198
00:08:21,899 --> 00:08:23,829
include就是把那个头文件啊

199
00:08:23,829 --> 00:08:24,610
里头

200
00:08:24,610 --> 00:08:28,180
所有的文本插入到include所在的那一行

201
00:08:28,180 --> 00:08:29,800
就做了这一件事情

202
00:08:30,038 --> 00:08:32,859
include有两种形式呃

203
00:08:32,859 --> 00:08:34,239
如果你刚才留意的话

204
00:08:34,239 --> 00:08:35,318
我们在in.c里面

205
00:08:35,318 --> 00:08:37,219
其实就用了它的两种形式

206
00:08:37,659 --> 00:08:39,490
我们的第一个include

207
00:08:39,490 --> 00:08:41,440
include那个s t d l.h的时候

208
00:08:41,440 --> 00:08:42,580
用的是尖括号

209
00:08:42,580 --> 00:08:45,279
第二个include我们自己的一个max h的时候

210
00:08:45,279 --> 00:08:46,539
用的是双引号

211
00:08:46,539 --> 00:08:48,039
这两者有什么区别呢

212
00:08:48,039 --> 00:08:49,419
如果是双引号的话

213
00:08:49,419 --> 00:08:50,620
他的意思是说

214
00:08:50,620 --> 00:08:51,370
你呢

215
00:08:51,370 --> 00:08:54,690
首先在我当前的这个点c所在的

216
00:08:54,690 --> 00:08:56,399
那个目录底下去找

217
00:08:56,399 --> 00:08:58,568
有没有那个就是max.h

218
00:08:58,568 --> 00:09:00,969
如果有就打开那个如果没有

219
00:09:00,969 --> 00:09:03,099
再到系统指定的地方去找

220
00:09:03,259 --> 00:09:05,360
而如果你用尖括号的话呢

221
00:09:05,360 --> 00:09:07,039
就不会找当前目录了

222
00:09:07,039 --> 00:09:09,318
那么就只是去找系统指定了

223
00:09:09,899 --> 00:09:13,320
所以一般来说你自己的电源取文件

224
00:09:13,320 --> 00:09:15,599
你自己的头文件你要用双引号

225
00:09:15,779 --> 00:09:18,570
而系统给的标准库的

226
00:09:18,570 --> 00:09:20,240
那么有件括号

227
00:09:20,779 --> 00:09:23,710
当然这个所谓系统指定的目录在哪呢

228
00:09:23,710 --> 00:09:26,019
一般来说现在的编译器呢

229
00:09:26,019 --> 00:09:29,839
他自己知道他的那个标准头文件在哪

230
00:09:29,980 --> 00:09:33,039
对于unix系统来说它在哪呢

231
00:09:33,279 --> 00:09:35,139
对于unix系统来说呢

232
00:09:35,139 --> 00:09:37,659
你可以在跟下的usr目录下面

233
00:09:37,659 --> 00:09:39,460
找到一个叫做include的目录

234
00:09:39,460 --> 00:09:40,419
在那里呢

235
00:09:40,419 --> 00:09:41,080
你会发现

236
00:09:41,080 --> 00:09:46,220
比如说我们的这个s t b l.h啊

237
00:09:46,220 --> 00:09:48,919
我们可以看看这个s t d i o.h

238
00:09:48,919 --> 00:09:49,879
里面有什么

239
00:09:49,879 --> 00:09:52,879
一开头有好多页的版权声明啊

240
00:09:52,879 --> 00:09:54,389
然后有各种各样的东西

241
00:09:54,389 --> 00:09:58,169
当然你仔细看会在里头找到print f的原型

242
00:09:58,169 --> 00:09:58,980
声明等等

243
00:09:58,980 --> 00:10:00,509
但是呢你在里面绝对找不到

244
00:10:00,509 --> 00:10:02,009
print f的源代码啊

245
00:10:02,009 --> 00:10:06,980
呃他在别的地方对macomacintosh呢

246
00:10:06,980 --> 00:10:08,600
你你装了xcode之后呢

247
00:10:08,600 --> 00:10:12,269
这个啊他的这个这个位置有点奇怪哈

248
00:10:12,269 --> 00:10:14,610
呃需要到一个比较古怪的地方去找出来

249
00:10:14,610 --> 00:10:15,690
我们就不去找他了

250
00:10:15,690 --> 00:10:17,429
对于windows这个头文

251
00:10:17,429 --> 00:10:19,379
这个标准库的头文件在哪呢

252
00:10:19,440 --> 00:10:24,730
在你的这个d vc加加的

253
00:10:24,730 --> 00:10:27,220
明基w32 下的include目录下面

254
00:10:27,220 --> 00:10:29,379
这部分的编译器自己知道啊

255
00:10:29,379 --> 00:10:30,250
标准头文件

256
00:10:30,250 --> 00:10:32,889
另外呢呃我们也可以通过环境变量

257
00:10:32,889 --> 00:10:35,529
通过编译器的命令行参数也可以指定

258
00:10:35,529 --> 00:10:37,559
我们去哪儿找这个头文件呃

259
00:10:37,559 --> 00:10:38,700
在dvc加加里面呢

260
00:10:38,700 --> 00:10:40,799
也有地方让你去做这个选项的设置

261
00:10:40,799 --> 00:10:43,250
当然这些高级的应用啊

262
00:10:43,250 --> 00:10:45,500
一开始大家肯定还用不上哈

263
00:10:46,600 --> 00:10:49,529
那么这个呃include呢

264
00:10:49,529 --> 00:10:51,629
传统教学上面会有个误区啊

265
00:10:51,629 --> 00:10:54,299
呃有的教科书上甚至也会这么写

266
00:10:54,299 --> 00:10:54,720
说啊

267
00:10:54,720 --> 00:10:57,669
我要呃用include引入一个库啊

268
00:10:57,669 --> 00:10:59,830
呃我要用标准输入输出了

269
00:10:59,830 --> 00:11:01,870
所以我就include s t d l点进去

270
00:11:01,870 --> 00:11:03,669
我就把include s t l点进去

271
00:11:03,669 --> 00:11:04,210
做的事情

272
00:11:04,210 --> 00:11:06,899
就是把s t d l那个库给引进来了

273
00:11:06,899 --> 00:11:09,818
这是一个错误的理解啊

274
00:11:09,840 --> 00:11:11,879
当然有的时候我们会觉得说呃

275
00:11:11,879 --> 00:11:14,490
我们以这种方式去教学生

276
00:11:14,490 --> 00:11:15,870
学生比较容易接受了

277
00:11:15,870 --> 00:11:17,779
但是这不是事实的真相

278
00:11:17,779 --> 00:11:21,019
实际上include只做一个非常普通的事情

279
00:11:21,019 --> 00:11:23,860
就是后面所表达的那个

280
00:11:23,860 --> 00:11:25,149
无论是监控还是双引号

281
00:11:25,149 --> 00:11:27,458
那个文件里头的内容

282
00:11:27,458 --> 00:11:30,698
原封不动地插入到include所在的那一行来

283
00:11:30,698 --> 00:11:31,808
就做这一件事情

284
00:11:31,808 --> 00:11:33,219
别的什么都不做

285
00:11:33,919 --> 00:11:36,850
s d d l.h里面只有print f的原型

286
00:11:36,850 --> 00:11:38,440
pf的源代码

287
00:11:38,440 --> 00:11:39,820
print f的编译好以后的

288
00:11:39,820 --> 00:11:41,500
产生的那个目标代码文件

289
00:11:41,879 --> 00:11:43,620
都不在那个点a区里头

290
00:11:43,620 --> 00:11:44,580
他在别的地方

291
00:11:44,580 --> 00:11:47,019
在某个点lb会在某个点a文件里头

292
00:11:47,080 --> 00:11:50,259
而现代的c语言的编译器会默认

293
00:11:50,259 --> 00:11:55,490
他会把所有的标准库这个代码啊

294
00:11:55,490 --> 00:11:58,960
都和你的源代码去链接在一起

295
00:11:58,960 --> 00:12:00,279
形成一个可执行文件

296
00:12:00,279 --> 00:12:02,919
当然当中用不到的它会自动帮你拿掉

297
00:12:02,919 --> 00:12:04,720
所以你的print f skin f

298
00:12:04,720 --> 00:12:06,578
它会自动帮你连接在一起的

299
00:12:06,620 --> 00:12:09,799
因此你如果没有include s t d l dh

300
00:12:09,799 --> 00:12:12,428
或者之前有同学在讨论区已经发现说诶

301
00:12:12,428 --> 00:12:14,828
他没有include那个s t d lib.h

302
00:12:14,828 --> 00:12:16,688
但是mlock呢好像也能用

303
00:12:16,688 --> 00:12:18,690
虽然编译的时候给了几句warning

304
00:12:18,690 --> 00:12:19,830
但是也能用

305
00:12:19,830 --> 00:12:20,899
为什么

306
00:12:20,980 --> 00:12:25,029
就是因为malloc的代码并不在那个点区里头

307
00:12:25,029 --> 00:12:26,500
那个点进去里面有什么呢

308
00:12:26,500 --> 00:12:28,029
s t d lib点里面有什么呢

309
00:12:28,029 --> 00:12:29,578
有mc的原型

310
00:12:29,580 --> 00:12:32,610
所以当麦克的原型不在

311
00:12:32,610 --> 00:12:35,039
你没有include那个点h编译器会猜

312
00:12:35,039 --> 00:12:36,360
就像我们前面发生的事一样

313
00:12:36,360 --> 00:12:40,129
他猜他以为那个malloc要的输入是int

314
00:12:40,129 --> 00:12:41,659
返回的也是int

315
00:12:41,659 --> 00:12:45,289
现在呢刚好它的输入是一个size t

316
00:12:45,289 --> 00:12:47,899
可以看作是int返回是一个指针

317
00:12:47,899 --> 00:12:49,279
可以看作是int

318
00:12:49,279 --> 00:12:50,599
结果呢你就对了

319
00:12:50,820 --> 00:12:52,438
只是因为这个缘故啊

320
00:12:54,500 --> 00:12:57,070
那我们的头文件的贴式呢

321
00:12:57,070 --> 00:12:57,850
是说

322
00:12:57,850 --> 00:13:01,419
我们在使用定义和使用这个函数的地方

323
00:13:01,419 --> 00:13:03,099
都应该包含这个头文件

324
00:13:03,879 --> 00:13:04,860
使用它的地方

325
00:13:04,860 --> 00:13:07,019
你有头文件编译器能够替你检查

326
00:13:07,019 --> 00:13:08,940
说你对这个函数的调用是不是对的

327
00:13:08,940 --> 00:13:10,419
给的参数是不是对的

328
00:13:10,639 --> 00:13:13,639
定义它的地方你包含了这个头文件

329
00:13:13,639 --> 00:13:14,899
编译器会给你检查

330
00:13:14,899 --> 00:13:17,480
你对外宣称的这个函数的原型

331
00:13:17,480 --> 00:13:20,039
和实际这个函数的定义是不是一致的

332
00:13:20,100 --> 00:13:21,899
所以一般的做法就是说

333
00:13:21,899 --> 00:13:24,279
任何点c当然除了命啊

334
00:13:24,279 --> 00:13:26,769
因为那个命是不需要你再去给出原形的

335
00:13:26,769 --> 00:13:29,649
一般的点c都应该有一个对应的同名的点

336
00:13:29,649 --> 00:13:31,690
比如说max.c对应一个max.h

337
00:13:31,690 --> 00:13:32,389
然后呢

338
00:13:32,389 --> 00:13:35,149
把所有对外公开的函数的原型

339
00:13:35,149 --> 00:13:37,429
和全局变量的声明都放进去啊

340
00:13:37,429 --> 00:13:38,720
我们还没有讲这个事情

341
00:13:38,720 --> 00:13:43,379
全局变量是可以在多个点c之间共享的

342
00:13:43,840 --> 00:13:45,190
但是前提是

343
00:13:45,190 --> 00:13:47,740
你也要有恰当的方式去告诉别人

344
00:13:47,740 --> 00:13:49,299
这个全局变量的原型是什么

345
00:13:49,299 --> 00:13:50,938
这事儿我们一会儿再来说

346
00:13:51,899 --> 00:13:55,580
那假如说你有函数放在某个点c里头

347
00:13:55,580 --> 00:13:57,159
你不希望别人用

348
00:13:57,159 --> 00:13:59,259
但是你希望这个点c里头的

349
00:13:59,259 --> 00:14:00,399
别的函数能够用

350
00:14:00,399 --> 00:14:02,500
你可以在这个函数前面加上

351
00:14:02,500 --> 00:14:03,859
steady的关键字

352
00:14:03,940 --> 00:14:07,120
就是我们那个静态本地变量前面那个static

353
00:14:07,120 --> 00:14:08,850
同样的关键词static

354
00:14:08,850 --> 00:14:11,909
如果在一个全局的函数前面加上static

355
00:14:11,909 --> 00:14:13,350
它就成为局部的函数

356
00:14:13,350 --> 00:14:15,409
也就是说只有这个点c里面能够用

357
00:14:15,409 --> 00:14:17,750
如果在一个全局变量前面加上static

358
00:14:17,750 --> 00:14:18,769
注意是全局变量

359
00:14:18,769 --> 00:14:19,629
不是本地变量

360
00:14:19,629 --> 00:14:21,190
全局变量前面加sting

361
00:14:21,190 --> 00:14:22,480
那么他的意思是说

362
00:14:22,480 --> 00:14:23,440
这个全局变量

363
00:14:23,440 --> 00:14:25,399
只有在这个点c里面才能够用

