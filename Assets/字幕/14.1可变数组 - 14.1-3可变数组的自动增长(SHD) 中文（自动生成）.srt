1
00:00:04,660 --> 00:00:07,750
最后infit怎么长大呢

2
00:00:07,750 --> 00:00:10,419
嗯哼怎么长大

3
00:00:11,380 --> 00:00:14,039
其实他他不能长大

4
00:00:14,039 --> 00:00:14,580
对不对

5
00:00:14,580 --> 00:00:16,760
mlock出来的东西不能长大

6
00:00:17,760 --> 00:00:20,210
所以我们的方案是这样啊

7
00:00:20,210 --> 00:00:23,829
我们重新去申请一块新的空间

8
00:00:23,829 --> 00:00:25,809
我们需要有一个int int

9
00:00:25,809 --> 00:00:30,239
等于我们去ma一个一块新的空间

10
00:00:30,239 --> 00:00:35,880
这块空间呢是a的size加上那个more size

11
00:00:35,880 --> 00:00:38,409
当然我们还得有一堆括号

12
00:00:38,409 --> 00:00:42,779
因为还得size of int去乘这个东西

13
00:00:43,780 --> 00:00:45,119
得到一块新的空间

14
00:00:45,119 --> 00:00:46,560
接下来我们还得做一件事情

15
00:00:46,560 --> 00:00:48,479
我们得把老的空间的东西

16
00:00:48,479 --> 00:00:50,399
逐一复制到新的空间去

17
00:00:50,399 --> 00:00:53,329
所以我们需要有一个循环数i等于零

18
00:00:54,710 --> 00:00:59,259
i小于a的size i加加

19
00:00:59,259 --> 00:01:00,939
然后循环的每一步做的事情

20
00:01:00,939 --> 00:01:06,379
无非是p的i等于a的arread

21
00:01:06,920 --> 00:01:09,280
于是呢我们就拷贝得到了

22
00:01:09,280 --> 00:01:11,409
原来那个数组里头所有的东西

23
00:01:11,409 --> 00:01:17,459
完了以后我们还得别忘了free那个a的array

24
00:01:17,459 --> 00:01:21,599
然后让a的array呢等于p

25
00:01:21,599 --> 00:01:27,530
让a的size呢加等于我们现在的这个more size

26
00:01:27,530 --> 00:01:31,039
这叫做infit长大

27
00:01:32,219 --> 00:01:33,500
那可什么时候长大

28
00:01:33,500 --> 00:01:35,239
当然你可以这样子考虑

29
00:01:35,239 --> 00:01:38,799
比如说我们写一个循环

30
00:01:38,799 --> 00:01:43,180
比方说我们现在呢在这呢需要有个while

31
00:01:43,180 --> 00:01:45,679
一的循环无限循环

32
00:01:46,859 --> 00:01:49,739
然后我们会skin一些数字进来

33
00:01:50,379 --> 00:01:51,719
读进来之后呢

34
00:01:52,980 --> 00:01:59,599
我们还需要有个计数器o我们会让这个

35
00:02:01,540 --> 00:02:05,420
新a rat a

36
00:02:05,420 --> 00:02:09,110
这个数组在c n t加加那个位置上

37
00:02:09,110 --> 00:02:12,479
等于number啊

38
00:02:12,479 --> 00:02:13,560
当然其实我们还可以把这个事情

39
00:02:13,560 --> 00:02:14,280
做的更简单一点

40
00:02:14,280 --> 00:02:14,759
对不对

41
00:02:14,759 --> 00:02:15,900
这两句话可以合起来

42
00:02:15,900 --> 00:02:17,280
那个number是可以不要的

43
00:02:17,280 --> 00:02:18,900
ok我们就把它搞得很古怪吧

44
00:02:18,900 --> 00:02:20,680
这事看上去已经很古怪了

45
00:02:21,039 --> 00:02:24,460
skin f百分号d它需要有一个指针

46
00:02:24,460 --> 00:02:28,780
我们给它的指针是array at and a c n t

47
00:02:28,780 --> 00:02:30,300
加加加

48
00:02:33,618 --> 00:02:35,050
这两行就不需要

49
00:02:35,050 --> 00:02:36,490
于是我们就不断的把一些东西

50
00:02:36,490 --> 00:02:37,509
放到里头去了

51
00:02:37,509 --> 00:02:39,610
所以在某一个时刻

52
00:02:39,610 --> 00:02:43,740
那个are at会发现说你给我的那个index越界了

53
00:02:45,899 --> 00:02:47,449
那个ariat

54
00:02:47,449 --> 00:02:55,979
如果有一天发现说index大于等于a的size了

55
00:02:57,278 --> 00:02:58,079
对不对

56
00:02:58,079 --> 00:02:59,990
这时候index已经越界了嘛

57
00:02:59,990 --> 00:03:02,330
当然如果要把代码写得完整一点

58
00:03:02,330 --> 00:03:04,250
你还得考虑小于零的情况啊

59
00:03:04,250 --> 00:03:05,289
我们先先不管

60
00:03:05,289 --> 00:03:08,050
先把我们主要的编辑是哪几个给它做出来

61
00:03:08,050 --> 00:03:09,069
ok如果这样子

62
00:03:09,069 --> 00:03:10,699
那我们要做的事情很简单

63
00:03:10,879 --> 00:03:13,680
array infit

64
00:03:14,280 --> 00:03:18,569
infit需要给他一个参数多大

65
00:03:18,569 --> 00:03:20,060
你需要它长多大

66
00:03:22,118 --> 00:03:23,848
我们有一个想法是说

67
00:03:23,848 --> 00:03:27,819
当然一种办法是说ok你现在的index是多少

68
00:03:28,139 --> 00:03:31,740
减去那个a的size

69
00:03:31,740 --> 00:03:32,780
再加一

70
00:03:34,399 --> 00:03:35,378
这是一种做法

71
00:03:35,378 --> 00:03:35,829
对不对

72
00:03:35,829 --> 00:03:37,929
这样子做我们可以保证说

73
00:03:37,929 --> 00:03:41,979
我让你刚刚好能够够到那个东西那个地方

74
00:03:42,699 --> 00:03:44,099
但是有的时候我们可能会觉得

75
00:03:44,099 --> 00:03:45,780
这样子做挺不经济的

76
00:03:45,780 --> 00:03:50,620
这就这就意味着说我们呢原来有这么大

77
00:03:51,718 --> 00:03:54,919
然后你现在说诶我还我要这个位置

78
00:03:54,919 --> 00:03:55,908
我要访问这个位置

79
00:03:55,908 --> 00:03:57,799
一个就多出一个

80
00:03:57,799 --> 00:03:59,598
可按照那个刚才那个公式呢哈

81
00:03:59,598 --> 00:04:03,580
那我们就心申请这么大一块

82
00:04:03,979 --> 00:04:07,460
然后下一次来的时候又正好加加了一嘛

83
00:04:07,460 --> 00:04:08,900
因为我cnt每次加一嘛

84
00:04:08,900 --> 00:04:10,580
他又说我就一个好

85
00:04:10,580 --> 00:04:12,759
那我再来那么大一个

86
00:04:12,899 --> 00:04:14,158
这多费劲啊

87
00:04:14,158 --> 00:04:15,239
每次就涨一个

88
00:04:15,239 --> 00:04:16,798
然后每次还拷贝

89
00:04:16,798 --> 00:04:18,379
然后下一次又拷贝

90
00:04:18,999 --> 00:04:19,978
太费劲了

91
00:04:19,978 --> 00:04:22,858
所以不如呢我们说你要一个吗

92
00:04:22,858 --> 00:04:27,319
好那我就给你长那么个五个

93
00:04:28,240 --> 00:04:30,839
于是下五个都满足了对吧

94
00:04:30,839 --> 00:04:32,040
然后又不够了哈

95
00:04:32,040 --> 00:04:34,110
我再给你涨五个

96
00:04:34,110 --> 00:04:38,939
所以我们会需要有一个brock这种概念

97
00:04:38,939 --> 00:04:41,180
我每次长一个brock

98
00:04:43,139 --> 00:04:44,298
这事儿听起来不错

99
00:04:44,298 --> 00:04:44,718
对不对

100
00:04:46,699 --> 00:04:49,000
所以呢我们可以考虑这么干

101
00:04:49,240 --> 00:04:52,329
当然我们前提得前都得定那个broken si哈

102
00:04:52,329 --> 00:04:55,319
如果我们说我们在这个点h里头说

103
00:04:56,300 --> 00:04:56,740
呃

104
00:04:56,740 --> 00:05:01,699
如果我们说这个process呢

105
00:05:01,699 --> 00:05:04,500
等于21次涨20个

106
00:05:04,718 --> 00:05:06,699
那这个公式什么意思呢

107
00:05:06,699 --> 00:05:08,889
那个index去除以broadsize

108
00:05:08,889 --> 00:05:12,000
算出来它位于哪一个brock里头

109
00:05:12,939 --> 00:05:16,459
然后加一是他的brock的

110
00:05:16,839 --> 00:05:20,720
从一开始说的那个序号乘以broadsize

111
00:05:22,040 --> 00:05:24,160
再减去那个a的size

112
00:05:24,259 --> 00:05:26,360
ok这事真挺复杂的

113
00:05:26,360 --> 00:05:28,629
我们来回到图上看怎么回事

114
00:05:28,629 --> 00:05:30,310
我们每次20个bg

115
00:05:30,310 --> 00:05:32,199
20个做一个block对吧

116
00:05:32,199 --> 00:05:34,740
所以一开始就有五个block在那

117
00:05:35,000 --> 00:05:39,218
然后接下来的20个都处于下一个broken

118
00:05:39,218 --> 00:05:40,418
我们如果brock编号的话

119
00:05:40,418 --> 00:05:42,759
这是01234

120
00:05:42,759 --> 00:05:43,829
这是五

121
00:05:43,829 --> 00:05:47,699
所以现在假如说我们要访问102

122
00:05:48,480 --> 00:05:54,250
那102÷20

123
00:05:54,250 --> 00:05:55,300
我们得到了

124
00:05:57,519 --> 00:05:58,240
五

125
00:05:59,740 --> 00:06:01,110
我们让它加一

126
00:06:01,110 --> 00:06:04,819
我们得到了六六去乘以20

127
00:06:04,819 --> 00:06:06,560
我们得到了120

128
00:06:06,560 --> 00:06:10,160
也就是这个地方是100对吧

129
00:06:10,160 --> 00:06:12,290
也就是这个位置是120

130
00:06:12,290 --> 00:06:14,720
我们要得到说我加一个bg的话

131
00:06:14,720 --> 00:06:17,769
那个block的底在哪啊

132
00:06:17,769 --> 00:06:18,819
底线在哪

133
00:06:18,819 --> 00:06:21,399
然后拿这个120去减去这个100

134
00:06:21,399 --> 00:06:23,860
于是得到了20个

135
00:06:23,879 --> 00:06:27,519
我们维持了刚才那个infit函数没变

136
00:06:27,519 --> 00:06:29,889
但是我们引入了brock的概念

137
00:06:29,889 --> 00:06:31,959
于是通过这么一个复杂的公式

138
00:06:31,959 --> 00:06:33,339
我们可以告诉你一个free

139
00:06:33,339 --> 00:06:36,040
说我们一次涨20个

140
00:06:36,300 --> 00:06:39,060
所以我们现在的rat具有这个功能

141
00:06:39,060 --> 00:06:40,500
它能够自动增长

142
00:06:40,500 --> 00:06:42,420
这个rat会说

143
00:06:42,459 --> 00:06:45,339
当你要去访问一个内存单元的时候

144
00:06:45,339 --> 00:06:47,500
当你要去访问某个下标的时候

145
00:06:47,500 --> 00:06:49,959
我会替你把这个数组长大

146
00:06:49,959 --> 00:06:51,759
所以我们在这个循环当中

147
00:06:51,759 --> 00:06:53,339
只要做这个事情就可以了

148
00:06:54,079 --> 00:06:56,319
ok当然这程序写到这儿是有点问题是吧

149
00:06:56,319 --> 00:06:59,528
我们什么时候退出好吧

150
00:06:59,528 --> 00:07:04,449
我们可以考虑说当number等于-1的时候退出

151
00:07:04,449 --> 00:07:06,728
所以我们恢复这两行吧

152
00:07:06,728 --> 00:07:08,040
我们想说

153
00:07:10,420 --> 00:07:15,529
如果number不等于-1

154
00:07:15,529 --> 00:07:18,199
那我们把这个数字记下来

155
00:07:18,199 --> 00:07:23,579
否则的话呢这个当number等于-1的话呢

156
00:07:23,579 --> 00:07:26,009
我们就要退出了啊

157
00:07:26,009 --> 00:07:27,779
于是我们就写出了这样一个代码

158
00:07:29,980 --> 00:07:36,189
ok这就是一个可以无限的读入这个整数

159
00:07:36,189 --> 00:07:38,680
然后它可以不断的自己增长了

160
00:07:38,680 --> 00:07:39,970
那么一段代码

161
00:07:39,970 --> 00:07:40,720
这里头呢

162
00:07:40,720 --> 00:07:44,319
我们就实现了我们的这个能够自动增长的

163
00:07:44,319 --> 00:07:46,449
那么一个数组那种结构

164
00:07:46,449 --> 00:07:48,899
这里头核心的代码当然就在这

165
00:07:49,500 --> 00:07:52,420
不过这个循环

166
00:07:54,199 --> 00:07:57,639
这个循环我们可以把它换成一个

167
00:07:57,639 --> 00:07:59,079
标准库里的函数

168
00:07:59,079 --> 00:08:00,968
叫做m e m c p y

169
00:08:00,968 --> 00:08:03,639
这件事我们不在视频里头展开哈

170
00:08:04,240 --> 00:08:06,649
大家回头自己去试一下

171
00:08:06,649 --> 00:08:09,769
我们在课件里头给出了那个具体的代码

172
00:08:09,769 --> 00:08:12,889
怎么用m e m c p y来做来代替这个循环

173
00:08:12,889 --> 00:08:14,269
来实现这种拷贝

174
00:08:14,269 --> 00:08:15,329
理论上说

175
00:08:15,329 --> 00:08:17,310
库函数的mm cp化的效率

176
00:08:17,310 --> 00:08:18,699
比你自己写循环要来的高

