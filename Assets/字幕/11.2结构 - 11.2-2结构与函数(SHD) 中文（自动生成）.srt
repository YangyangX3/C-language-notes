1
00:00:04,559 --> 00:00:06,389
当然一旦你声明的结构

2
00:00:06,389 --> 00:00:09,900
你就有了一种自己定义的数据类型

3
00:00:09,900 --> 00:00:11,580
好像int float一样

4
00:00:11,779 --> 00:00:15,199
那么当然ink float可以作为函数的参数

5
00:00:15,199 --> 00:00:16,879
你的这种结构类型呢

6
00:00:16,879 --> 00:00:18,820
也可以作为函数的参数

7
00:00:19,079 --> 00:00:22,500
比如说我们现在这个函数我们叫number of days

8
00:00:22,500 --> 00:00:25,379
它的参数就是一个struck date

9
00:00:26,199 --> 00:00:28,769
那么现在这个参数的形式明显

10
00:00:28,769 --> 00:00:31,980
这个参数呢就是一个结构变量

11
00:00:33,200 --> 00:00:36,520
所以整个结构是可以作为参数的值

12
00:00:36,520 --> 00:00:37,810
传入函数的

13
00:00:37,810 --> 00:00:39,280
但这种时候呢

14
00:00:39,280 --> 00:00:41,920
我们是在函数内新建的一个结构变量

15
00:00:41,920 --> 00:00:45,459
然后去复制那个调用者的结构的值

16
00:00:46,200 --> 00:00:49,880
在这个函数里头作为参数

17
00:00:49,880 --> 00:00:51,710
它是一个新的结构变量

18
00:00:51,710 --> 00:00:54,039
这和数组是完全不一样的

19
00:00:55,200 --> 00:00:56,899
当然可以作为参数

20
00:00:56,899 --> 00:00:57,979
你也可以作为返回类型

21
00:00:57,979 --> 00:01:00,179
你可以让一个函数返回一个结构

22
00:01:01,079 --> 00:01:03,079
所以这些都和数组是不一样的

23
00:01:03,079 --> 00:01:05,319
我们来看一个这样的程序的例子

24
00:01:05,780 --> 00:01:08,099
这程序呢有点长哈

25
00:01:08,099 --> 00:01:10,859
呃我们声明了一个结构叫做date

26
00:01:10,859 --> 00:01:12,180
里面有month day year

27
00:01:12,180 --> 00:01:14,219
这这这是我们今天看了好多遍了

28
00:01:14,219 --> 00:01:15,599
然后呢我们有俩函数

29
00:01:15,599 --> 00:01:16,900
一个叫做is leap

30
00:01:16,900 --> 00:01:17,319
呃

31
00:01:17,319 --> 00:01:18,939
从名字上面我们可以猜得出来

32
00:01:18,939 --> 00:01:22,659
这个函数是判断这一天所在的那1年

33
00:01:22,659 --> 00:01:24,280
是不是闰年啊

34
00:01:24,280 --> 00:01:25,629
所以如果是闰年的话

35
00:01:25,629 --> 00:01:26,530
它会返回一个true

36
00:01:26,530 --> 00:01:27,129
如果不是闰年

37
00:01:27,129 --> 00:01:28,448
他发一个boforce

38
00:01:28,448 --> 00:01:31,420
那么他要的是一个structure dd

39
00:01:31,560 --> 00:01:33,840
然后另外一个呢是number of days

40
00:01:33,840 --> 00:01:36,540
也是要一个stretch of radd

41
00:01:36,540 --> 00:01:38,459
那一下子我们可能看不出来这number of days

42
00:01:38,459 --> 00:01:38,939
什么意思啊

43
00:01:38,939 --> 00:01:40,179
我们往往下看

44
00:01:40,379 --> 00:01:44,250
然后我们在main里面呢啊

45
00:01:44,250 --> 00:01:46,739
我们做了这个结构的两个变量

46
00:01:46,739 --> 00:01:47,549
一个是today

47
00:01:47,549 --> 00:01:49,340
一个是tomorrow

48
00:01:49,620 --> 00:01:53,519
然后呢我们要求用户的输入今天的日期呃

49
00:01:53,519 --> 00:01:57,409
输入的方式呢是这个月日年啊

50
00:01:59,560 --> 00:02:02,620
于是呢我们就用scaf呢去读入了三个数字

51
00:02:02,620 --> 00:02:04,959
这三个数字分别付给了today

52
00:02:04,959 --> 00:02:05,700
the month

53
00:02:06,099 --> 00:02:10,280
today的day和today的一

54
00:02:10,538 --> 00:02:12,758
那从这个小细节

55
00:02:12,758 --> 00:02:14,139
其实我们可以知道说

56
00:02:14,139 --> 00:02:19,039
这两个运算符取地址和取成员

57
00:02:19,039 --> 00:02:20,719
谁的优先起来的高呢

58
00:02:20,719 --> 00:02:23,310
一定是取成员的优先起来的高

59
00:02:23,310 --> 00:02:25,530
所以我们才能把式子写成这样

60
00:02:25,530 --> 00:02:26,099
对不对

61
00:02:26,099 --> 00:02:28,110
如果取地址的优先级来的高的话

62
00:02:28,110 --> 00:02:31,400
那就变成我们先做today的那个地址取出来

63
00:02:31,599 --> 00:02:33,039
那就是个指针的指针

64
00:02:33,039 --> 00:02:34,900
再让他去点就没有任何意义了

65
00:02:34,900 --> 00:02:36,939
点的左边一定得是一个结构体才行

66
00:02:36,939 --> 00:02:40,460
所以它是先做了today的那个month

67
00:02:40,460 --> 00:02:43,560
叫做month的那个呃成员变量啊

68
00:02:43,560 --> 00:02:46,370
然后拿他的地址交给caf

69
00:02:46,370 --> 00:02:48,469
然后cf会把一个整数都进来以后

70
00:02:48,469 --> 00:02:49,939
填到这个monster里去

71
00:02:49,939 --> 00:02:54,498
所以这样我们就得到了一个today的三个值啊

72
00:02:54,498 --> 00:02:56,329
我们today就有了明确的值了

73
00:02:56,329 --> 00:02:59,278
然后呢接下来我们做的事情说

74
00:02:59,278 --> 00:03:02,459
如果today the day不是number of days today

75
00:03:03,538 --> 00:03:04,139
ok

76
00:03:06,819 --> 00:03:09,120
如果我们现在还不知道他到底什么意思哈

77
00:03:09,120 --> 00:03:10,699
我们一点点往下看

78
00:03:10,780 --> 00:03:13,689
于是呢我们做的事情就是说让da加一

79
00:03:13,689 --> 00:03:15,370
month和e2 都不变

80
00:03:15,370 --> 00:03:17,639
因为这是tomorrow嘛

81
00:03:18,019 --> 00:03:20,658
所以大概从这个地方我们可以大概猜说

82
00:03:20,658 --> 00:03:25,099
如果这一个这一天不是这个月的最后一天

83
00:03:26,319 --> 00:03:27,060
对不对

84
00:03:27,060 --> 00:03:28,800
如果这几天不是这个月的最后一天

85
00:03:28,800 --> 00:03:31,139
那么他的明天就很简单

86
00:03:31,139 --> 00:03:32,400
年和月都不变

87
00:03:32,400 --> 00:03:34,020
只要日加一就可以了

88
00:03:34,039 --> 00:03:35,000
否则的话

89
00:03:35,000 --> 00:03:36,979
如果today the month是12的话

90
00:03:36,979 --> 00:03:39,469
如果呃现在已经12月了

91
00:03:39,469 --> 00:03:41,180
那么而且呢

92
00:03:41,180 --> 00:03:44,938
这个day呢也是这个月的最后一天

93
00:03:44,938 --> 00:03:46,679
所以如果这个条件满足的话

94
00:03:46,679 --> 00:03:50,129
它相当于说如果这是这1年的最后一天

95
00:03:50,129 --> 00:03:53,370
那么它就变成第2年的是12+1

96
00:03:53,370 --> 00:03:54,919
第2年的1月1号

97
00:03:55,000 --> 00:03:56,500
再否则的话

98
00:03:56,500 --> 00:03:59,469
那就意味着它在某个月的最后一天

99
00:03:59,469 --> 00:04:01,659
但是那个月呢并不是12月

100
00:04:01,659 --> 00:04:04,669
那么day也要变成一下个月的1号

101
00:04:04,669 --> 00:04:05,028
对不对

102
00:04:05,028 --> 00:04:06,498
然后month要加一

103
00:04:06,498 --> 00:04:08,868
然后最后呢我们就输出说啊

104
00:04:08,868 --> 00:04:11,080
tomorrow the date是什么什么什么

105
00:04:11,459 --> 00:04:13,139
也就是说在这个命里面呢

106
00:04:13,139 --> 00:04:15,028
我们调用了一个函数number of days

107
00:04:15,028 --> 00:04:17,769
我们传给他today这个结构

108
00:04:17,769 --> 00:04:20,288
那么在这儿我们看到number of days呢

109
00:04:20,288 --> 00:04:21,428
是这样一个函数

110
00:04:21,428 --> 00:04:23,228
它得到了radate

111
00:04:23,228 --> 00:04:24,600
得到了那个结构

112
00:04:24,600 --> 00:04:28,670
在它里面呢有一个cost的数组12个

113
00:04:28,670 --> 00:04:29,870
你看看这个数字

114
00:04:29,870 --> 00:04:31,670
你就明白这个数字是什么对吧

115
00:04:31,670 --> 00:04:33,170
31 28什么就是什么

116
00:04:33,170 --> 00:04:35,029
就是一个月每个月有多少天对吧

117
00:04:35,029 --> 00:04:36,410
那就是第一个月有多少天

118
00:04:36,410 --> 00:04:37,620
第二个月有多少天

119
00:04:37,879 --> 00:04:43,029
那如果这个这个日子它的month是二

120
00:04:43,029 --> 00:04:44,920
因为2月份我们知道有闰年的问题

121
00:04:44,920 --> 00:04:45,490
对不对

122
00:04:45,490 --> 00:04:47,800
并且呢用is leaf这个函数

123
00:04:47,800 --> 00:04:48,639
我们去算出来

124
00:04:48,639 --> 00:04:51,449
说当天这个地所在的那一天

125
00:04:51,449 --> 00:04:53,339
所在的那个年啊

126
00:04:53,339 --> 00:04:54,689
是闰年的话

127
00:04:54,689 --> 00:04:57,240
那么days呢要变成29

128
00:04:57,240 --> 00:04:59,889
就是这个2月份就是29天了

129
00:04:59,889 --> 00:05:01,209
而不是28天了啊

130
00:05:01,209 --> 00:05:02,230
如果不满足这个条件

131
00:05:02,230 --> 00:05:05,620
那我们就直接拿这个数组里面的mars减一

132
00:05:05,620 --> 00:05:06,220
为什么要减一

133
00:05:06,220 --> 00:05:07,540
因为数组从零开始数嘛

134
00:05:07,540 --> 00:05:07,990
对不对

135
00:05:07,990 --> 00:05:09,579
所以一month等于一的时候

136
00:05:09,579 --> 00:05:12,410
对应的是this promise的那个零

137
00:05:12,410 --> 00:05:13,730
所以它要减一

138
00:05:13,730 --> 00:05:14,660
这样我们得到一个days

139
00:05:14,660 --> 00:05:17,899
最后呢我们就return那个days呃

140
00:05:18,199 --> 00:05:19,459
如果你足够细心

141
00:05:19,459 --> 00:05:21,079
你会看到这个函数也非常符合

142
00:05:21,079 --> 00:05:22,399
我们之前曾经提到过的

143
00:05:22,399 --> 00:05:24,589
一个函数的设计原则

144
00:05:24,589 --> 00:05:25,699
就是什么

145
00:05:25,978 --> 00:05:27,988
就是单一出口对吧

146
00:05:27,988 --> 00:05:29,519
我们并不是在这里来个return

147
00:05:29,519 --> 00:05:30,598
在这里来个return啊

148
00:05:30,598 --> 00:05:32,098
不是在这里一个return这个return

149
00:05:32,098 --> 00:05:33,910
而是算出一个days来

150
00:05:33,910 --> 00:05:35,470
最后统一的地方去做考虑

151
00:05:35,470 --> 00:05:40,879
称单一出口is lip做的事情呢也是一样

152
00:05:40,879 --> 00:05:43,158
他要一个rap作为输入啊

153
00:05:43,158 --> 00:05:46,430
然后呢拿他的一页4%看看

154
00:05:46,430 --> 00:05:47,389
100%

155
00:05:47,389 --> 00:05:48,949
看看400%看看对吧

156
00:05:48,949 --> 00:05:50,360
把这些条件都组合起来

157
00:05:50,360 --> 00:05:52,029
最后说这个leap是true

158
00:05:52,029 --> 00:05:53,110
如果不是这样的

159
00:05:53,110 --> 00:05:55,029
默认情况下离不是force啊

160
00:05:55,029 --> 00:05:55,569
然后呢

161
00:05:55,569 --> 00:05:59,819
最后的turn那个这样三个函数组合起来

162
00:05:59,819 --> 00:06:01,738
我们能够实现这样的功能

163
00:06:01,738 --> 00:06:03,028
在这个过程当中

164
00:06:03,028 --> 00:06:07,579
我们直接把today传给另外一个函数

165
00:06:07,819 --> 00:06:11,180
直接把这个d传给另外一个函数啊

166
00:06:11,180 --> 00:06:14,959
函这个结构变量是可以直接在函数中间

167
00:06:14,959 --> 00:06:16,120
传来传去传的

168
00:06:16,459 --> 00:06:19,279
那么相对于那些基础类型啊

169
00:06:19,279 --> 00:06:20,120
int float

170
00:06:20,120 --> 00:06:21,379
int float那些类型呢

171
00:06:21,379 --> 00:06:24,259
我们知道说scaf print pf都有直接的方式

172
00:06:24,259 --> 00:06:25,170
百分号d

173
00:06:25,170 --> 00:06:28,649
百分号f我们就可以做它的输入和输出

174
00:06:28,649 --> 00:06:30,990
那么你自己定义的结构啊

175
00:06:30,990 --> 00:06:32,790
你显然不可能指望说我有个百分号

176
00:06:32,790 --> 00:06:33,928
什么东西呃

177
00:06:33,928 --> 00:06:35,459
直接把那个结构的地址取出来

178
00:06:35,459 --> 00:06:37,379
交给scaf或者摆放什么东西

179
00:06:37,379 --> 00:06:39,059
直接把那个结构变量交给print def

180
00:06:39,059 --> 00:06:40,228
它就能够帮我们输出

181
00:06:40,228 --> 00:06:41,218
或者帮我们输入了

182
00:06:41,218 --> 00:06:43,920
这事他显然没有那么聪明啊

183
00:06:43,920 --> 00:06:46,930
他不可能知道你自己定义的内容呃

184
00:06:46,930 --> 00:06:49,569
你自己声明的那种类型里头有什么东西

185
00:06:49,569 --> 00:06:50,949
需要怎么样去做输入输出

186
00:06:50,949 --> 00:06:51,949
他不知道

187
00:06:51,949 --> 00:06:55,339
所以呢呃如果我们打算自己写一个函数

188
00:06:55,339 --> 00:06:57,439
这个函数能够读入一个结构

189
00:06:57,740 --> 00:06:59,740
如果我们把程序写成这个样子

190
00:07:00,620 --> 00:07:04,000
他能不能帮我们读这个结构呢

191
00:07:04,000 --> 00:07:05,199
你看我们要做的事情呢

192
00:07:05,199 --> 00:07:06,399
是这样说

193
00:07:06,399 --> 00:07:08,470
我们有个叫做gastra的函数

194
00:07:08,470 --> 00:07:09,959
我们给他一个rap

195
00:07:10,098 --> 00:07:11,238
然后在main里面呢

196
00:07:11,238 --> 00:07:15,110
我们做了一个straight point的一个这个这个呃

197
00:07:15,110 --> 00:07:16,040
变量y

198
00:07:16,040 --> 00:07:18,019
然后我们把这个y交给gta

199
00:07:19,370 --> 00:07:23,540
我们作为参数接收到了这个结构啊

200
00:07:23,540 --> 00:07:24,350
结构变量

201
00:07:24,350 --> 00:07:25,439
然后呢

202
00:07:26,939 --> 00:07:29,959
我其实刚才那句话说错了

203
00:07:30,000 --> 00:07:32,459
因为作为参数

204
00:07:32,459 --> 00:07:36,819
它接收到的不是那个y那个结构变量

205
00:07:37,000 --> 00:07:37,779
对不对

206
00:07:38,800 --> 00:07:42,579
他接收到的是y那个结构变量的值

207
00:07:42,658 --> 00:07:46,738
所以现在p是一个和y具有相同值的

208
00:07:46,738 --> 00:07:48,439
另外一个结构变量

209
00:07:49,339 --> 00:07:51,160
因此在get这里头

210
00:07:51,160 --> 00:07:54,100
我们对p的y x和y做了赋值

211
00:07:54,100 --> 00:07:55,600
我们当然通过这个print f

212
00:07:55,600 --> 00:07:57,879
可以看到正确的p的x和y

213
00:07:57,879 --> 00:08:00,040
但是做完这件事情

214
00:08:00,040 --> 00:08:02,600
当the guja函数返回的时候

215
00:08:03,339 --> 00:08:05,670
我们没有去动那个y

216
00:08:05,670 --> 00:08:08,430
我们没有去动main函数里面的y

217
00:08:08,430 --> 00:08:10,259
所以y还是零零

218
00:08:10,478 --> 00:08:12,879
output会得到一个star point

219
00:08:12,879 --> 00:08:14,978
然后去把里面的x和y给我们输出

220
00:08:14,978 --> 00:08:16,658
显然我们应该得到的是零零

221
00:08:16,658 --> 00:08:17,959
我们来看一下这件事情

222
00:08:17,978 --> 00:08:21,399
这就是我们在刚才呃看到的那个页呃

223
00:08:21,399 --> 00:08:22,579
那个程序啊

224
00:08:22,899 --> 00:08:25,720
我们现在把这个程序呢呃编译运行一下

225
00:08:25,720 --> 00:08:27,430
我们看看结果是怎么样子的

226
00:08:27,430 --> 00:08:30,709
我们需要给它一个xy

227
00:08:30,709 --> 00:08:33,839
我们给他的是12和23

228
00:08:35,360 --> 00:08:36,940
我们看到第一次

229
00:08:36,940 --> 00:08:40,389
他在那个函数里头输出了12和23

230
00:08:40,389 --> 00:08:41,980
可是回到main里头以后呢

231
00:08:41,980 --> 00:08:43,918
他输出的只有零和零了

232
00:08:44,519 --> 00:08:46,700
然后我们这个程序写的不太好看哈

233
00:08:46,700 --> 00:08:48,479
这输出都不带回车的

234
00:08:49,399 --> 00:08:51,100
也就是说回到那以后

235
00:08:51,100 --> 00:08:52,879
那个那个娃也没有改

236
00:08:53,179 --> 00:08:56,450
我们在gets str里头得到的这个p

237
00:08:56,450 --> 00:08:59,099
它里头只有y的值

238
00:08:59,099 --> 00:09:02,309
它并不是和我有任何联系的东西

239
00:09:02,309 --> 00:09:04,320
这和数组完全不一样

240
00:09:04,320 --> 00:09:05,610
所以我们在gj里头

241
00:09:05,610 --> 00:09:08,559
对这个p的x和y做任何的赋值

242
00:09:08,559 --> 00:09:10,539
和这个y没有任何关系

243
00:09:12,259 --> 00:09:13,539
应该怎么做

244
00:09:13,539 --> 00:09:16,779
所以我们在gr里头读到的那个结构

245
00:09:16,779 --> 00:09:19,500
那些x和y的值怎么能够传回来呢

246
00:09:20,259 --> 00:09:22,860
你要记住c语言在函数调用的时候

247
00:09:22,860 --> 00:09:24,090
它是传值的

248
00:09:24,090 --> 00:09:25,830
它永远是传值的

249
00:09:25,830 --> 00:09:28,000
所以我们没有别的办法说

250
00:09:28,080 --> 00:09:29,460
如果不传指针的话

251
00:09:31,440 --> 00:09:32,639
所以在函数当中

252
00:09:32,639 --> 00:09:34,860
p和y和main当中的y

253
00:09:34,860 --> 00:09:36,299
他们是没有任何关系的

254
00:09:36,639 --> 00:09:38,259
在函数多了p的值之后

255
00:09:38,259 --> 00:09:39,340
没有任何东西回到mean去

256
00:09:39,340 --> 00:09:40,240
所以y还是零

257
00:09:40,240 --> 00:09:42,539
因此一个解决方案是这样

258
00:09:42,759 --> 00:09:44,320
我们之前的方案呢

259
00:09:44,320 --> 00:09:46,059
是把一个结构传到函数里头

260
00:09:46,059 --> 00:09:47,750
然后在函数当中做到操作

261
00:09:47,750 --> 00:09:49,850
但其实我们不是把结构传到函数里头

262
00:09:49,850 --> 00:09:52,070
我们把一个结构的值传到函数里头

263
00:09:52,070 --> 00:09:53,750
然后在函数当中搓澡做操作

264
00:09:53,750 --> 00:09:55,220
然后没有返回回去

265
00:09:55,220 --> 00:09:56,600
所以问题就在于

266
00:09:56,600 --> 00:09:57,799
传入函数的呢

267
00:09:57,799 --> 00:10:00,080
是外面那个结构变量的一个克隆体

268
00:10:00,080 --> 00:10:01,240
不是指针

269
00:10:01,659 --> 00:10:04,600
不是指下了外面的一个结构

270
00:10:04,600 --> 00:10:06,339
而是传进去一个克隆体

271
00:10:06,580 --> 00:10:09,940
所以船结构和传输组进函数是不一样的

272
00:10:09,940 --> 00:10:11,559
那么一种方案就是

273
00:10:11,559 --> 00:10:13,450
我们可以在这个输入函数当中

274
00:10:13,450 --> 00:10:15,879
创建一个临时的结构变量

275
00:10:15,879 --> 00:10:18,198
然后把这个结构返回给调用者

276
00:10:18,240 --> 00:10:20,340
我们不需要去接收一个什么东西

277
00:10:20,340 --> 00:10:23,960
我们就在这个函数里头有一个point的结构

278
00:10:23,960 --> 00:10:26,539
用它去做cf得到x和y

279
00:10:26,539 --> 00:10:28,519
然后把这个结构返回就可以了

280
00:10:28,940 --> 00:10:31,198
也就是说我们可以把它做成这个样子

281
00:10:31,320 --> 00:10:33,929
我们让这个gesture函数呢

282
00:10:33,929 --> 00:10:35,940
它不需要参数是void的

283
00:10:35,940 --> 00:10:38,599
而它的返回呢是一个rap point

284
00:10:38,899 --> 00:10:40,879
它返回一个结构变量

285
00:10:41,159 --> 00:10:43,559
然后我们在这个gr里头呢

286
00:10:43,559 --> 00:10:45,659
自己做一个rap point p

287
00:10:45,659 --> 00:10:47,399
那么显然这是一个本地变量

288
00:10:47,399 --> 00:10:47,820
对不对

289
00:10:47,820 --> 00:10:51,929
这个变量本身在离开这个函数的时候

290
00:10:51,929 --> 00:10:53,190
会消失掉

291
00:10:53,190 --> 00:10:55,200
这没有任何问题呃

292
00:10:55,200 --> 00:10:56,789
c语言有足够好的机制

293
00:10:56,789 --> 00:10:58,169
来帮我们做剩下的事情

294
00:10:58,169 --> 00:10:59,700
我们在这个gr里头

295
00:10:59,700 --> 00:11:02,340
对这个p的x和y做了赋值

296
00:11:02,340 --> 00:11:06,299
完了以后我们return这个p在调用get right的地方

297
00:11:06,299 --> 00:11:08,460
我们说y等于那个东西

298
00:11:08,460 --> 00:11:09,929
我们在前面已经看到过

299
00:11:09,929 --> 00:11:12,500
两个结构变量是可以复制的

300
00:11:12,639 --> 00:11:14,080
所以我们就利用这个

301
00:11:14,080 --> 00:11:16,629
我们让gets job返回一个结构变量

302
00:11:16,629 --> 00:11:17,919
把这个变结构变量呢

303
00:11:17,919 --> 00:11:20,860
通过腐殖付给了另外一个结构变量

304
00:11:20,860 --> 00:11:21,340
ok

305
00:11:21,340 --> 00:11:23,679
这样子y就能够得到

306
00:11:23,679 --> 00:11:26,730
我们在gar里头传进去的值

307
00:11:26,730 --> 00:11:27,840
我们来试试看

308
00:11:28,919 --> 00:11:30,479
还是1223

309
00:11:30,899 --> 00:11:34,769
现在我们在命里面也得到了1223

310
00:11:34,769 --> 00:11:36,000
这两个值

311
00:11:36,000 --> 00:11:40,080
在传一个结构给函数的这种方式当中呢

312
00:11:40,080 --> 00:11:41,159
我们不传结构

313
00:11:41,159 --> 00:11:42,539
而是传结构的指针

314
00:11:42,539 --> 00:11:46,139
是一个更加被推荐的方式啊

315
00:11:46,139 --> 00:11:49,679
在c语言的经典教材k安娜那本的c里面

316
00:11:49,679 --> 00:11:51,219
在他的131页

317
00:11:51,500 --> 00:11:53,899
所以你知道在我们这一行也有一些呃

318
00:11:53,899 --> 00:11:56,269
会让人记住页数的经典的东西啊

319
00:11:56,269 --> 00:11:57,769
在那一行那一页里头

320
00:11:57,769 --> 00:12:00,470
他说呢如果你有一个大的结构变量

321
00:12:00,470 --> 00:12:01,909
你要传进函数的话呢

322
00:12:01,909 --> 00:12:05,649
那通常更为有效的方式呢是传指针

323
00:12:05,649 --> 00:12:07,990
而不是拷贝整个结构

324
00:12:07,990 --> 00:12:11,299
因为c语言的这种结构的传递方式

325
00:12:11,299 --> 00:12:12,830
是直的传递

326
00:12:12,830 --> 00:12:15,919
也就是说你在那个被调的函数里头呢

327
00:12:15,919 --> 00:12:16,970
要一模一样的

328
00:12:16,970 --> 00:12:19,929
去建立一个和调用函数那边一模一样的

329
00:12:19,929 --> 00:12:21,070
那么一个结构变量

330
00:12:21,070 --> 00:12:24,399
然后把每一个字节的值都拷贝过去

331
00:12:24,399 --> 00:12:27,370
这是一个非常计费空间

332
00:12:27,370 --> 00:12:30,610
因为你要有一个新的结构变量在那了

333
00:12:30,610 --> 00:12:31,539
又费时间

334
00:12:31,539 --> 00:12:32,889
因为你要做大量的拷贝

335
00:12:32,889 --> 00:12:33,820
都没一件事情

336
00:12:33,820 --> 00:12:35,320
既费空间又费时间的事情

337
00:12:35,320 --> 00:12:38,779
所以呢早在k安娜的那本书里头

338
00:12:38,779 --> 00:12:42,139
就已经提出来说你更好的方式是穿指针

339
00:12:44,860 --> 00:12:47,519
我们先得要解决的一个问题是

340
00:12:47,519 --> 00:12:50,159
我们前面其实已经看到

341
00:12:50,419 --> 00:12:53,659
结构变量本身不是地址

342
00:12:53,659 --> 00:12:56,179
所以你要用and的符号去取得它的地址

343
00:12:56,360 --> 00:12:59,299
我们也看到怎么去做出它的一个指针

344
00:12:59,299 --> 00:13:01,779
来指向某个结构的一种指针

345
00:13:02,039 --> 00:13:04,049
可是接下来的问题是

346
00:13:04,049 --> 00:13:05,460
当你像我们现在这儿

347
00:13:05,460 --> 00:13:06,360
我们有stra date

348
00:13:10,509 --> 00:13:12,600
我们在讲结构呃

349
00:13:12,600 --> 00:13:13,379
类型声明的时候

350
00:13:13,379 --> 00:13:14,580
我们提到过他有三种形式

351
00:13:14,580 --> 00:13:14,940
对不对

352
00:13:14,940 --> 00:13:16,769
最右边的第三种形式就是这样子的

353
00:13:16,769 --> 00:13:18,000
我们又有它的类型的名字

354
00:13:18,000 --> 00:13:19,339
我们又有变量的名字

355
00:13:19,339 --> 00:13:20,658
同时做了声明

356
00:13:20,658 --> 00:13:21,649
同时做了定义

357
00:13:21,649 --> 00:13:24,499
那这个my day我们可以取出它的地址

358
00:13:24,499 --> 00:13:27,259
然后交给一个指向加data的一个指针

359
00:13:28,220 --> 00:13:30,519
那我们怎么去访问它里面的成员

360
00:13:30,519 --> 00:13:32,740
因为my day里头会有month

361
00:13:32,740 --> 00:13:34,360
所以my day.month当然没有问题

362
00:13:34,360 --> 00:13:35,870
可是通过p怎么访问

363
00:13:35,870 --> 00:13:37,370
因为新p就是my day

364
00:13:37,370 --> 00:13:37,940
对不对

365
00:13:37,940 --> 00:13:38,990
大家啊

366
00:13:38,990 --> 00:13:39,769
在指针那块

367
00:13:39,769 --> 00:13:41,899
应该已经把这件事搞得很清楚了哈

368
00:13:41,899 --> 00:13:45,320
新p就是它所指的那个那个那个变量嘛

369
00:13:45,320 --> 00:13:47,720
所以如果你说我有新p

370
00:13:47,720 --> 00:13:49,340
然后加上括号来点帽子

371
00:13:49,340 --> 00:13:50,000
没问题

372
00:13:50,000 --> 00:13:50,960
可以这么写

373
00:13:50,960 --> 00:13:52,960
可是这么写的话

374
00:13:52,960 --> 00:13:54,039
你要敲的键太多

375
00:13:54,039 --> 00:13:54,610
对不对

376
00:13:54,610 --> 00:13:55,600
那个符号太多

377
00:13:55,600 --> 00:13:56,259
又是括号

378
00:13:56,259 --> 00:13:56,980
又是点的

379
00:13:56,980 --> 00:13:57,879
还有新号

380
00:13:57,879 --> 00:14:01,820
所以呢人们就用了一个更简单的方式来表

381
00:14:01,820 --> 00:14:02,000
达

382
00:14:02,000 --> 00:14:05,960
说这个指针所指的那个结构变量

383
00:14:05,960 --> 00:14:08,080
里面的那个成员

384
00:14:08,080 --> 00:14:10,029
你看我说话都要说那么费劲

385
00:14:10,029 --> 00:14:12,490
结果呢在c语言我们只要敲两个键

386
00:14:12,490 --> 00:14:14,110
我们敲一个减号

387
00:14:14,110 --> 00:14:15,679
敲一个大于号

388
00:14:15,679 --> 00:14:17,059
它非常形象的

389
00:14:17,059 --> 00:14:19,019
正好是一个箭头

390
00:14:19,399 --> 00:14:21,169
正好是个箭头啊

391
00:14:21,169 --> 00:14:23,570
在英文里面我们就把这个符号读作arrow

392
00:14:23,570 --> 00:14:24,740
就是箭头啊

393
00:14:24,740 --> 00:14:25,519
当然在中文

394
00:14:25,519 --> 00:14:30,259
我们通常呃会把它念成说p所指的v

395
00:14:31,299 --> 00:14:34,860
其实你知道p所指的month就是有所省略的

396
00:14:34,860 --> 00:14:38,320
是p所指的那个结构的month是吧

397
00:14:38,320 --> 00:14:40,090
但是呢呃我们中文一般就这么说

398
00:14:40,090 --> 00:14:40,870
p所指的month

399
00:14:40,870 --> 00:14:42,309
英文里头也说呃

400
00:14:42,309 --> 00:14:43,539
pa romance啊

401
00:14:43,539 --> 00:14:44,919
就是p所指的那个

402
00:14:45,220 --> 00:14:46,120
这样子的话呢

403
00:14:46,120 --> 00:14:48,340
我们就可以用一个比较简单的运算符

404
00:14:48,340 --> 00:14:50,259
其实这个减号加大于号

405
00:14:50,259 --> 00:14:52,659
这是一个新的运算符啊

406
00:14:52,659 --> 00:14:53,740
这是一个运算符

407
00:14:53,740 --> 00:14:56,460
和点的运算符的定位差不多

408
00:14:56,460 --> 00:14:58,919
只不过现在在这个运算符error的左边呢

409
00:14:58,919 --> 00:15:01,129
一定是一个指针指向结构的一个指针

410
00:15:01,129 --> 00:15:02,750
然后这个指针所指的那个成员

411
00:15:02,750 --> 00:15:04,519
我们就以这种方式来表达了

412
00:15:05,840 --> 00:15:07,240
所以有了这个之后

413
00:15:07,240 --> 00:15:09,610
我们就可以把前面的那个get jar

414
00:15:09,610 --> 00:15:11,080
改造成另外的样子了

415
00:15:11,080 --> 00:15:12,799
我们看看改造成什么样呢

416
00:15:13,259 --> 00:15:15,179
我们改造说啊

417
00:15:15,179 --> 00:15:17,580
我们有个get struck函数啊

418
00:15:17,580 --> 00:15:20,690
这get stru函数呢要的是一个指针

419
00:15:20,690 --> 00:15:22,009
rap point的一个指针

420
00:15:22,009 --> 00:15:24,870
所以我们调用它的时候给了他这个指针

421
00:15:24,870 --> 00:15:28,110
这个时候呢我们还是让他做了返回啊

422
00:15:28,110 --> 00:15:29,370
我们还是让他做了返回

423
00:15:29,370 --> 00:15:31,559
我们在这个函数内部呢

424
00:15:31,559 --> 00:15:34,299
去取得了p所指的那个x

425
00:15:34,299 --> 00:15:36,879
取得了p所指的那个y啊

426
00:15:36,879 --> 00:15:40,039
然后我们做了skin f把那些值给付进去

427
00:15:40,120 --> 00:15:40,960
最后呢

428
00:15:40,960 --> 00:15:43,360
我们又把我们得到的那个参数

429
00:15:43,360 --> 00:15:45,099
p给返回出去了

430
00:15:46,299 --> 00:15:49,559
呃这是其实是一个非常常用的一个套路

431
00:15:49,559 --> 00:15:51,940
就是我传进来一个指针

432
00:15:51,940 --> 00:15:54,580
我在里头对这个指针所指的那些东西

433
00:15:54,580 --> 00:15:55,840
做一定的处理之后呢

434
00:15:55,840 --> 00:15:57,850
我又把这个指针给返回出去了

435
00:15:57,850 --> 00:15:59,409
这样做的好处呢

436
00:15:59,409 --> 00:16:03,019
就是我将来可以把它串在

437
00:16:03,019 --> 00:16:04,190
其他函数的调用当中

438
00:16:04,190 --> 00:16:06,470
你看下面我们紧接着就出现了

439
00:16:06,470 --> 00:16:10,940
我们做了一个另外做了一个print函数

440
00:16:10,940 --> 00:16:13,220
这print函数呢也要一个指针

441
00:16:13,220 --> 00:16:14,659
也是要一个rap的指针

442
00:16:14,659 --> 00:16:15,620
你看我们前面讲过

443
00:16:15,620 --> 00:16:16,909
k安娜都提了马力

444
00:16:16,909 --> 00:16:19,100
传一个结构不如传它的指针

445
00:16:19,100 --> 00:16:19,629
对不对

446
00:16:19,629 --> 00:16:22,330
但是呢我们很好心的在前面加了const

447
00:16:22,330 --> 00:16:22,570
为什么

448
00:16:22,570 --> 00:16:24,559
因为我们我们叫print嘛

449
00:16:25,879 --> 00:16:28,679
我们是要去修改这个p所指的

450
00:16:28,679 --> 00:16:29,700
结构的内容了

451
00:16:29,700 --> 00:16:30,899
所以它不能是cost

452
00:16:30,899 --> 00:16:31,860
可以在print的时候

453
00:16:31,860 --> 00:16:33,899
我们只需要拿它的值读一下

454
00:16:33,899 --> 00:16:35,399
然后把它这个值给输出了

455
00:16:35,399 --> 00:16:37,039
所以我们可以大胆的加上const

456
00:16:37,039 --> 00:16:38,659
表明说哎你你放心

457
00:16:38,659 --> 00:16:39,379
我的print啊

458
00:16:39,379 --> 00:16:41,059
我不会对你做任何的修改的

459
00:16:41,059 --> 00:16:43,100
现在呢这个print要的是一个指针

460
00:16:43,100 --> 00:16:45,080
所以呢你看我们就可以直接这么用

461
00:16:45,080 --> 00:16:48,938
说我get judge得到的那个指针

462
00:16:48,938 --> 00:16:50,960
我就拿来传给print

463
00:16:50,960 --> 00:16:51,679
print呢

464
00:16:51,679 --> 00:16:55,070
就会把那个指针所指的那个结构的内容呢

465
00:16:55,070 --> 00:16:56,500
帮我给打印出来

466
00:16:57,000 --> 00:16:59,220
这样的我的程序就可以写得很简洁

467
00:16:59,220 --> 00:16:59,700
对不对

468
00:16:59,700 --> 00:17:04,059
我get to直接作为print的一个参数了

469
00:17:05,039 --> 00:17:09,579
那我们之前不是有另外一个叫做output

470
00:17:09,579 --> 00:17:10,240
的函数吗

471
00:17:10,240 --> 00:17:12,279
那个函数要的是一个结构本身

472
00:17:12,279 --> 00:17:13,519
而不是指针

473
00:17:13,559 --> 00:17:15,599
这个时候你怎么怎么利用它呢

474
00:17:15,599 --> 00:17:17,069
你看我们做了一件

475
00:17:17,069 --> 00:17:20,089
看上去很不可思议的事情

476
00:17:20,089 --> 00:17:22,339
我们知道心是一个运算符

477
00:17:22,339 --> 00:17:24,890
用来取出它右边的那个指针

478
00:17:24,890 --> 00:17:26,660
所指的那个变量

479
00:17:26,660 --> 00:17:27,349
对不对

480
00:17:27,349 --> 00:17:29,279
现在它右边的指针是什么呢

481
00:17:29,279 --> 00:17:31,599
是这个函数的返回值

482
00:17:32,539 --> 00:17:34,299
我们有一个函数

483
00:17:34,299 --> 00:17:36,230
它的返回是一个指针

484
00:17:36,230 --> 00:17:37,160
于是呢

485
00:17:37,160 --> 00:17:38,509
我们就用星号

486
00:17:38,509 --> 00:17:42,500
取出这个函数所返回的那个东西

487
00:17:42,920 --> 00:17:46,759
然后作为一个变量来使用它

488
00:17:47,519 --> 00:17:49,759
这件事情居然是可以做的

489
00:17:49,759 --> 00:17:52,220
实际上我们还可以做更邪恶的事情哦

490
00:17:52,220 --> 00:17:57,170
说get这个and why等于哦

491
00:17:57,170 --> 00:17:59,960
你看我们说过结构可以做这样的复制

492
00:17:59,960 --> 00:18:00,259
对不对

493
00:18:00,259 --> 00:18:02,480
这个point我们给它一个结构的值

494
00:18:02,480 --> 00:18:04,819
比如说一二行吗

495
00:18:05,839 --> 00:18:07,519
没问题哇

496
00:18:07,519 --> 00:18:09,200
这看上去更加不可思议了

497
00:18:09,200 --> 00:18:09,740
对不对

498
00:18:09,740 --> 00:18:12,230
在这个辅字号的左边出现的是什么

499
00:18:12,230 --> 00:18:16,059
是一个新一个函数的返回结果

500
00:18:16,059 --> 00:18:17,140
但是没有问题啊

501
00:18:17,140 --> 00:18:18,339
这是左值啊

502
00:18:18,740 --> 00:18:21,440
所以我们为什么要说在复12号的左边

503
00:18:21,440 --> 00:18:22,039
不是变量

504
00:18:22,039 --> 00:18:23,420
你看这绝对不是变量了

505
00:18:23,420 --> 00:18:23,779
对不对

