1
00:00:04,519 --> 00:00:05,719
那讲了这么多

2
00:00:05,719 --> 00:00:06,349
啰里啰嗦

3
00:00:06,349 --> 00:00:07,309
又取地址

4
00:00:07,309 --> 00:00:10,679
又根据地址去取到那个变量干嘛呢

5
00:00:10,679 --> 00:00:12,619
我们我们干嘛做那么复杂的事情呢

6
00:00:13,660 --> 00:00:16,170
我们来看指针可以用在什么场景下面

7
00:00:16,170 --> 00:00:17,940
第一个场景就是大家记不记得

8
00:00:17,940 --> 00:00:19,980
我们之前讲过说在讲函数的时候

9
00:00:19,980 --> 00:00:20,789
我们讲过说

10
00:00:20,789 --> 00:00:22,719
如果你想交换两个变量

11
00:00:23,179 --> 00:00:24,620
你做一个sp

12
00:00:24,620 --> 00:00:28,158
你穿ab两个直径去在swap函数里头

13
00:00:28,158 --> 00:00:29,178
你可以把它们交换过来

14
00:00:29,178 --> 00:00:29,809
没问题

15
00:00:29,809 --> 00:00:31,759
可是离开swap就没有用了

16
00:00:31,759 --> 00:00:32,359
为什么

17
00:00:32,359 --> 00:00:34,378
因为你传进去的是两个值

18
00:00:34,560 --> 00:00:36,719
现在学过指针之后

19
00:00:36,719 --> 00:00:38,789
我们就可以用它来交换变量了

20
00:00:38,789 --> 00:00:41,729
我们传两个地址进去就可以做事情

21
00:00:41,729 --> 00:00:42,689
我们来试试看

22
00:00:42,689 --> 00:00:44,789
现在呢我们写了这样一个sp函数出来

23
00:00:44,789 --> 00:00:46,020
在这个sp里面呢

24
00:00:46,020 --> 00:00:48,210
我们要的参数是两个指针

25
00:00:48,210 --> 00:00:49,079
然后呢

26
00:00:49,079 --> 00:00:52,259
我们在里面所有的运算都是用新号来做的

27
00:00:52,259 --> 00:00:54,869
新pa取出p a所代表的那个变量

28
00:00:54,869 --> 00:00:56,490
让它把它付给t

29
00:00:56,490 --> 00:00:58,920
让新p所代表的那个变量

30
00:00:58,920 --> 00:01:01,079
等于pb所代表的那个变量

31
00:01:01,079 --> 00:01:02,850
让pb所代表的那个变量呢

32
00:01:02,850 --> 00:01:05,189
又等于t完成了一次交换

33
00:01:05,189 --> 00:01:06,659
要用这个sb的时候

34
00:01:06,659 --> 00:01:07,819
我们只要这样写

35
00:01:08,579 --> 00:01:10,280
我们把a的地址给他

36
00:01:10,280 --> 00:01:11,859
把b的地址给他

37
00:01:13,040 --> 00:01:16,060
然后出来以后我们来看看a等于多少

38
00:01:16,060 --> 00:01:17,359
b等于多少

39
00:01:17,719 --> 00:01:18,739
在sb之前

40
00:01:18,739 --> 00:01:19,400
当然a等于五

41
00:01:19,400 --> 00:01:20,000
b等于六

42
00:01:20,000 --> 00:01:23,079
sp之后换过来了

43
00:01:24,140 --> 00:01:25,480
所以像swap这样的函数

44
00:01:25,480 --> 00:01:27,129
我们就就只能用指针来做

45
00:01:27,129 --> 00:01:27,760
对不对

46
00:01:27,760 --> 00:01:29,500
只能用指针去帮我们完成

47
00:01:29,500 --> 00:01:31,359
这样的两个变量的交换的事情

48
00:01:31,459 --> 00:01:33,560
这种两个变量交换做swap

49
00:01:33,560 --> 00:01:35,340
这是一种什么样的场景呢

50
00:01:35,579 --> 00:01:40,439
这种场景是说函数其实它要返回多个值

51
00:01:41,060 --> 00:01:42,819
这个函数返回的值不止一个

52
00:01:42,819 --> 00:01:44,620
你看光返回一个a不够

53
00:01:44,620 --> 00:01:45,939
你还得返回一个b

54
00:01:46,319 --> 00:01:49,759
所以某些值就必须通过指针带回

55
00:01:50,280 --> 00:01:52,920
也就是说我们传进去的参数呢

56
00:01:52,920 --> 00:01:55,859
实际上是需要保存带回的结果的变量

57
00:01:56,239 --> 00:01:57,829
我们再来看个例子

58
00:01:57,829 --> 00:01:59,420
好在这个代码里面呢

59
00:01:59,420 --> 00:02:00,799
我们定义一个函数啊

60
00:02:00,799 --> 00:02:03,510
明max我们看到这个函数呢有很多参数啊

61
00:02:03,510 --> 00:02:04,650
第一个参数是一个数组

62
00:02:04,650 --> 00:02:06,150
因为我们要在这个数组当中

63
00:02:06,150 --> 00:02:10,419
找出最大和最小land是表达这个数字有多大

64
00:02:10,479 --> 00:02:12,579
新max和新命

65
00:02:12,579 --> 00:02:15,699
也就是说我们这个明max要算出两个结果

66
00:02:15,699 --> 00:02:16,058
对不对

67
00:02:16,058 --> 00:02:16,718
一个是最大的

68
00:02:16,718 --> 00:02:17,588
一个是最小的

69
00:02:17,588 --> 00:02:19,870
那么显然呢在这个计算过程当中

70
00:02:19,870 --> 00:02:21,189
他要有两个结果

71
00:02:21,189 --> 00:02:22,210
这个结两个结果

72
00:02:22,210 --> 00:02:24,669
不可能通过函数的返回值来返回

73
00:02:24,669 --> 00:02:26,270
返回值只能返回一个

74
00:02:26,270 --> 00:02:30,349
所以呢我们用两个指针来做这个事情

75
00:02:30,349 --> 00:02:32,389
在这个函数里面做的事当然非常简单

76
00:02:32,389 --> 00:02:34,159
我们先让新max等于新

77
00:02:34,159 --> 00:02:36,650
新命等于新max等于a的第一个元素

78
00:02:36,650 --> 00:02:37,379
然后呢

79
00:02:37,379 --> 00:02:40,379
从后面第二个元素开始遍历整个数组

80
00:02:40,379 --> 00:02:41,400
那如果发现小了

81
00:02:41,400 --> 00:02:43,860
那么就等着这个这个这个代码非常简单

82
00:02:43,860 --> 00:02:44,759
大家做到现在

83
00:02:44,759 --> 00:02:46,750
应该已经非常熟悉这一类的做法了

84
00:02:46,750 --> 00:02:49,689
然后我们在命里头我们就调用这个mmax

85
00:02:49,689 --> 00:02:50,610
我们给了他a

86
00:02:50,610 --> 00:02:52,949
我们通过size of a除以size of a0 

87
00:02:52,949 --> 00:02:56,819
得到了它的元素的个数传给了这个l

88
00:02:56,819 --> 00:02:58,919
然后我们把在这里

89
00:02:58,919 --> 00:03:01,680
命里面的变量命和max取了地址

90
00:03:01,680 --> 00:03:03,719
交给了这个mmax函数

91
00:03:03,719 --> 00:03:05,219
最后我们得到了那个结果

92
00:03:05,219 --> 00:03:06,689
我们看一下运行的结果呢

93
00:03:06,689 --> 00:03:08,159
果然名是一

94
00:03:08,159 --> 00:03:10,240
而max是55

95
00:03:11,960 --> 00:03:15,558
所以这就是指针应用的一种

96
00:03:15,558 --> 00:03:16,968
非常常见的场景

97
00:03:16,968 --> 00:03:19,639
我的函数的结果不止一个

98
00:03:19,639 --> 00:03:21,479
那么我通过指针

99
00:03:21,599 --> 00:03:26,449
把我要接收的结果的变量的地址传进去

100
00:03:26,449 --> 00:03:30,699
让函数在里面呢帮我把这些变量给它填好

101
00:03:30,699 --> 00:03:32,050
把值传回来

102
00:03:32,050 --> 00:03:34,539
所以虽然这两个是参数

103
00:03:34,539 --> 00:03:36,819
是从主函数传进去的

104
00:03:36,819 --> 00:03:38,229
是从命传进去的参数

105
00:03:38,229 --> 00:03:39,789
但是它们的作用

106
00:03:39,789 --> 00:03:42,759
它们的作用是把结果带出来

107
00:03:43,860 --> 00:03:46,849
好参数的作用是得到结果

108
00:03:46,849 --> 00:03:49,139
那还有一种应用场景呢是这样

109
00:03:49,439 --> 00:03:52,979
我们的函数呢要返回运算的状态

110
00:03:52,979 --> 00:03:56,370
而结果呢需要通过指针返回

111
00:03:56,370 --> 00:04:02,310
也就是说我们函数在运算的过程当中

112
00:04:02,310 --> 00:04:04,379
可能遇到一些特殊的状态

113
00:04:04,379 --> 00:04:07,769
这个算计算呢没有正确的得到结果

114
00:04:07,769 --> 00:04:09,899
那么常用的套路是什么呢

115
00:04:09,899 --> 00:04:12,808
我们可以考虑让函数返回特殊的

116
00:04:12,808 --> 00:04:15,479
不属于有效范围内的值来表示出错

117
00:04:15,479 --> 00:04:17,339
在c语言的标准库里面呢

118
00:04:17,339 --> 00:04:21,089
我们可以在想和文件箱操作相关的地方

119
00:04:21,089 --> 00:04:22,470
看到大量这样的例子

120
00:04:22,470 --> 00:04:24,939
这些函数它要么返回-1

121
00:04:24,939 --> 00:04:25,990
要么返回零

122
00:04:25,990 --> 00:04:29,019
用来表示说呢这个操作没成功啊

123
00:04:29,019 --> 00:04:30,009
但是呢

124
00:04:30,009 --> 00:04:35,139
如果你的这个函数返回任何值都是有效的

125
00:04:35,139 --> 00:04:36,899
可能的情况的话

126
00:04:36,939 --> 00:04:39,658
如果返回任何的值都是有效的

127
00:04:39,658 --> 00:04:42,358
零和-1也是在你返回有效的里头

128
00:04:45,238 --> 00:04:46,839
你这个运算是否正确

129
00:04:46,899 --> 00:04:49,360
那么这个时候你得分开返回

130
00:04:49,360 --> 00:04:50,560
而分开返回呢

131
00:04:50,560 --> 00:04:52,029
我们往往是这么做

132
00:04:52,029 --> 00:04:55,040
状态用函数的返回来返回

133
00:04:55,040 --> 00:04:57,139
用函数的return来返回

134
00:04:57,139 --> 00:05:01,788
而实际的值呢通过指针参数来返回

135
00:05:01,788 --> 00:05:03,319
这样做的好处是

136
00:05:03,319 --> 00:05:05,509
我容易把这个函数的返回结果

137
00:05:05,509 --> 00:05:07,009
放到f里语句里头去

138
00:05:07,009 --> 00:05:07,798
对不对

139
00:05:07,798 --> 00:05:09,059
我们来看一个例子

140
00:05:09,059 --> 00:05:13,139
我们想做一个两个整数做除法的函数

141
00:05:13,259 --> 00:05:15,509
我们在这儿定义了这个divide函数

142
00:05:15,509 --> 00:05:16,259
diy函数

143
00:05:16,259 --> 00:05:17,339
你要三个参数

144
00:05:17,339 --> 00:05:18,120
第一个参数是a

145
00:05:18,120 --> 00:05:18,899
第二个参数是b

146
00:05:18,899 --> 00:05:20,930
他要去做a除以b的事情

147
00:05:20,930 --> 00:05:26,069
它的相除的结果通过这个指针result来交回来

148
00:05:26,069 --> 00:05:27,509
但是他也有个返回值

149
00:05:27,509 --> 00:05:30,269
它的返回值呢如果除法是成功的

150
00:05:30,269 --> 00:05:30,988
它返回一

151
00:05:30,988 --> 00:05:32,158
否则返回零

152
00:05:32,158 --> 00:05:34,019
为什么会有相除不成功呢

153
00:05:34,019 --> 00:05:36,298
我们知道说如果两个整数相除的时候

154
00:05:36,298 --> 00:05:38,009
如果除数是零

155
00:05:38,009 --> 00:05:40,720
那么如果你真的去做了这个除法

156
00:05:41,959 --> 00:05:43,899
你的程序会产生一个异常

157
00:05:43,899 --> 00:05:44,920
会被终止的

158
00:05:44,920 --> 00:05:46,959
所以如果我们发现说除数是零

159
00:05:46,959 --> 00:05:49,360
我们就让返回值为零

160
00:05:49,819 --> 00:05:51,079
就不去做运算了

161
00:05:51,079 --> 00:05:52,100
如果除数不是零

162
00:05:52,100 --> 00:05:55,009
那么我们去算出那个a除以b的结果

163
00:05:55,009 --> 00:05:56,870
最后呢我们返回这个返回值

164
00:05:56,870 --> 00:05:58,160
那么在main里面呢

165
00:05:58,160 --> 00:05:59,029
我们要这么去用

166
00:05:59,029 --> 00:06:01,040
如果divide是成功的

167
00:06:01,699 --> 00:06:02,788
它返回是一

168
00:06:02,788 --> 00:06:03,749
他如果返回零

169
00:06:03,749 --> 00:06:05,608
那么这个衣服就不条件不满足

170
00:06:05,608 --> 00:06:07,918
它返回一条件是满足的

171
00:06:07,918 --> 00:06:09,059
那么我们就进来

172
00:06:09,059 --> 00:06:10,829
我们去输出a b c的结果

173
00:06:10,829 --> 00:06:13,800
你看按照我们下面的这个divide函数的代码

174
00:06:13,800 --> 00:06:15,569
如果b是零的

175
00:06:15,569 --> 00:06:18,000
他根本就没有去计算a除以b

176
00:06:18,000 --> 00:06:20,100
所以那个c里面是不会有任何

177
00:06:20,100 --> 00:06:21,110
有意义的结果的

178
00:06:21,110 --> 00:06:21,889
对不对

179
00:06:21,889 --> 00:06:23,930
所以这种指针应用的场景

180
00:06:23,930 --> 00:06:26,379
其实是我的运算可能会出错

181
00:06:26,439 --> 00:06:28,149
因此这种错误呢

182
00:06:28,149 --> 00:06:30,540
要通过另外的途径给表达出来

183
00:06:30,699 --> 00:06:33,160
在c我们可能只能用这种方式来做

184
00:06:33,160 --> 00:06:34,300
在后续的语言

185
00:06:34,300 --> 00:06:35,680
比如说c加加和java

186
00:06:35,680 --> 00:06:37,240
我们可以通过异常的机制

187
00:06:37,240 --> 00:06:38,579
来解决这样的问题

188
00:06:39,120 --> 00:06:40,699
在指针这一部分

189
00:06:40,699 --> 00:06:43,100
初学者最容易犯的错误是什么呢

190
00:06:43,100 --> 00:06:45,529
就是定义了一个指针变量

191
00:06:45,529 --> 00:06:47,420
还没有让它指向任何变量

192
00:06:47,420 --> 00:06:49,120
就开始使用指针

193
00:06:49,279 --> 00:06:51,500
比如说像这样子

194
00:06:51,500 --> 00:06:55,199
如果我们在这儿定义了一个int新p

195
00:06:56,279 --> 00:06:59,240
我们没有让他去等于任何地址

196
00:06:59,699 --> 00:07:01,860
然后很多作业会觉得说

197
00:07:01,860 --> 00:07:04,350
诶如果我有一个int k

198
00:07:04,350 --> 00:07:07,619
那我之后当然就可以对k赋值了

199
00:07:07,619 --> 00:07:09,329
现在我有了int新p

200
00:07:09,329 --> 00:07:11,249
那么新p既然是一个整数

201
00:07:11,249 --> 00:07:13,228
我是不是也可以对新p做腐殖呢

202
00:07:13,228 --> 00:07:15,709
no way不行

203
00:07:15,709 --> 00:07:19,279
因为这个时候你其实发生的事情是什么呢

204
00:07:19,279 --> 00:07:22,860
我们有一个i它里面会放一个六

205
00:07:22,860 --> 00:07:25,500
我们有一个k它里面可以放一些值

206
00:07:25,500 --> 00:07:26,279
比如12

207
00:07:26,279 --> 00:07:29,250
现在我们有一个p这个p是一个指针

208
00:07:29,250 --> 00:07:33,000
当你说int cp写到这一步的时候

209
00:07:33,000 --> 00:07:34,410
这个p里面有东西吗

210
00:07:34,410 --> 00:07:35,699
没有东西

211
00:07:35,959 --> 00:07:38,750
他没有和任何具体的变量联系在一起

212
00:07:38,750 --> 00:07:41,389
它没有被赋予一个实际的值

213
00:07:46,839 --> 00:07:50,860
我们知道所有的本地变量都不会有

214
00:07:51,180 --> 00:07:53,490
默认的初始值

215
00:07:53,490 --> 00:07:55,439
如果你没有对它做过腐殖

216
00:07:55,439 --> 00:07:59,538
这个本地变量里面现在什么东西都没有

217
00:07:59,538 --> 00:08:02,910
p是没有一个明确的值得

218
00:08:02,910 --> 00:08:04,290
他可能是一个乱七八糟的

219
00:08:04,290 --> 00:08:06,509
什么a b23 等等等等

220
00:08:06,509 --> 00:08:06,870
等

221
00:08:06,870 --> 00:08:09,189
于是呢如果把它当做地址的话

222
00:08:09,189 --> 00:08:12,860
它可能会指向一片莫名其妙的地方

223
00:08:13,680 --> 00:08:15,920
因此当你在说cp等于12的时候

224
00:08:15,920 --> 00:08:18,339
就是你试图往那个地方写入12

225
00:08:18,800 --> 00:08:22,819
而那个地方如果碰巧是一个不能写的地方

226
00:08:22,819 --> 00:08:25,680
o立刻你的程序就崩溃了

227
00:08:25,680 --> 00:08:26,639
我们试一下

228
00:08:26,639 --> 00:08:27,779
现在我们来试一下

229
00:08:27,779 --> 00:08:29,670
如果我们给他一个明确的

230
00:08:29,670 --> 00:08:32,059
它不该去的地方啊

231
00:08:32,059 --> 00:08:33,740
我们就直接给了他一个零

232
00:08:36,519 --> 00:08:39,359
他说segmentation fault

233
00:08:40,580 --> 00:08:43,480
当我们要试图去做这个事情的时候

234
00:08:43,480 --> 00:08:45,460
你看我们的第一个print语句还没有输出

235
00:08:45,460 --> 00:08:46,049
对不对

236
00:08:46,049 --> 00:08:47,159
在他之前

237
00:08:47,159 --> 00:08:48,990
他已经出现了segment推荐foot

238
00:08:48,990 --> 00:08:52,169
因为我们试图往零那个地方写了12

239
00:08:52,169 --> 00:08:52,958
这个值

240
00:08:53,000 --> 00:08:55,009
所以这是初学者常见的错误

241
00:08:55,009 --> 00:08:57,080
如果我们没有给他做腐蚀

242
00:08:57,080 --> 00:08:58,820
我们不见得每一次都出错

243
00:08:58,820 --> 00:09:01,318
你看这次诶好像没错嘛

244
00:09:01,519 --> 00:09:04,720
但是总有一天你会你会错的啊

245
00:09:04,720 --> 00:09:08,649
所以任何一个地址变量没有被腐蚀之前

246
00:09:08,649 --> 00:09:10,269
没有得到任何变量的

247
00:09:10,269 --> 00:09:11,740
实际的变量的地址之前

248
00:09:11,740 --> 00:09:13,200
你不能通过它

249
00:09:13,200 --> 00:09:17,009
通过他用新号去访问任何的变量

250
00:09:17,009 --> 00:09:18,299
去访问任何的数据

251
00:09:18,299 --> 00:09:19,580
那都是没有任何意义的

