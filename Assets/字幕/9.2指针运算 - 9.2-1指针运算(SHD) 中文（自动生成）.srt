1
00:00:04,440 --> 00:00:06,439
1+1=2吗

2
00:00:07,480 --> 00:00:09,240
这个问题太幼稚了是吧

3
00:00:09,240 --> 00:00:10,769
小学1年级就知道了吗

4
00:00:10,769 --> 00:00:12,060
1+1肯定等于二

5
00:00:12,419 --> 00:00:17,519
可是如果我问你一个指针加一

6
00:00:18,500 --> 00:00:23,440
它的结果是加了一那个数字吗

7
00:00:24,500 --> 00:00:25,809
我们来试试看

8
00:00:25,809 --> 00:00:29,359
我们现在有一个c h r的数组

9
00:00:29,500 --> 00:00:32,469
我们之前一直在在做int的数组啊

10
00:00:32,469 --> 00:00:34,119
啊其实c h i也一样对吧

11
00:00:34,119 --> 00:00:35,649
c h a r是一种整数

12
00:00:35,649 --> 00:00:38,219
所以呢我们来试一下这个c h r的数组

13
00:00:38,899 --> 00:00:40,689
ac这是一个c h的数组

14
00:00:40,689 --> 00:00:42,850
让它等于012345678 90

15
00:00:42,850 --> 00:00:44,659
打60~9

16
00:00:44,659 --> 00:00:46,159
让它等于0~9

17
00:00:46,159 --> 00:00:48,729
所以呢这个ac有十个单元

18
00:00:48,729 --> 00:00:50,799
然后呢我们做了一个c h r的指针

19
00:00:50,799 --> 00:00:53,109
cp之前一直都在做int金啊

20
00:00:53,109 --> 00:00:54,570
我们现在来做一下chasing

21
00:00:54,570 --> 00:00:58,409
恰信p等于a c所以p呢是一个指针

22
00:00:58,409 --> 00:01:02,549
它指向了a c这个数组的第一个单元

23
00:01:02,549 --> 00:01:06,888
那好接下来呢我们做的事情就是premiss

24
00:01:06,888 --> 00:01:07,759
输出一下

25
00:01:07,759 --> 00:01:13,060
说这个p的地址等于多少是吧

26
00:01:13,060 --> 00:01:15,549
那么p这个值多少啊

27
00:01:15,549 --> 00:01:17,719
输出一下这个p的值是多少

28
00:01:18,900 --> 00:01:21,980
然后呢我们把这个事情再往前推一步

29
00:01:21,980 --> 00:01:23,420
说我们想要看一下

30
00:01:23,420 --> 00:01:26,310
说这个p加一等于多少

31
00:01:26,310 --> 00:01:28,530
于是呢我们来看一下p加一的值

32
00:01:28,530 --> 00:01:29,010
对不对

33
00:01:29,010 --> 00:01:30,239
非常简单的程序啊

34
00:01:30,239 --> 00:01:31,560
我们现在来运行一下

35
00:01:31,560 --> 00:01:34,519
他说p呢是在5e上

36
00:01:34,519 --> 00:01:36,950
而p加一呢是在5f上

37
00:01:36,950 --> 00:01:38,209
这个是16进制

38
00:01:38,209 --> 00:01:40,040
所以e后头就是f大了

39
00:01:40,040 --> 00:01:41,299
a b c d e f嘛

40
00:01:41,319 --> 00:01:42,159
没错啊

41
00:01:42,159 --> 00:01:43,480
加一就是加了一嘛

42
00:01:43,480 --> 00:01:45,539
5e加了一变成5f了

43
00:01:46,019 --> 00:01:50,039
嗯那好我们再来看一个

44
00:01:50,379 --> 00:01:52,930
我们把这一段呢拷贝粘贴一下

45
00:01:52,930 --> 00:01:57,939
现在呢我们把chr换成chasing呢

46
00:01:57,939 --> 00:01:59,530
换成int型

47
00:01:59,530 --> 00:02:01,180
当然变量名字得换换啊

48
00:02:01,180 --> 00:02:03,750
这是ai p变什么呢

49
00:02:03,750 --> 00:02:07,120
嗯当年人们在做这个事情的时候

50
00:02:07,120 --> 00:02:08,740
真的是毫无想象力

51
00:02:08,740 --> 00:02:09,680
你知道吗

52
00:02:10,060 --> 00:02:11,889
我们做整数的时候

53
00:02:11,889 --> 00:02:17,800
i用完了j k l m n做这个指针的时候

54
00:02:17,800 --> 00:02:19,539
p因为是pointer的第一个字母

55
00:02:19,539 --> 00:02:21,490
所以用p来表达式指针

56
00:02:21,490 --> 00:02:25,088
p用完了q r s t真的就是这样

57
00:02:25,088 --> 00:02:25,718
ok好吧

58
00:02:25,718 --> 00:02:26,709
我们也不能免书

59
00:02:26,709 --> 00:02:29,558
这就是q q等于ai

60
00:02:29,558 --> 00:02:30,399
然后我们来看一下

61
00:02:30,399 --> 00:02:32,709
说q和q加一是多少

62
00:02:32,709 --> 00:02:34,299
那么这是q

63
00:02:34,299 --> 00:02:36,659
这是q加e来运行一下

64
00:02:38,419 --> 00:02:41,979
p5 a p加15b ok

65
00:02:41,979 --> 00:02:48,759
这是加1q2 c q加1302

66
00:02:48,759 --> 00:02:50,080
c和三零是多少

67
00:02:50,080 --> 00:02:50,860
16进制

68
00:02:50,860 --> 00:02:52,150
如果你不太熟的话

69
00:02:52,150 --> 00:02:53,120
很简单

70
00:02:53,120 --> 00:02:54,229
c是什么呢

71
00:02:54,229 --> 00:02:58,280
你扳扳手指头a b c第三个a是十

72
00:02:58,280 --> 00:02:59,659
所以是10 11 12

73
00:02:59,659 --> 00:03:01,719
所以c呢就是12

74
00:03:03,998 --> 00:03:06,299
零对于16进制来说

75
00:03:06,299 --> 00:03:10,539
零意味着进位了12~16之间

76
00:03:10,539 --> 00:03:12,729
它要它要加到16的时候才进位

77
00:03:12,729 --> 00:03:15,199
12~16之间刚好是四

78
00:03:15,199 --> 00:03:18,719
也就是说30-2 c一的结果就是四

79
00:03:18,859 --> 00:03:20,329
四是什么

80
00:03:20,329 --> 00:03:22,960
我这个q是做的是加一

81
00:03:23,099 --> 00:03:26,219
他给了我说诶你的结果加四了

82
00:03:26,219 --> 00:03:27,819
这个地址加四了

83
00:03:28,899 --> 00:03:30,149
为什么加四

84
00:03:30,149 --> 00:03:30,658
为什么

85
00:03:30,658 --> 00:03:31,719
刚才tra加一

86
00:03:33,618 --> 00:03:36,338
size of tra是一

87
00:03:36,338 --> 00:03:40,080
而size of int是四

88
00:03:40,919 --> 00:03:45,229
所以当我们给一个指针去加一的时候

89
00:03:45,229 --> 00:03:47,659
它不是在地址值上加一

90
00:03:47,659 --> 00:03:50,520
它在地址值上加一个size of

91
00:03:50,520 --> 00:03:54,780
那个指针所指的类型为啥

92
00:03:55,860 --> 00:03:58,199
如果我现在有一个数组

93
00:03:59,618 --> 00:04:01,500
这个数组的类型是char

94
00:04:02,618 --> 00:04:05,278
如果他的第一个单元

95
00:04:05,278 --> 00:04:07,110
这是一个tra的数组

96
00:04:07,110 --> 00:04:08,669
他的第一个单元的地址

97
00:04:08,669 --> 00:04:10,620
如果是我们刚才看到5e的话

98
00:04:10,620 --> 00:04:12,689
那我们知道它的第二个单元的地址

99
00:04:12,689 --> 00:04:13,460
就是5f

100
00:04:13,460 --> 00:04:17,920
因为五一和5f的距离正好可以放一个圈

101
00:04:18,879 --> 00:04:23,110
现在如果我们是一个int的数组的话

102
00:04:23,110 --> 00:04:25,629
我们知道int的数组的一个单元

103
00:04:25,629 --> 00:04:27,250
要占据四个字节

104
00:04:27,250 --> 00:04:29,500
所以这是一个int的数组

105
00:04:29,500 --> 00:04:34,480
它的第零个单元的地址如果是2c的话

106
00:04:34,620 --> 00:04:39,060
那么它的第一个单元的地址就得在三零上

107
00:04:39,060 --> 00:04:41,579
而他的第三个啊

108
00:04:41,579 --> 00:04:46,199
或者叫做2号单元的地址就应该在三四上

109
00:04:46,420 --> 00:04:47,199
对不对

110
00:04:47,199 --> 00:04:50,079
相邻的单元的地址的差距

111
00:04:50,079 --> 00:04:53,410
正好是它的这个基础类型的大小

112
00:04:53,410 --> 00:04:57,790
所以如果这个q原本等于这个

113
00:04:57,790 --> 00:05:00,069
也就意味着q指向的是这个单元

114
00:05:00,069 --> 00:05:05,279
那我们让q加一的意思是让这个q加一

115
00:05:05,279 --> 00:05:07,470
这个地址等于他

116
00:05:07,470 --> 00:05:11,899
也就是说q加一指向了他的第二个单元

117
00:05:11,899 --> 00:05:13,420
也就是1号单元

118
00:05:14,160 --> 00:05:16,910
所以对指针做一个加一的动作

119
00:05:16,910 --> 00:05:20,819
意味着我们要把它移到下一个单元去

120
00:05:20,819 --> 00:05:25,019
我们给实际的指针值加上的是size of

121
00:05:25,019 --> 00:05:26,740
那个基础类型

122
00:05:26,740 --> 00:05:30,519
大家可以自己拿我的这个程序再去试一下

123
00:05:30,519 --> 00:05:31,120
其他的类型

124
00:05:31,120 --> 00:05:31,870
比如说double

125
00:05:31,870 --> 00:05:33,048
比如说long long

126
00:05:33,048 --> 00:05:34,249
比如说short

127
00:05:34,249 --> 00:05:36,348
看看是不是真的如我所言

128
00:05:36,348 --> 00:05:38,899
当你要让一个指针去加一的时候

129
00:05:38,899 --> 00:05:41,139
它实际上加的是size of

130
00:05:43,540 --> 00:05:45,870
那既然如此

131
00:05:45,870 --> 00:05:48,160
我们就想起一件事情来

132
00:05:48,300 --> 00:05:52,019
因为我们在讲到数组和指针的关系的时候

133
00:05:52,019 --> 00:05:53,490
我们提到过说

134
00:05:53,490 --> 00:05:57,860
当你把一个数组付给一个指针以后

135
00:05:58,120 --> 00:06:02,470
你可以拿那个指针像数组一样的操作

136
00:06:02,470 --> 00:06:04,899
你也可以拿那个数组变量

137
00:06:04,899 --> 00:06:06,420
像指针一样的操作

138
00:06:06,699 --> 00:06:07,870
也就是说

139
00:06:07,870 --> 00:06:10,540
如果现在你有新p

140
00:06:11,319 --> 00:06:13,139
在现在这句话的位置上面

141
00:06:13,139 --> 00:06:16,620
cp就相当于是ac的零

142
00:06:17,500 --> 00:06:19,470
如果我有cp加一

143
00:06:19,470 --> 00:06:20,680
它是什么

144
00:06:22,959 --> 00:06:25,980
p加一就是八字真指向了他的下一个

145
00:06:25,980 --> 00:06:28,410
那么当然它就等于a c的一了

146
00:06:28,410 --> 00:06:29,639
相当于a c的一

147
00:06:29,639 --> 00:06:30,209
对不对

148
00:06:30,209 --> 00:06:31,620
在这儿我们要加括号

149
00:06:31,620 --> 00:06:35,119
是因为星号是一个单目运算符

150
00:06:35,119 --> 00:06:37,819
它的优先级比这个加号要来得高

151
00:06:37,819 --> 00:06:40,620
所以我们必须放一个括号

152
00:06:40,620 --> 00:06:42,889
来保证说加一这件事情先做

153
00:06:42,889 --> 00:06:45,889
然后再去取那个加了一以后的

154
00:06:45,889 --> 00:06:46,819
地址上的东西

155
00:06:46,819 --> 00:06:48,470
我们不妨来试一下这件事情

156
00:06:48,470 --> 00:06:49,790
我们想要输出一下

157
00:06:49,790 --> 00:06:51,439
说这个

158
00:06:53,259 --> 00:06:57,300
新p加一的值是多少

159
00:06:58,079 --> 00:07:00,319
同样的我们在这儿也可以来输出一下

160
00:07:00,319 --> 00:07:03,019
做这个新q加一的值是多少

161
00:07:03,019 --> 00:07:09,370
我们看到新p加一就是一一就是a c e

162
00:07:09,370 --> 00:07:12,459
新q加e就是e e就是ai 1

163
00:07:13,420 --> 00:07:14,339
所以也就是

164
00:07:14,339 --> 00:07:16,860
我们把它挪到下一个位置上去了

165
00:07:16,860 --> 00:07:19,519
如果它不是这么加了个一

166
00:07:19,658 --> 00:07:22,298
它是在地址上面加了个一

167
00:07:22,298 --> 00:07:24,279
那等他加完一以后

168
00:07:25,100 --> 00:07:26,560
他没有意义了

169
00:07:26,560 --> 00:07:28,089
你看在这张图上

170
00:07:28,089 --> 00:07:31,798
如果说我们让这个q加一不是变成三零

171
00:07:31,798 --> 00:07:33,500
而是变成了2c加一

172
00:07:33,500 --> 00:07:36,319
2c加一作为16进制运算

173
00:07:36,319 --> 00:07:39,899
2c加一结果是2d2 d是什么

174
00:07:39,899 --> 00:07:42,180
我们这个整数是四个字节

175
00:07:42,180 --> 00:07:43,079
对不对

176
00:07:43,180 --> 00:07:46,180
这是2c那下一个单元呢是2d

177
00:07:46,180 --> 00:07:49,439
你说我的q指向了这个东西的话

178
00:07:49,978 --> 00:07:51,238
他没有任何意义

179
00:07:51,238 --> 00:07:53,579
他不可能说我拿这三个字节

180
00:07:53,579 --> 00:07:57,040
加上后面那个int的前一个字节拼起来

181
00:07:57,040 --> 00:07:58,240
ok这我有四个字节了

182
00:07:58,240 --> 00:07:59,720
这四个字节是个int

183
00:08:00,480 --> 00:08:02,000
这没有任何用处啊

184
00:08:02,000 --> 00:08:03,889
这不是一个我们想要的int

185
00:08:03,889 --> 00:08:05,120
这不是在那个数组里面

186
00:08:05,120 --> 00:08:06,680
任何一个有效的东西

187
00:08:07,098 --> 00:08:10,399
所以加一一定得要加上size那个东西

188
00:08:10,779 --> 00:08:12,759
实际上对于这样的运算来说

189
00:08:12,759 --> 00:08:14,079
如果你的这个指针

190
00:08:14,079 --> 00:08:15,879
不是指向了一片连续的空间

191
00:08:15,879 --> 00:08:17,170
比如说像速度这样的

192
00:08:17,170 --> 00:08:19,740
那么这种加一是没有任何意义的

193
00:08:20,538 --> 00:08:21,798
当然不光是加一

194
00:08:21,798 --> 00:08:23,209
我们也可以加2+3

195
00:08:23,209 --> 00:08:27,160
其实看到这个你就会知道说在这里

196
00:08:27,160 --> 00:08:29,860
实际上当你p指向了ac以后

197
00:08:29,860 --> 00:08:38,038
那么新p加n和ac的n他们就是等价的

198
00:08:38,500 --> 00:08:40,859
这两件事情是完全相等的

199
00:08:41,080 --> 00:08:45,438
我们让p加上多少个单元之后

200
00:08:45,720 --> 00:08:47,879
去取那个地址上的东西

201
00:08:51,629 --> 00:08:52,958
是一回事儿

202
00:08:53,080 --> 00:08:54,399
所以我们已经知道说

203
00:08:54,399 --> 00:08:57,070
指针是可以去加一个整数的

204
00:08:57,070 --> 00:08:59,320
那么除了做加一个整数以外

205
00:08:59,320 --> 00:09:00,730
还有什么事可以做呢

206
00:09:00,730 --> 00:09:02,479
减一个整数也可以

207
00:09:02,899 --> 00:09:05,120
既然加可以加等于也可以减

208
00:09:05,120 --> 00:09:07,269
等于也可以减的意思是什么

209
00:09:07,269 --> 00:09:10,990
在我现在这个位置上往前挪一些

210
00:09:10,990 --> 00:09:12,309
家是往后挪

211
00:09:12,309 --> 00:09:15,960
那么减呢就是往前挪递增递减

212
00:09:17,399 --> 00:09:21,139
p加加q加加啥意思

213
00:09:21,500 --> 00:09:23,360
挪到下一个位置上去

214
00:09:23,360 --> 00:09:25,159
p加加p等于p加一嘛

215
00:09:25,159 --> 00:09:26,958
挪到下一个位置上去

216
00:09:28,039 --> 00:09:31,240
其实我们在很多代码里面经常看到

217
00:09:31,240 --> 00:09:33,899
这样加加对指针做加加减减的运算

218
00:09:34,220 --> 00:09:39,639
还有两个指针可以相减诶

219
00:09:39,639 --> 00:09:40,960
这又有问题了

220
00:09:40,960 --> 00:09:42,639
减的结果是什么

221
00:09:42,639 --> 00:09:43,600
我们来试一下

222
00:09:43,600 --> 00:09:47,500
看我们现在呢这样我们有个p

223
00:09:47,659 --> 00:09:51,299
我们再来个p让它等于什么呢

224
00:09:51,299 --> 00:09:52,379
等于ac的

225
00:09:52,379 --> 00:09:56,578
比如说5号那个位置上的那个单元的地址

226
00:09:56,720 --> 00:09:59,659
然后呢我们来输出一下

227
00:09:59,659 --> 00:10:03,759
说唉现在呢这个p一减p啊等于多少

228
00:10:04,659 --> 00:10:05,539
嗯

229
00:10:06,200 --> 00:10:08,080
我相信他们剪完以后是个整数

230
00:10:08,080 --> 00:10:09,639
我们可以先用整数来试试看啊

231
00:10:09,639 --> 00:10:11,679
如果说这个呃百分之d不对

232
00:10:11,679 --> 00:10:12,639
编译给我打回了

233
00:10:12,639 --> 00:10:13,720
我们再来改别的啊

234
00:10:13,720 --> 00:10:14,740
p一减p

235
00:10:15,659 --> 00:10:18,440
当然同样的我们应该对q也做一下是吧

236
00:10:18,440 --> 00:10:22,379
所以呢我们有一个对这个我们有个q一啊

237
00:10:22,379 --> 00:10:26,200
他也等于ai的5号位置上的啊

238
00:10:26,200 --> 00:10:28,120
或者我们换一个这个6号位置上也一样

239
00:10:28,120 --> 00:10:28,600
对不对

240
00:10:28,600 --> 00:10:28,990
好

241
00:10:28,990 --> 00:10:31,120
然后呢我们也来说说说诶

242
00:10:31,120 --> 00:10:34,230
那我这个q一减q等于多少

243
00:10:34,230 --> 00:10:36,269
q一到q

244
00:10:37,740 --> 00:10:39,980
编译运行没问题哈

245
00:10:39,980 --> 00:10:41,299
过了我们来看这结果

246
00:10:41,299 --> 00:10:42,019
怎么说

247
00:10:42,019 --> 00:10:46,580
这结果呢说这个p一减p啊

248
00:10:46,580 --> 00:10:47,698
等于五

249
00:10:48,899 --> 00:10:52,009
这个p呢是a c0 对吧

250
00:10:52,009 --> 00:10:53,779
你把它写成这个样子

251
00:10:53,779 --> 00:10:56,960
和你把它写成and a c0 是一回事

252
00:10:56,960 --> 00:10:59,720
那五和零之间距离就是五嘛

253
00:10:59,720 --> 00:11:00,479
没错

254
00:11:00,659 --> 00:11:03,659
他说q一到q呢是六

255
00:11:05,100 --> 00:11:07,789
这个有点好奇呃

256
00:11:07,789 --> 00:11:09,200
q一的值到底是多少

257
00:11:09,200 --> 00:11:10,039
我们不妨在这儿呢

258
00:11:10,039 --> 00:11:11,840
让他们不要看q加e了

259
00:11:11,840 --> 00:11:13,639
你给我看看q一是多少啊

260
00:11:13,639 --> 00:11:15,730
给我们看一下q一的值是多少

261
00:11:15,730 --> 00:11:19,509
我们来看一下q一是四零

262
00:11:19,509 --> 00:11:21,219
那个是二八

263
00:11:21,419 --> 00:11:22,620
这16进制啊

264
00:11:22,620 --> 00:11:24,219
40-28是多少呢

265
00:11:24,559 --> 00:11:25,639
我也懒得算我

266
00:11:25,639 --> 00:11:27,649
我们找这个计算器帮忙

267
00:11:27,649 --> 00:11:29,059
我们现在这个16进制哈

268
00:11:29,059 --> 00:11:34,720
我们要40-28等于呢

269
00:11:34,720 --> 00:11:36,460
他说连x18 的实际是多少呢

270
00:11:36,460 --> 00:11:37,719
24

271
00:11:39,580 --> 00:11:40,740
24

272
00:11:40,740 --> 00:11:43,740
也就是说q一和q之间这俩地址

273
00:11:43,740 --> 00:11:46,679
他们如果直接减的话

274
00:11:46,679 --> 00:11:47,850
应该是24

275
00:11:47,850 --> 00:11:51,299
但是呢他告诉我说q一减q呢等于六六

276
00:11:51,299 --> 00:11:51,840
是什么

277
00:11:51,840 --> 00:11:55,159
24除以什么size of int

278
00:11:55,379 --> 00:11:58,500
所以当你去减两个指针的时候

279
00:11:58,500 --> 00:11:59,549
它给你的是什么

280
00:11:59,549 --> 00:12:02,159
给你的不是这两个地址的差

281
00:12:02,159 --> 00:12:06,059
给你的是这两个地址的差除以那个size of

282
00:12:06,059 --> 00:12:06,840
它的类型

283
00:12:06,840 --> 00:12:08,429
也就是他告诉你说

284
00:12:08,429 --> 00:12:13,440
在这俩地址中间有几个这样类型的东西在

285
00:12:13,440 --> 00:12:16,659
或者说能放几个这样类型的东西

286
00:12:17,559 --> 00:12:20,039
这是指针减法的意思

287
00:12:20,039 --> 00:12:23,659
我们刚才看到有这个加加减减递增的运算

288
00:12:23,659 --> 00:12:24,200
对吧

289
00:12:24,200 --> 00:12:25,759
那比较有意思的就是

290
00:12:25,759 --> 00:12:27,590
我们其实经常在程序里面看见的呢

291
00:12:27,590 --> 00:12:28,519
是这个写法

292
00:12:28,519 --> 00:12:32,559
新t加加新b加加是什么意思呢

293
00:12:32,559 --> 00:12:34,870
呃在这里头我们有俩运算符啊

294
00:12:34,870 --> 00:12:36,639
那么从优先级来说呢

295
00:12:36,639 --> 00:12:38,710
加加这个运算符的优先级啊

296
00:12:38,710 --> 00:12:40,399
比心还要高

297
00:12:40,620 --> 00:12:42,818
所以呢我们不需要后面有括号

298
00:12:43,200 --> 00:12:46,409
我们让p去做一个加加的运算

299
00:12:46,409 --> 00:12:48,059
可是我们知道这是后缀

300
00:12:48,059 --> 00:12:51,620
后缀的意思就是p当然会加一

301
00:12:51,620 --> 00:12:55,340
可是呢p加加的结果是p加一前的结果

302
00:12:55,340 --> 00:12:58,318
这就是我们之前讲反复讲很多遍的事情

303
00:12:58,480 --> 00:13:00,859
完了以后再对他取心

304
00:13:00,879 --> 00:13:03,100
取出这个指针

305
00:13:03,100 --> 00:13:06,340
取出这个指针所指的那个地方的

306
00:13:06,340 --> 00:13:08,299
值了那个地方的东西来

307
00:13:09,980 --> 00:13:12,940
也就是说我们要去取出p所指的那个

308
00:13:12,940 --> 00:13:14,339
对方的那个东西

309
00:13:14,659 --> 00:13:18,440
顺便把p加个一啊

310
00:13:18,440 --> 00:13:19,490
顺便把p加一

311
00:13:19,490 --> 00:13:23,240
那这种东西呢经常用于像数组这样的

312
00:13:23,240 --> 00:13:25,159
连续空间的数据

313
00:13:25,159 --> 00:13:26,909
我去做一些操作

314
00:13:26,909 --> 00:13:28,938
比如说像便利这样的操作

315
00:13:28,960 --> 00:13:30,759
因为在之前啊

316
00:13:30,759 --> 00:13:31,990
我们如果要便利的话

317
00:13:31,990 --> 00:13:33,580
比如说我们就拿这个代码来说哈

318
00:13:33,580 --> 00:13:36,419
我们把不相干的东西先拿掉一些

319
00:13:37,539 --> 00:13:39,120
如果我们要遍历这个a c

320
00:13:39,120 --> 00:13:41,039
那我们做法是说我们会有个int i

321
00:13:41,039 --> 00:13:43,340
然后呢我们for说i等于零

322
00:13:43,340 --> 00:13:44,539
i呢小于

323
00:13:44,539 --> 00:13:46,340
比如说这个size of a c呢

324
00:13:46,340 --> 00:13:52,159
去除以这个size size of这个ac的零是吧

325
00:13:52,159 --> 00:13:57,000
完了以后呢i佳佳那循环的每一步呢

326
00:13:57,000 --> 00:13:57,600
我们就说啊

327
00:13:57,600 --> 00:14:02,539
我们要print af这个a c的i对吧

328
00:14:02,539 --> 00:14:04,279
我们就把这个值给输出了

329
00:14:04,279 --> 00:14:05,870
这是一个便利的方法

330
00:14:05,870 --> 00:14:08,720
现在呢我们还可以有另外一个便利的方法

331
00:14:08,720 --> 00:14:15,620
我们可以说我们呢让这个p等于ac

332
00:14:16,279 --> 00:14:20,019
也就是说有个指针指向数组的头

333
00:14:20,019 --> 00:14:21,250
完了以后呢

334
00:14:21,250 --> 00:14:23,080
p呢每次要加加

335
00:14:23,080 --> 00:14:25,659
当然这中间还有条件是啥

336
00:14:26,679 --> 00:14:28,139
条件是啥呢

337
00:14:29,340 --> 00:14:30,740
有两个办法

338
00:14:30,740 --> 00:14:35,299
一个办法呢是说我可以在这个数组里头啊

339
00:14:35,299 --> 00:14:37,519
我在最后放一个特殊的东西

340
00:14:37,519 --> 00:14:39,620
比如说-1啊

341
00:14:39,620 --> 00:14:42,440
假如说-1不可能是有效的数据的话

342
00:14:42,440 --> 00:14:43,519
我就放个-1在那

343
00:14:43,519 --> 00:14:46,509
所以呢这条件就变成说什么时候

344
00:14:46,509 --> 00:14:48,370
新p不等于-1的话

345
00:14:48,370 --> 00:14:51,179
表明咱们还没走到头呢是吧

346
00:14:51,179 --> 00:14:52,139
完了以后呢

347
00:14:52,139 --> 00:14:54,779
我在里头呢就可以print f说诶

348
00:14:54,779 --> 00:14:57,629
百分号d杠n是什么呢

349
00:14:57,629 --> 00:15:00,669
新p我不用加加了对吧

350
00:15:00,669 --> 00:15:02,200
如果我说cp加加

351
00:15:02,200 --> 00:15:04,818
ok那我for循环的这个呢可以不要

352
00:15:05,820 --> 00:15:06,500
当然了

353
00:15:06,500 --> 00:15:07,610
既然写成这样

354
00:15:07,610 --> 00:15:08,720
大家也看出来了

355
00:15:08,720 --> 00:15:10,639
我完全可以把这个for循环写成什么

356
00:15:10,639 --> 00:15:11,840
is while对吧

357
00:15:11,840 --> 00:15:14,289
因为我前奏新p等于ac已经有了

358
00:15:14,289 --> 00:15:18,399
所以while cp不等于-1诶

359
00:15:18,399 --> 00:15:20,620
我来做这个诶

360
00:15:20,620 --> 00:15:22,120
我来做这个啊

361
00:15:22,120 --> 00:15:22,659
输出

362
00:15:22,659 --> 00:15:24,039
我们可以试一下这件事情

363
00:15:24,039 --> 00:15:28,539
我们看到我们有两个输出的结果对吧

364
00:15:28,539 --> 00:15:29,799
第一个输出结果带的-1了

365
00:15:29,799 --> 00:15:31,889
因为这个的输出

366
00:15:31,889 --> 00:15:33,269
当然他会把所有输出的内容

367
00:15:33,269 --> 00:15:34,350
都是输出了是吧

368
00:15:34,350 --> 00:15:34,769
然后呢

369
00:15:34,769 --> 00:15:36,990
我们这种做新p加加的输出的时候呢

370
00:15:36,990 --> 00:15:39,659
他是说你p所指的那东西不等于-1

371
00:15:39,659 --> 00:15:43,000
也就是说-1是不会作为输出的一部分

372
00:15:43,000 --> 00:15:43,779
来输出的

373
00:15:43,779 --> 00:15:45,379
它是一个结尾的标志

374
00:15:45,879 --> 00:15:48,940
我们在下个星期讲字符串的时候

375
00:15:48,940 --> 00:15:50,979
我会大量的看到这样的运算

376
00:15:51,360 --> 00:15:53,610
到那个时候我们再来仔细探究

377
00:15:53,610 --> 00:15:56,340
这个新皮加加到底有什么意思

378
00:15:56,340 --> 00:15:58,120
这个新皮加加

379
00:15:58,779 --> 00:16:00,600
在我们知道c语言

380
00:16:00,600 --> 00:16:02,460
最早是在一个叫做p dp eleven

381
00:16:02,460 --> 00:16:03,809
的机器上做出来的啊

382
00:16:03,809 --> 00:16:07,958
在那个机器的汇编指令里头有一条指令

383
00:16:08,220 --> 00:16:11,698
这一条指令做的事情就是新皮加加

384
00:16:12,480 --> 00:16:15,879
也就是说如果你把你的代码写成cp加加

385
00:16:15,879 --> 00:16:19,029
那那个时候c语言的编译器就可以很省事

386
00:16:19,029 --> 00:16:19,720
一看哦

387
00:16:19,720 --> 00:16:22,539
你有心p加加打p可以变成任何变量对吧

388
00:16:22,539 --> 00:16:23,938
你有心什么什么加

389
00:16:24,000 --> 00:16:24,419
他

390
00:16:24,419 --> 00:16:26,220
就可以把你的c语言的代码

391
00:16:26,220 --> 00:16:28,099
翻译成那一条机器指令

392
00:16:28,919 --> 00:16:30,200
于是我们知道什么

393
00:16:32,120 --> 00:16:36,379
所以当初要设计加加减减这样的运算符

394
00:16:36,379 --> 00:16:38,809
要设计这样的指针的操作

395
00:16:38,809 --> 00:16:42,429
完全就是为了让c语言写出来的代码

396
00:16:44,360 --> 00:16:45,590
那后续呢

397
00:16:45,590 --> 00:16:49,029
其实很多的处理器也都延续了

398
00:16:49,029 --> 00:16:50,169
这样的一种指令

399
00:16:50,169 --> 00:16:52,210
我们pc用的x86 的处理器

400
00:16:52,210 --> 00:16:53,990
里头也有类似的指令

401
00:16:53,990 --> 00:16:56,870
但是不是所有的处理器都有这样的指令的

402
00:16:56,870 --> 00:16:58,370
如果正好你遇到的那个处理器

403
00:16:58,370 --> 00:16:59,029
没有这样的指令

404
00:16:59,029 --> 00:17:02,580
其实cp cb加加呢就不会跑的特别的快啊

405
00:17:02,580 --> 00:17:03,750
当然这是题外话啊

406
00:17:03,750 --> 00:17:06,078
我们多看点背景的知识

407
00:17:07,940 --> 00:17:12,029
另外除了甲减没有乘除啊

408
00:17:12,029 --> 00:17:13,380
指针不能做乘除啊

409
00:17:13,380 --> 00:17:14,579
指针做乘除没有任何意义

410
00:17:14,579 --> 00:17:15,059
对不对

411
00:17:15,059 --> 00:17:16,779
你说我俩地址乘一下

412
00:17:17,859 --> 00:17:20,099
这这这没意思对吧

413
00:17:20,099 --> 00:17:21,839
又不是算面积啊

414
00:17:23,220 --> 00:17:24,299
可以做加减

415
00:17:25,039 --> 00:17:26,858
可以做比较

416
00:17:27,339 --> 00:17:29,859
可以比较指针是否相等

417
00:17:29,859 --> 00:17:31,539
可以比较比指针是否不相等

418
00:17:31,539 --> 00:17:34,339
可以比较指针大于还是小于

419
00:17:34,420 --> 00:17:35,859
当然对于指针的比较

420
00:17:35,859 --> 00:17:39,279
你想得到它其实就是地址的大小的比较

421
00:17:39,279 --> 00:17:40,000
对不对

422
00:17:40,000 --> 00:17:42,940
所以如果你有一个指针指向a0 

423
00:17:42,940 --> 00:17:44,200
另外一个指针指向a5 

424
00:17:44,200 --> 00:17:46,079
那么明显指向a0 的指针

425
00:17:46,079 --> 00:17:47,519
比指向a5 的指针要来的小

426
00:17:47,519 --> 00:17:50,920
因为数组它是这样顺序递增排列的啊

427
00:17:50,920 --> 00:17:51,519
这很简单

428
00:17:52,839 --> 00:17:54,039
还有一个问题

429
00:17:54,940 --> 00:17:57,180
零地址是怎么回事啊

430
00:17:58,559 --> 00:18:01,220
我们现代的这些操作系统

431
00:18:01,220 --> 00:18:06,680
无论是windows macos还是linux或者其他的unix

432
00:18:07,759 --> 00:18:11,750
这些操作系统都是叫做多进程的操作系统

433
00:18:11,750 --> 00:18:14,450
它的基本的管理单元是叫做进程

434
00:18:14,450 --> 00:18:15,410
什么是进程呢

435
00:18:15,410 --> 00:18:17,089
你double click一个东西

436
00:18:17,089 --> 00:18:18,500
它运行起来了

437
00:18:18,500 --> 00:18:20,700
它就是操作系统里面的一个进程

438
00:18:20,980 --> 00:18:22,450
对于进程来说

439
00:18:22,450 --> 00:18:23,799
最基本的概念是说

440
00:18:23,799 --> 00:18:27,549
操作系统会给他一个虚拟的地址空间

441
00:18:27,549 --> 00:18:30,339
也就是说所有的程序在运行的时候

442
00:18:30,339 --> 00:18:31,900
都以为自己具有

443
00:18:31,900 --> 00:18:34,809
从零开始的一片连续的空间

444
00:18:34,809 --> 00:18:36,309
那个顶是多少呢

445
00:18:36,309 --> 00:18:37,750
如果32位机器的话

446
00:18:37,750 --> 00:18:40,799
那个顶就是4g4 个g杆啊

447
00:18:40,799 --> 00:18:42,779
当然实际上你用不了那么多呃

448
00:18:42,779 --> 00:18:45,180
我们很快会看我们怎么样去探测你

449
00:18:45,180 --> 00:18:47,019
你到底能用多少空间啊

450
00:18:47,339 --> 00:18:50,519
呃所以任何益生菌里面都有零地址

451
00:18:50,519 --> 00:18:53,180
不是说我这个程序用了零定制了那个地

452
00:18:53,180 --> 00:18:54,200
那个程序就没有零地址

453
00:18:54,200 --> 00:18:55,789
所有程序都有一个虚拟的啊

454
00:18:55,789 --> 00:18:57,079
当然这个虚拟的物理怎么翻译

455
00:18:57,079 --> 00:18:58,220
这是另外一回事

456
00:18:58,220 --> 00:19:00,200
我们有另外一门课叫做操作系统

457
00:19:00,200 --> 00:19:03,000
在那门课里面我们会详细讲这些事情

458
00:19:03,000 --> 00:19:06,180
现在我们还很很在计算机非常基础的地方

459
00:19:06,180 --> 00:19:06,919
对不对

460
00:19:07,579 --> 00:19:09,309
每个程序都有一个零地址

461
00:19:09,309 --> 00:19:11,960
但是这个零地址呢是你不能碰的

462
00:19:12,240 --> 00:19:14,519
你不能往那个零地址里面去写

463
00:19:14,519 --> 00:19:16,799
甚至有的系统说

464
00:19:16,799 --> 00:19:19,039
你你去读那个零地址都是不行的

465
00:19:19,039 --> 00:19:20,720
所以在这种情况下

466
00:19:20,720 --> 00:19:23,420
我们通常用零这个地址

467
00:19:23,420 --> 00:19:25,200
来表示一些特殊的事情

468
00:19:25,460 --> 00:19:27,799
比方说你要返回指针的

469
00:19:27,799 --> 00:19:30,440
我返回零告诉你说这事儿没戏

470
00:19:30,440 --> 00:19:33,130
这事儿没成呃

471
00:19:33,130 --> 00:19:36,130
或者呢当你有了一个指针变量之后

472
00:19:36,130 --> 00:19:38,878
你可以先给它附上一个零

473
00:19:39,880 --> 00:19:41,430
先给他附上一个零

474
00:19:41,430 --> 00:19:43,680
等于没有给他任何有意义的东西

475
00:19:43,680 --> 00:19:44,099
对不对

476
00:19:44,099 --> 00:19:46,579
因为零那个地址你不能做任何事情

477
00:19:46,880 --> 00:19:48,140
但是好处是

478
00:19:48,140 --> 00:19:50,750
如果你不小心对那个地方

479
00:19:50,750 --> 00:19:53,359
对那个没有付过初值

480
00:19:53,359 --> 00:19:55,190
但是付了零值的那个指针

481
00:19:55,190 --> 00:19:56,750
做了任何事情的话

482
00:19:56,750 --> 00:19:58,440
系统一定会崩溃

483
00:19:59,079 --> 00:20:01,920
我们之前在这个指针那部分

484
00:20:01,920 --> 00:20:03,420
我们尝试过这件事情了

485
00:20:03,420 --> 00:20:03,839
对不对

486
00:20:03,839 --> 00:20:07,349
我们给一个指针负了零的初值以运行

487
00:20:07,349 --> 00:20:09,319
它就崩溃了啊

488
00:20:09,319 --> 00:20:10,400
试图往那个地方写东西

489
00:20:10,400 --> 00:20:11,390
他就崩溃了

490
00:20:11,390 --> 00:20:13,299
那么c语言的

491
00:20:13,299 --> 00:20:15,730
除了可以用零来表示地址之外

492
00:20:15,730 --> 00:20:18,789
它预先定义了一个量这个一个符号

493
00:20:18,789 --> 00:20:21,170
这个符号叫做n n u l l

494
00:20:21,170 --> 00:20:22,309
四个字母全部是大写

495
00:20:22,309 --> 00:20:23,420
小写就不管用了啊

496
00:20:23,420 --> 00:20:24,470
必须全部是大写

497
00:20:24,470 --> 00:20:28,240
这个闹呢表示是零地址啊

498
00:20:28,240 --> 00:20:29,079
我建议大家

499
00:20:29,079 --> 00:20:31,940
今后如果需要用零来表示地址的时候

500
00:20:31,940 --> 00:20:32,779
用now这个符号

501
00:20:32,779 --> 00:20:34,460
因为有的编译器他不喜欢

502
00:20:34,460 --> 00:20:35,720
你用零来表示地址

503
00:20:35,720 --> 00:20:40,299
有的编译器里头零和now可能是不相等的啊

504
00:20:40,299 --> 00:20:41,920
这这事牵扯的比较深远

505
00:20:41,920 --> 00:20:43,720
我们不在这儿说太细

506
00:20:43,720 --> 00:20:46,000
我只是提醒大家想要用到零地址

507
00:20:46,000 --> 00:20:47,079
你用now这个符号

508
00:20:47,079 --> 00:20:50,630
而不是用零这个这个这个字面量的值啊

509
00:20:50,630 --> 00:20:53,559
另外我们知道说一个指针

510
00:20:54,299 --> 00:20:55,640
其实它是有各种类型的

511
00:20:55,640 --> 00:20:57,140
我们刚才看了有chart指针

512
00:20:57,140 --> 00:20:58,549
我们看了ink的指针

513
00:20:58,549 --> 00:21:00,079
你可以自己去试一下shot指针

514
00:21:00,079 --> 00:21:01,069
double指针

515
00:21:01,069 --> 00:21:02,878
指针有不同的类型

516
00:21:03,059 --> 00:21:07,079
所以不同类型的指针是不能互相复制的

517
00:21:07,079 --> 00:21:07,559
我们来试一下

518
00:21:07,559 --> 00:21:09,579
这件事情很简单

519
00:21:09,579 --> 00:21:10,180
在我们这儿就有

520
00:21:10,180 --> 00:21:10,660
对不对

521
00:21:10,660 --> 00:21:12,400
我们有新q就是int的指针

522
00:21:12,400 --> 00:21:14,359
如果我们想说q等于p

523
00:21:15,799 --> 00:21:17,170
我们编译一下

524
00:21:17,170 --> 00:21:22,730
他说compatible point of type assign

525
00:21:22,730 --> 00:21:25,599
说这两个指针的这个赋值啊

526
00:21:25,819 --> 00:21:28,430
类型是不匹配的啊

527
00:21:28,430 --> 00:21:29,690
类型是不匹配的

528
00:21:29,690 --> 00:21:32,210
你把一个p的指针交给

529
00:21:32,210 --> 00:21:35,750
要你把一个p的值交给q了

530
00:21:35,750 --> 00:21:38,299
虽然从某种角度上来说

531
00:21:38,299 --> 00:21:39,710
指针都是指针对吧

532
00:21:39,710 --> 00:21:41,809
不管你之前硬抬指向char

533
00:21:41,809 --> 00:21:43,740
指针的大小都是一样的

534
00:21:44,220 --> 00:21:47,759
所以由一个q这个变量来接收

535
00:21:47,759 --> 00:21:50,700
p这个变量的值没有问题

536
00:21:50,799 --> 00:21:52,450
这个值是放得进去的

537
00:21:52,450 --> 00:21:53,259
不像说啊

538
00:21:53,259 --> 00:21:54,759
我要把一个double放到int里头去

539
00:21:54,759 --> 00:21:55,390
放不进去

540
00:21:55,390 --> 00:21:56,079
那会有问题

541
00:21:56,079 --> 00:21:57,190
现在现在没有问题

542
00:21:57,190 --> 00:21:59,579
这个q里头去放屁

543
00:21:59,799 --> 00:22:01,039
这没有问题

544
00:22:01,599 --> 00:22:03,910
可是有问题的是什么

545
00:22:03,910 --> 00:22:06,759
如果这件事情你就这么做了

546
00:22:06,759 --> 00:22:08,109
你就做成了

547
00:22:08,109 --> 00:22:10,180
现在变成什么局面呢

548
00:22:10,539 --> 00:22:13,029
正好就是我们先先前那个图对吧

549
00:22:13,029 --> 00:22:14,859
这个是p的指针

550
00:22:14,859 --> 00:22:15,789
指向的是他

551
00:22:15,789 --> 00:22:19,059
现在呢你让q的指针也指向他了

552
00:22:19,500 --> 00:22:22,460
然后我们知道说新q表示什么

553
00:22:22,819 --> 00:22:24,529
新q是个int对吧

554
00:22:24,529 --> 00:22:27,049
因此如果我们想说新q等于零的话

555
00:22:27,049 --> 00:22:28,299
他要怎么做

556
00:22:28,920 --> 00:22:31,069
一个int要四个字节

557
00:22:31,069 --> 00:22:33,829
它会让这四个字节都变成了零

558
00:22:33,829 --> 00:22:40,390
也就是p0 到p3 通通变成零了

559
00:22:40,390 --> 00:22:42,119
通通变成零了

560
00:22:43,180 --> 00:22:45,509
这显然是不对的对吧

561
00:22:45,509 --> 00:22:49,259
所以指向不同类型的指针不能直接复制啊

562
00:22:49,259 --> 00:22:51,480
这主要就是为了避免你用错指针

563
00:22:51,700 --> 00:22:55,690
但是呢如果你想你可以做强制类型转换

564
00:22:55,690 --> 00:22:59,619
强制把指向这个类型的指针指向那个类型

565
00:22:59,619 --> 00:23:01,089
当然作为初学者

566
00:23:01,089 --> 00:23:03,460
我劝你不要轻易尝试这个事情

567
00:23:04,500 --> 00:23:06,740
在有了一定的经验之后

568
00:23:06,740 --> 00:23:08,599
你会发现在某些情况下

569
00:23:08,599 --> 00:23:10,160
你也许不得不做这个事情

570
00:23:10,160 --> 00:23:11,690
但是在初学的时候

571
00:23:11,690 --> 00:23:13,460
这个事情没有任何意义啊

572
00:23:13,579 --> 00:23:15,140
呃我们把它放在这儿讲

573
00:23:15,140 --> 00:23:16,700
是因为我们希望带进来

574
00:23:16,700 --> 00:23:17,839
另外一种特殊的东西

575
00:23:17,839 --> 00:23:19,279
就是void的心

576
00:23:19,740 --> 00:23:22,650
void的这个这个单词我们之前遇到过

577
00:23:22,650 --> 00:23:25,200
如果说一个函数它不返回任何结果

578
00:23:25,200 --> 00:23:27,480
我们会说这个函数的返回类型是void

579
00:23:27,480 --> 00:23:28,878
void表示没有

580
00:23:28,880 --> 00:23:30,019
他没有返回值

581
00:23:30,019 --> 00:23:30,380
对不对

582
00:23:30,380 --> 00:23:31,549
没有返回结果

583
00:23:31,549 --> 00:23:33,619
那void的心是什么意思呢

584
00:23:33,619 --> 00:23:35,670
是说这是一个指针啊

585
00:23:35,670 --> 00:23:36,569
这这这没有错

586
00:23:36,569 --> 00:23:37,410
是个指针

587
00:23:37,410 --> 00:23:38,309
可是呢

588
00:23:38,309 --> 00:23:41,460
我不确定这个指针指向它到底是什么

589
00:23:41,599 --> 00:23:46,299
所以呢我就先说它指向的是void啊

590
00:23:46,299 --> 00:23:47,559
我先说它质量是void

591
00:23:47,559 --> 00:23:49,960
它指向了那么一块空间

592
00:23:49,960 --> 00:23:53,859
这块内存空间里头究竟是int还是double

593
00:23:53,859 --> 00:23:55,390
还是chara还是short

594
00:23:55,390 --> 00:23:56,859
我不知道

595
00:23:56,859 --> 00:23:58,420
我也不关心

596
00:23:58,420 --> 00:24:00,970
我只是说它指向那块内存空间

597
00:24:00,970 --> 00:24:04,390
所以我们用void的新的指针来表达

598
00:24:04,390 --> 00:24:08,240
说我现在呢有一个内存地址啊

599
00:24:08,240 --> 00:24:09,799
在内存里头有一块地方啊

600
00:24:09,799 --> 00:24:11,779
我用这个指针来表达它

601
00:24:11,779 --> 00:24:15,809
这个往往会用在底层程序系统程序里头

602
00:24:15,809 --> 00:24:18,269
我要直接去访问某个内存地址

603
00:24:18,269 --> 00:24:20,130
我要直接去访问某个内存地址

604
00:24:20,130 --> 00:24:21,409
所代表的一些

605
00:24:21,409 --> 00:24:23,028
比如说外部设备啊

606
00:24:23,028 --> 00:24:24,648
控制寄存器啊等等

607
00:24:24,648 --> 00:24:27,079
这个时候呢我们会需要用到这样的类型

608
00:24:27,660 --> 00:24:29,240
当我们去做类型转换

609
00:24:29,240 --> 00:24:30,680
对指针类型去做类型转换

610
00:24:30,680 --> 00:24:32,119
比如说我们在这儿写的

611
00:24:32,119 --> 00:24:35,859
说你看这个in的新p呢是i的地址

612
00:24:35,859 --> 00:24:36,579
然后呢

613
00:24:36,579 --> 00:24:39,640
我们把这个p呢强制转换成void的心

614
00:24:39,640 --> 00:24:41,420
交给了一个void的新q

615
00:24:41,420 --> 00:24:42,890
那这句话的意思呢

616
00:24:42,890 --> 00:24:45,829
并没有去改变p所指的变量的类型

617
00:24:45,829 --> 00:24:47,920
i还是int啊

618
00:24:47,920 --> 00:24:48,700
p是指向i的

619
00:24:48,700 --> 00:24:49,359
i还是in的

620
00:24:49,359 --> 00:24:50,049
这没有变

621
00:24:50,049 --> 00:24:54,509
只不过是说我们通过q去看这个i

622
00:24:54,509 --> 00:24:55,769
q现在也只想i了

623
00:24:55,769 --> 00:24:56,338
对不对

624
00:24:56,338 --> 00:24:58,318
我们通过q去看i的时候呢

625
00:24:58,318 --> 00:24:59,759
我们眼光变了

626
00:25:00,079 --> 00:25:01,339
通过peach看i

627
00:25:01,339 --> 00:25:03,440
我们觉得i是个int

628
00:25:03,440 --> 00:25:05,180
通过q去看i的意思呢

629
00:25:05,180 --> 00:25:08,980
就是说我现在啊不拿你当int了

630
00:25:08,980 --> 00:25:10,839
我拿你当void了

631
00:25:11,119 --> 00:25:13,220
我当你什么都不是了

632
00:25:16,140 --> 00:25:18,450
我们可以稍微总结一下

633
00:25:18,450 --> 00:25:19,680
我们之前看到过

634
00:25:19,680 --> 00:25:21,329
我们用指针来做什么呢

635
00:25:21,329 --> 00:25:24,210
我们需要传入比较大的数据的时候

636
00:25:24,210 --> 00:25:26,670
我们用指针做参数的类型

637
00:25:26,670 --> 00:25:28,159
比如说我们要传数组

638
00:25:28,160 --> 00:25:30,019
我们传入数组以后呢

639
00:25:30,019 --> 00:25:32,539
我们可以用指针对那个数组做操作

640
00:25:33,079 --> 00:25:35,420
当我们函数返回不止一个结果的时候

641
00:25:35,420 --> 00:25:37,250
我们可以用指针做参数

642
00:25:37,250 --> 00:25:39,299
让它带出结果

643
00:25:40,839 --> 00:25:42,660
当我们需要用函数来修改

644
00:25:42,660 --> 00:25:43,680
不止一个变量的时候

645
00:25:43,680 --> 00:25:44,670
比如说swap

646
00:25:44,670 --> 00:25:46,799
我们可以用传指针进去

647
00:25:46,799 --> 00:25:49,500
让函数里头帮我们修改变量的值

648
00:25:49,740 --> 00:25:54,500
还有当我们需要动态申请内存的时候

