1
00:00:04,259 --> 00:00:07,139
我们前面在讲这个浮点数的呃范围的时候

2
00:00:07,139 --> 00:00:09,630
经提到过超过范围的浮点数

3
00:00:09,630 --> 00:00:13,409
我们有i n f来表示它是无穷大的

4
00:00:13,409 --> 00:00:15,989
我们有n a n来表示它是不存在的

5
00:00:15,989 --> 00:00:18,599
我们怎么怎么怎么会看到这些东西呢

6
00:00:23,120 --> 00:00:24,440
我们已经看到过这个结果了

7
00:00:24,440 --> 00:00:24,890
对不对

8
00:00:24,890 --> 00:00:27,260
我们在做那个前n项和的时候

9
00:00:27,260 --> 00:00:28,480
已经看到过

10
00:00:30,899 --> 00:00:31,890
它就会越界

11
00:00:31,890 --> 00:00:33,420
会看到那个i n f

12
00:00:33,420 --> 00:00:34,560
我们再来试试看怎么样

13
00:00:34,560 --> 00:00:36,539
我们能够得到i f和n a n

14
00:00:36,539 --> 00:00:39,780
我们知道一个数如果去除以零

15
00:00:39,780 --> 00:00:41,329
也就是说除数是零的话

16
00:00:41,329 --> 00:00:42,289
它就是无穷大

17
00:00:42,289 --> 00:00:42,770
对不对

18
00:00:42,770 --> 00:00:44,090
那么正数除以零

19
00:00:44,090 --> 00:00:44,869
负数除以零

20
00:00:44,869 --> 00:00:46,670
还有0÷0会有什么样的结果呢

21
00:00:46,670 --> 00:00:47,820
我们来试一下

22
00:00:49,119 --> 00:00:51,060
正数除以零就是正无穷大

23
00:00:51,060 --> 00:00:52,649
负数除以零就是负无穷大

24
00:00:52,649 --> 00:00:57,560
而0÷0就是一个不存在的数字啊

25
00:00:57,560 --> 00:00:58,878
就是一个不存在的数

26
00:01:00,100 --> 00:01:01,859
我们还可以试一下

27
00:01:01,859 --> 00:01:04,319
如果说这不是浮点数

28
00:01:04,319 --> 00:01:07,200
而是比如说我们这是一个整数

29
00:01:07,200 --> 00:01:11,219
说12÷0会有什么样的结果呢

30
00:01:11,560 --> 00:01:13,269
事实上如果这样的话

31
00:01:13,269 --> 00:01:17,700
编译就会通不过他说除以零是没有定义的

32
00:01:18,459 --> 00:01:19,859
整数不能除以零

33
00:01:19,859 --> 00:01:22,719
因为无穷大无法用整数来表达

34
00:01:22,719 --> 00:01:24,819
但是无穷大可以用浮点来表达

35
00:01:28,239 --> 00:01:30,430
但是呢在浮点数的设计里头

36
00:01:30,430 --> 00:01:31,560
他把无穷大

37
00:01:31,560 --> 00:01:32,519
正负无穷大

38
00:01:32,519 --> 00:01:35,760
还有不存在的数作为两三种特殊的值

39
00:01:35,760 --> 00:01:37,728
定义在浮点数的这个数字里头了

40
00:01:37,728 --> 00:01:42,420
但是浮点的运算呢是没有精度的啊

41
00:01:42,420 --> 00:01:42,900
是没有进度

42
00:01:42,900 --> 00:01:44,040
我们可以来试一下这个代码

43
00:01:44,040 --> 00:01:46,319
我们要做的事情是1.345

44
00:01:46,319 --> 00:01:47,400
加1.123

45
00:01:47,400 --> 00:01:49,620
我们知道这个应该等于2.468

46
00:01:49,620 --> 00:01:50,159
对不对

47
00:01:50,159 --> 00:01:51,959
应该等于2.468

48
00:01:52,219 --> 00:01:54,590
但是实际结果会不会是这样子

49
00:01:54,590 --> 00:01:56,000
我们让c等于a加b

50
00:01:56,000 --> 00:01:59,090
所以如果c和这个2.468是相等的

51
00:01:59,090 --> 00:01:59,930
它会输出相等

52
00:01:59,930 --> 00:02:00,799
不相等的时候

53
00:02:00,799 --> 00:02:02,090
他会告诉我们说

54
00:02:02,090 --> 00:02:06,780
这个c如果我们把它值输出出来

55
00:02:06,780 --> 00:02:07,980
看它会是多少

56
00:02:07,980 --> 00:02:09,060
我们来试一下这个代码

57
00:02:09,060 --> 00:02:11,498
它告诉我们说不相等啊

58
00:02:11,498 --> 00:02:12,308
不相等

59
00:02:12,308 --> 00:02:18,509
他说呢这个c呢如果做十位看的话

60
00:02:18,509 --> 00:02:20,580
它是2.4679

61
00:02:21,459 --> 00:02:23,128
如果不考虑是v的话

62
00:02:23,128 --> 00:02:24,639
它是2.468

63
00:02:25,580 --> 00:02:27,039
哪个是对的呢

64
00:02:27,039 --> 00:02:28,340
这个是对的

65
00:02:28,939 --> 00:02:32,780
这是在一定位数上做了四舍五入的结果

66
00:02:32,780 --> 00:02:33,979
它是2.468

67
00:02:33,979 --> 00:02:37,800
但是你把它的比较多的位数都打出来的话

68
00:02:37,800 --> 00:02:38,819
因为这是float类型

69
00:02:38,819 --> 00:02:41,039
我们知道float只有七位有效数字

70
00:02:41,039 --> 00:02:43,199
我们把它的小数点后面十位都打出来

71
00:02:43,199 --> 00:02:44,659
我们总共有11位了

72
00:02:44,659 --> 00:02:46,400
其实它只有七位是有效的

73
00:02:46,400 --> 00:02:49,580
所以我们看一下1234567

74
00:02:49,580 --> 00:02:51,930
大概到这这些是有效的

75
00:02:51,930 --> 00:02:53,639
这些如果四舍五入

76
00:02:53,639 --> 00:02:55,219
当然它就是468

77
00:02:55,338 --> 00:02:57,438
但是他实际上在内部不是468

78
00:02:57,438 --> 00:02:59,479
所以我们要去判断它是不是468的时候

79
00:02:59,479 --> 00:03:00,019
他告诉我

80
00:03:00,019 --> 00:03:01,008
他是不想等

81
00:03:01,008 --> 00:03:02,479
我们还要知道一个小细节

82
00:03:02,479 --> 00:03:05,810
是我们为什么这里要带f

83
00:03:05,810 --> 00:03:08,419
因为如果带着小数点的那个自变量

84
00:03:08,419 --> 00:03:10,430
比如说1.345不带f

85
00:03:10,430 --> 00:03:11,449
它是double

86
00:03:11,449 --> 00:03:12,740
而不是float

87
00:03:12,838 --> 00:03:14,248
你希望它是float

88
00:03:14,248 --> 00:03:16,199
你就需要给它后面加上f

89
00:03:16,199 --> 00:03:18,960
小f和大f来表明它是一个float

90
00:03:18,960 --> 00:03:20,189
这是第一件事情

91
00:03:20,189 --> 00:03:22,800
第二件事情我们就知道说两个浮点数

92
00:03:22,800 --> 00:03:24,060
如果你直接用两个等号

93
00:03:24,060 --> 00:03:25,439
来判断它们是否相等

94
00:03:25,439 --> 00:03:26,860
它是可能失败的

95
00:03:26,979 --> 00:03:30,520
所以我们应该用的方法是这样

96
00:03:30,520 --> 00:03:33,479
我们去求这两个浮点数之间的差

97
00:03:33,479 --> 00:03:35,280
这个差求求出来以后呢

98
00:03:35,280 --> 00:03:36,300
它可能正可能负

99
00:03:36,300 --> 00:03:39,939
所以我们用f a b s去求它的绝对值

100
00:03:40,039 --> 00:03:41,180
得到绝对值以后

101
00:03:41,180 --> 00:03:42,620
我们看这个绝对值是不是

102
00:03:42,620 --> 00:03:43,990
小于一个很小的数

103
00:03:43,990 --> 00:03:45,610
通常这个数多小呢

104
00:03:45,610 --> 00:03:48,669
只要比你的那个能够表达的精度来的小

105
00:03:48,669 --> 00:03:48,909
就可以

106
00:03:48,909 --> 00:03:51,129
比如说对于flower来说

107
00:03:51,129 --> 00:03:52,270
七个有效数字

108
00:03:52,270 --> 00:03:54,729
那我们小于一一-8大概就可以了

109
00:03:54,729 --> 00:03:56,449
1x10的-8次方啊

110
00:03:56,449 --> 00:03:57,229
那更保险一点

111
00:03:57,229 --> 00:03:58,308
1x10的-12次方

112
00:03:58,308 --> 00:03:59,868
那个把精度约的更小一点

113
00:03:59,868 --> 00:04:00,919
但其实没有必要了

114
00:04:00,919 --> 00:04:02,479
一一-8大概就够了

115
00:04:02,479 --> 00:04:06,979
以这种方式来判断它是否是相等的啊

116
00:04:07,280 --> 00:04:10,128
呃计算机里头的浮点数

117
00:04:10,128 --> 00:04:11,778
是存在这样的问题的

118
00:04:11,778 --> 00:04:14,508
它只有一定范围内的有效数字

119
00:04:14,508 --> 00:04:17,569
那么你在做某些运算的时候

120
00:04:17,569 --> 00:04:20,499
你就不能用浮点数来呃

121
00:04:20,499 --> 00:04:21,699
做一些精确的计算

122
00:04:21,699 --> 00:04:24,369
比方说当你要写程序去算钱的时候

123
00:04:24,369 --> 00:04:26,259
你不能用浮点数来表达

124
00:04:26,259 --> 00:04:28,720
说这是一块两毛三

125
00:04:31,660 --> 00:04:33,279
用浮点数来表达的话

126
00:04:33,899 --> 00:04:36,259
它的这个误差最后会累积起来的

127
00:04:37,339 --> 00:04:39,769
所以我我们在算这些钱的时候

128
00:04:39,769 --> 00:04:41,449
其实我们简单的方法是说

129
00:04:41,449 --> 00:04:42,829
我们可以用分做单位

130
00:04:44,918 --> 00:04:46,538
然后用整数去做运算

131
00:04:46,538 --> 00:04:48,319
整数永远是精确的

132
00:04:48,680 --> 00:04:50,870
带小数点的数它是不准确的

133
00:04:50,870 --> 00:04:53,500
你只能在一定的范围内去相信它

134
00:04:54,220 --> 00:04:55,920
那还有另外一种方案

135
00:04:55,920 --> 00:04:57,660
就是在做这些运算的时候

136
00:04:57,660 --> 00:04:58,800
如果你要算得准确

137
00:04:58,800 --> 00:05:01,468
就用我们第二周的题目当中

138
00:05:01,468 --> 00:05:03,629
用到的那种b c d的数来做计算

139
00:05:03,629 --> 00:05:07,579
我们的计算器传统上其实它是四位的

140
00:05:07,579 --> 00:05:09,560
因为你想我们计算器要做的是

141
00:05:09,560 --> 00:05:10,500
十进制的运算

142
00:05:10,500 --> 00:05:12,449
每一个十进制的这个数

143
00:05:12,449 --> 00:05:15,060
用一个用b c d数来表达是最恰当的

144
00:05:15,060 --> 00:05:17,250
所以传统的计算器里面

145
00:05:17,250 --> 00:05:18,899
其实都是b c d运算

146
00:05:19,038 --> 00:05:21,649
顺便给大家推荐网上的一篇文章

147
00:05:21,649 --> 00:05:23,449
这篇文章就介绍说

148
00:05:23,449 --> 00:05:27,480
安卓在某一个这个版本上面的

149
00:05:27,480 --> 00:05:30,610
某一个这个计算器的版本啊

150
00:05:30,610 --> 00:05:32,779
是有计算误差的

151
00:05:32,779 --> 00:05:33,889
原因很简单

152
00:05:33,889 --> 00:05:35,540
当时做那个计算器的人

153
00:05:35,540 --> 00:05:37,730
直接用了浮点数来做运算

154
00:05:37,730 --> 00:05:39,470
而传统做计算器的人

155
00:05:39,470 --> 00:05:41,779
是完全不会用浮点数去做运算的

156
00:05:41,779 --> 00:05:45,019
完全是用整数的方式去做运算的

157
00:05:45,019 --> 00:05:45,980
我们再来说一下

158
00:05:45,980 --> 00:05:48,079
这个浮点数内部是怎么表达的啊

159
00:05:48,079 --> 00:05:50,699
呃和整数内部的表达方式不一样

160
00:05:50,699 --> 00:05:53,370
整数内部呢是二进制

161
00:05:53,370 --> 00:05:54,860
纯二进制数

162
00:05:55,540 --> 00:05:58,500
所以整数两个整数可以直接做运算

163
00:05:58,500 --> 00:05:59,279
可以直接做甲

164
00:05:59,279 --> 00:06:00,449
可以做直接做减

165
00:06:00,449 --> 00:06:03,720
但是浮点数的内部呢是一种编码形式

166
00:06:03,720 --> 00:06:07,069
它的一个比特用来表达这是正数还是负数

167
00:06:07,069 --> 00:06:08,600
然后这里的11个比特

168
00:06:08,600 --> 00:06:11,709
用来表达他的指数部分是多少

169
00:06:11,709 --> 00:06:13,449
后面还有一些比特

170
00:06:13,449 --> 00:06:15,970
用来表达它的分数部分是多少

171
00:06:15,970 --> 00:06:17,769
当然这张图上说有52个比特

172
00:06:17,769 --> 00:06:20,740
其实不一定是这样子啊

173
00:06:20,740 --> 00:06:21,879
我们的double和float

174
00:06:21,879 --> 00:06:23,649
虽然我们说float 32个比特

175
00:06:23,649 --> 00:06:24,699
double 64个比特

176
00:06:24,699 --> 00:06:27,920
他其实并没有把所有的位数都用完啊

177
00:06:27,920 --> 00:06:29,060
没有把所有的位数都难

178
00:06:29,060 --> 00:06:29,779
但是可以可以

179
00:06:29,779 --> 00:06:31,790
大概可以这样去表达这件事情

180
00:06:31,790 --> 00:06:33,538
也就是说在浮点数内部

181
00:06:33,538 --> 00:06:35,879
它不是一个真正的二进制数

182
00:06:35,879 --> 00:06:37,769
它是一个编码的形式

183
00:06:37,769 --> 00:06:39,089
然后在计算的时候呢

184
00:06:39,089 --> 00:06:42,750
现在我们的cpu都是带着专门的浮点

185
00:06:42,750 --> 00:06:43,839
计算的硬件的

186
00:06:43,839 --> 00:06:45,160
所以在计算的时候

187
00:06:45,160 --> 00:06:47,620
实际上是会把这个编码的数

188
00:06:47,620 --> 00:06:49,180
交给那个专门计算的硬件

189
00:06:49,180 --> 00:06:52,189
那个硬件呢会把这个数去解开来

190
00:06:52,189 --> 00:06:54,019
然后去做计算

191
00:06:54,019 --> 00:06:57,259
算完以后再编码编程这样的数字再给你

192
00:06:57,259 --> 00:06:59,360
而在这个计算的硬件当中呢

193
00:06:59,360 --> 00:07:02,939
计算double和计算float所用的方法

194
00:07:02,939 --> 00:07:05,040
所用的硬件部件是一样的

195
00:07:06,660 --> 00:07:08,360
所以跟整数一样

196
00:07:08,360 --> 00:07:09,139
我们有那么多整数

197
00:07:09,139 --> 00:07:10,120
我们怎么选择

198
00:07:10,120 --> 00:07:11,379
但是我告诉大家

199
00:07:11,379 --> 00:07:12,430
原则很简单

200
00:07:12,430 --> 00:07:14,060
没有特殊需要用int

201
00:07:14,060 --> 00:07:15,290
我们有两个浮点

202
00:07:15,290 --> 00:07:16,819
事实上我们还有long double啊

203
00:07:16,819 --> 00:07:19,279
我们没有在这个内容当中展开去讲

204
00:07:19,279 --> 00:07:19,939
long double

205
00:07:19,939 --> 00:07:22,160
我们还有128个比特的long double

206
00:07:22,180 --> 00:07:24,279
我们怎么选择浮点类型

207
00:07:24,279 --> 00:07:27,129
跟我在整数的时候跟大家说的观点一样

208
00:07:27,129 --> 00:07:28,509
没有特殊需要

209
00:07:28,509 --> 00:07:29,829
你只用double

210
00:07:29,829 --> 00:07:33,310
因为现在的cpu能够对double直接做硬件运算

211
00:07:33,310 --> 00:07:35,500
它的性能不会比float差

212
00:07:35,560 --> 00:07:37,420
而且在64位的机器上

213
00:07:38,439 --> 00:07:39,040
一个fo

214
00:07:39,040 --> 00:07:42,389
一个double直接就是一次的内存存储就过来了

215
00:07:42,389 --> 00:07:44,459
它也不会比float来得慢

216
00:07:44,459 --> 00:07:46,850
所以现在没有特别的需要

217
00:07:46,850 --> 00:07:48,350
你没有必要去用float

218
00:07:48,350 --> 00:07:49,560
直接用double就好了

