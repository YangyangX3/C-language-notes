1
00:00:04,740 --> 00:00:06,839
虽然我们有很多种不同的整数

2
00:00:06,839 --> 00:00:08,409
我们有chat short

3
00:00:08,409 --> 00:00:09,968
int long long long

4
00:00:09,968 --> 00:00:13,269
但是呢在做print f和cf输入输出的时候

5
00:00:13,269 --> 00:00:15,728
其实我们只有两种int或者long long

6
00:00:15,728 --> 00:00:16,989
也就是说呃

7
00:00:16,989 --> 00:00:19,280
所有小于int的char

8
00:00:19,559 --> 00:00:23,399
shot和int都采用相同的方式来做输出

9
00:00:23,399 --> 00:00:25,010
就是百分号d啊

10
00:00:25,010 --> 00:00:28,070
就是百分号d所有比int要来的大的

11
00:00:28,070 --> 00:00:31,489
那么我们需要用百分号l d来表明

12
00:00:31,489 --> 00:00:33,168
那个l表明在中间啊

13
00:00:33,168 --> 00:00:34,249
这个东西是一个long

14
00:00:34,249 --> 00:00:35,298
而如果是on side

15
00:00:35,298 --> 00:00:37,128
你可以用百分号u来输出

16
00:00:37,128 --> 00:00:41,049
顺便这个事情又一次可以让我们体会到

17
00:00:41,049 --> 00:00:41,770
什么叫做

18
00:00:41,770 --> 00:00:44,338
不管你在计算机内部是什么数

19
00:00:44,340 --> 00:00:46,859
重点是我们以什么方式来看它

20
00:00:46,859 --> 00:00:48,299
我们来试一下这件事情

21
00:00:48,299 --> 00:00:51,210
现在呢我们让两个变量的值都等于-1

22
00:00:51,210 --> 00:00:52,289
他们等于-1呢

23
00:00:52,289 --> 00:00:53,700
呃因为它们都不是on s的

24
00:00:53,700 --> 00:00:55,229
所以他当然可以等于-1

25
00:00:55,229 --> 00:00:57,329
然后呢我们让它输出成2%u

26
00:00:57,329 --> 00:01:00,859
也就是说我们希望他们被当做on上来输出

27
00:01:00,859 --> 00:01:04,370
我们看到他们的输出结果是非常大的

28
00:01:04,370 --> 00:01:05,239
两个数

29
00:01:05,859 --> 00:01:07,560
而且这两个数是一样的

30
00:01:07,560 --> 00:01:08,700
这两个数是什么呢

31
00:01:08,700 --> 00:01:12,420
是unsigned int所能够表达的最大的数

32
00:01:12,599 --> 00:01:14,640
因为-1就表示全一嘛

33
00:01:14,640 --> 00:01:15,239
对不对

34
00:01:15,239 --> 00:01:16,260
全部都是一嘛

35
00:01:16,260 --> 00:01:19,659
那为什么这个这不是一个字节吗

36
00:01:19,659 --> 00:01:21,159
不是只有最低位为一吗

37
00:01:21,159 --> 00:01:24,969
可是当我们把所有小于int的变量传给print

38
00:01:24,969 --> 00:01:25,689
f的时候

39
00:01:25,689 --> 00:01:29,069
我们的编译器会把这些变量转换为int

40
00:01:29,069 --> 00:01:29,849
传进去

41
00:01:29,849 --> 00:01:31,290
所以当他在转换的过程当中

42
00:01:31,290 --> 00:01:34,000
因为这是有符号的

43
00:01:34,000 --> 00:01:35,200
所以传进去的时候

44
00:01:35,200 --> 00:01:37,989
当然这个东西也被扩展到所有的位都是一

45
00:01:37,989 --> 00:01:39,478
所有的位都是一的话

46
00:01:39,478 --> 00:01:42,688
最后作为outside的结果就是这个结果

47
00:01:42,688 --> 00:01:45,299
所以我们在计算机内部

48
00:01:45,299 --> 00:01:46,890
还是只有那么一个东西

49
00:01:46,890 --> 00:01:48,269
可是你把它当做这个看

50
00:01:48,269 --> 00:01:49,200
把它当做那个看

51
00:01:49,200 --> 00:01:50,609
以不同的方式去看待它

52
00:01:50,609 --> 00:01:52,920
它就会给你看到不同的结果

53
00:01:54,280 --> 00:01:57,609
这和他在计算机内部是什么没有关系

54
00:01:57,609 --> 00:02:01,689
取决于你是是不是以正确的方式来用它

55
00:02:01,689 --> 00:02:04,689
以正确的方式把它格式化成人

56
00:02:04,689 --> 00:02:06,159
能够读懂的东西来看

57
00:02:06,239 --> 00:02:08,520
顺便说我们在c语言里头

58
00:02:08,520 --> 00:02:11,019
我们还会遇到八进制和16进制

59
00:02:11,019 --> 00:02:14,520
如果有一个数字的字面量是以零开头的

60
00:02:14,520 --> 00:02:15,719
它就是八进制

61
00:02:15,719 --> 00:02:18,659
如果一个数字的字面量0x开头

62
00:02:18,659 --> 00:02:19,469
他就是16进制

63
00:02:19,469 --> 00:02:20,870
我们可以试一下这件事情

64
00:02:20,870 --> 00:02:24,039
如果我们的这个x等于012

65
00:02:24,800 --> 00:02:27,340
我们的这个i等于0x12 

66
00:02:27,340 --> 00:02:31,189
然后我们来看一下这两个数字是多少

67
00:02:31,189 --> 00:02:33,139
当我们以百分号d输出的时候

68
00:02:33,139 --> 00:02:33,860
我们表示说

69
00:02:33,860 --> 00:02:36,770
我们希望它给我们看到十进制的结果

70
00:02:36,770 --> 00:02:40,490
而我们在写在程序当中的字面量的时候

71
00:02:40,490 --> 00:02:43,750
我们可以八进制或者16进制来看待他们

72
00:02:43,750 --> 00:02:47,409
于是我们得到说012对于八进制的

73
00:02:47,409 --> 00:02:49,719
012对于十进制来说就是十

74
00:02:49,719 --> 00:02:53,210
而0x12 作为16进制的幺二

75
00:02:53,210 --> 00:02:55,800
那么它的十进制对应的就是18

76
00:02:55,800 --> 00:02:57,240
如何换算八进制和十

77
00:02:57,240 --> 00:02:59,280
六进制和十进制之间的关系

78
00:02:59,280 --> 00:03:00,639
这不是我们的重点

79
00:03:00,639 --> 00:03:03,959
大家其实根本不需要去学那个呃

80
00:03:03,959 --> 00:03:05,459
算换算的那个方案啊

81
00:03:05,459 --> 00:03:07,318
你们的计算器我们之前都演示过

82
00:03:07,318 --> 00:03:07,679
计算器

83
00:03:07,679 --> 00:03:09,179
就可以帮你去换算

84
00:03:09,179 --> 00:03:11,360
这些不同的净值之间的关系

85
00:03:11,360 --> 00:03:15,449
但是同样的事情是这个禁制

86
00:03:15,449 --> 00:03:17,699
只是我们怎么去看

87
00:03:17,699 --> 00:03:18,159
它

88
00:03:18,159 --> 00:03:20,409
并不表示在计算机内部

89
00:03:20,409 --> 00:03:23,289
它会被表达为八进制或者16进制

90
00:03:23,289 --> 00:03:25,139
计算机内部永远只有二进制

91
00:03:25,139 --> 00:03:26,879
你在程序里面写了一个八进制

92
00:03:26,879 --> 00:03:30,240
编译器会替你转成对应的是进制的形式

93
00:03:30,240 --> 00:03:34,340
去变成二进制去交给计算机里头的东西

94
00:03:34,539 --> 00:03:36,159
同样的16进制也是这样

95
00:03:36,159 --> 00:03:37,840
我们用百分号d来输出的时候

96
00:03:37,840 --> 00:03:38,439
就表示说

97
00:03:38,439 --> 00:03:41,490
我们要输出的是一个十进制的东西

98
00:03:41,490 --> 00:03:43,530
所以如果我们想要输出八进制的东西

99
00:03:43,530 --> 00:03:44,650
我们要用百分号o

100
00:03:44,650 --> 00:03:46,509
想要输出16进制的东西

101
00:03:46,509 --> 00:03:47,949
我们要百分号x

102
00:03:47,949 --> 00:03:50,169
所以这样子我们就会得到说

103
00:03:50,169 --> 00:03:52,110
那个c呢是幺二

104
00:03:52,110 --> 00:03:53,400
i也是幺二

105
00:03:53,400 --> 00:03:57,210
但是注意它不会在前面有一个零加在那里

106
00:03:57,210 --> 00:03:59,069
如果你想要在前面加零怎么办

107
00:03:59,069 --> 00:04:00,050
自己加上一个好

108
00:04:00,050 --> 00:04:01,490
想要在前面有0x吗

109
00:04:01,490 --> 00:04:02,449
自己想想一个好了

110
00:04:02,449 --> 00:04:04,430
于是我们会得到说c等于零二

111
00:04:04,430 --> 00:04:06,110
i等于0x12 

112
00:04:06,110 --> 00:04:09,800
当然我们如果这个地方它是带的字母的

113
00:04:09,800 --> 00:04:13,838
那零小写的x会让他输出小写的a

114
00:04:13,838 --> 00:04:15,218
你如果有大写的

115
00:04:15,218 --> 00:04:19,480
大写的x会让他输出大写的a就是这样子

116
00:04:19,699 --> 00:04:21,529
八进制和16进制指示

117
00:04:21,529 --> 00:04:23,389
如何把数字表达为字符串

118
00:04:23,389 --> 00:04:25,449
这和内部如何表达数字无关

119
00:04:25,449 --> 00:04:27,189
不仅在print ef可以用skin f

120
00:04:27,189 --> 00:04:28,209
也可以用skin f

121
00:04:28,209 --> 00:04:29,620
如果用2%o表示说

122
00:04:29,620 --> 00:04:31,149
我们要读进来的那个数

123
00:04:31,149 --> 00:04:34,240
我们是当做八进制来读的

124
00:04:35,259 --> 00:04:36,478
我们读到了幺二

125
00:04:36,478 --> 00:04:39,838
我们要当做八进制来把它解释为十进制的

126
00:04:39,838 --> 00:04:41,428
实际上的什么样的数啊

127
00:04:41,428 --> 00:04:45,259
呃16进制呢它很适合表达二进制的数据

128
00:04:45,259 --> 00:04:47,000
因为四位的16啊

129
00:04:47,000 --> 00:04:49,339
四位的二进制呢正好是一个16进制的v

130
00:04:49,339 --> 00:04:50,089
为什么呢

131
00:04:50,089 --> 00:04:52,519
因为16是二的四次方嘛

132
00:04:53,660 --> 00:04:56,279
所以如果我们有一个二进制的数

133
00:04:56,279 --> 00:04:58,889
00010010

134
00:04:58,889 --> 00:05:01,860
那这四个比特表达为16进制是一

135
00:05:01,860 --> 00:05:04,230
这四个比特比特表达为16进制是二

136
00:05:04,230 --> 00:05:07,189
所以一二就可以表达这样一个二进制的数

137
00:05:07,189 --> 00:05:09,620
我们正好就是16进制的两位

138
00:05:09,620 --> 00:05:12,050
可以表达的是一个char

139
00:05:12,050 --> 00:05:13,060
是一个字节

140
00:05:13,060 --> 00:05:14,439
所以传统上面

141
00:05:14,439 --> 00:05:16,959
程序员会很喜欢用16进制来表达二进制

142
00:05:16,959 --> 00:05:20,319
因为这个中间的这个呃变换呢

143
00:05:20,319 --> 00:05:21,699
会非常容易去做

144
00:05:21,839 --> 00:05:24,360
而八进制的一位数字呢

145
00:05:24,360 --> 00:05:26,459
它表达的是三位二进制数对吧

146
00:05:26,459 --> 00:05:28,259
因为二的三次方等于八

147
00:05:28,259 --> 00:05:29,519
之所以会有这样的事情

148
00:05:29,519 --> 00:05:32,158
是因为早期的计算机的时候

149
00:05:33,059 --> 00:05:34,619
我们计算机呢是32位的

150
00:05:34,619 --> 00:05:35,639
或者64位的啊

151
00:05:35,639 --> 00:05:37,389
如果有的同学做单片机的话

152
00:05:37,389 --> 00:05:38,110
可能会知道啊

153
00:05:38,110 --> 00:05:39,610
单片机呢可能有八位的

154
00:05:39,610 --> 00:05:40,389
有16位的

155
00:05:40,389 --> 00:05:41,519
也有32位的

156
00:05:41,519 --> 00:05:43,019
但是早期的计算机

157
00:05:43,019 --> 00:05:44,819
我们说早期的时候是60年代

158
00:05:44,819 --> 00:05:46,029
70年代的时候

159
00:05:46,029 --> 00:05:47,829
计算机的字长是12的倍数

160
00:05:47,829 --> 00:05:49,610
比如说12呃

161
00:05:49,610 --> 00:05:51,920
一个一个一个字长是12的啊

162
00:05:51,920 --> 00:05:53,360
或者一个字长是24位啊

163
00:05:53,360 --> 00:05:54,259
12为24位

164
00:05:54,259 --> 00:05:55,759
那么12位24位的时候呢

165
00:05:55,759 --> 00:05:59,819
用八进制来表达他的一个字是最方便的

166
00:05:59,819 --> 00:06:01,899
比用16进制方便对吧

167
00:06:02,139 --> 00:06:04,180
所以呢在那个时候呢

