1
00:00:04,419 --> 00:00:07,240
我们在第一周就见识过这个家伙了

2
00:00:07,240 --> 00:00:09,310
我们在讲到caf的时候

3
00:00:09,310 --> 00:00:10,460
当时我们说

4
00:00:10,779 --> 00:00:14,050
你在那个scaf里面一定要有一个什么

5
00:00:14,050 --> 00:00:15,648
一定要有那个and符号

6
00:00:15,648 --> 00:00:17,809
如果变量前面不加n的符号

7
00:00:17,809 --> 00:00:19,129
你的程序会出错

8
00:00:19,129 --> 00:00:21,469
很多同学在讨论区里面就提到了

9
00:00:21,469 --> 00:00:22,609
没有加那个n的符号

10
00:00:22,609 --> 00:00:25,048
结果一运行程序崩溃了

11
00:00:25,048 --> 00:00:26,939
segmentation fault等等之类的

12
00:00:26,939 --> 00:00:28,300
这种错误就会出来了

13
00:00:28,820 --> 00:00:30,500
那这个and是什么呢

14
00:00:30,500 --> 00:00:33,939
今天我们终于要揭开他的面纱了

15
00:00:34,020 --> 00:00:37,770
我们的这个and是c语言的一个运算符

16
00:00:37,770 --> 00:00:38,939
跟加减乘除一样

17
00:00:38,939 --> 00:00:40,049
它是一个运算符

18
00:00:40,049 --> 00:00:41,418
它算什么呢

19
00:00:42,340 --> 00:00:46,598
这个and符号它的作用是取得变量的地址

20
00:00:47,119 --> 00:00:49,549
所以它的操作数必须是一个变量

21
00:00:49,549 --> 00:00:51,740
它把这个变量的地址拿出来给你

22
00:00:51,740 --> 00:00:53,359
为什么变量会有地址

23
00:00:53,359 --> 00:00:57,280
因为c语言的变量是放在内存里头的

24
00:00:57,280 --> 00:01:00,329
每一个变量我们之前用size of看过

25
00:01:00,329 --> 00:01:01,920
比如说int可能是四个字节

26
00:01:01,920 --> 00:01:03,420
这四个字节的int

27
00:01:03,420 --> 00:01:05,579
它在内存当中要占据一定的地方

28
00:01:05,579 --> 00:01:06,870
它放在某个地方

29
00:01:06,870 --> 00:01:08,159
它就有个地址

30
00:01:08,280 --> 00:01:10,980
所以n的运算符就是把那个地

31
00:01:10,980 --> 00:01:13,519
把那个变量的地址拿出来告诉你

32
00:01:13,540 --> 00:01:15,519
那这个地址会是一个什么样的值呢

33
00:01:15,519 --> 00:01:16,780
我们来试试看一下

34
00:01:16,780 --> 00:01:19,739
我们听说这些东西地址啊

35
00:01:19,739 --> 00:01:21,359
什么这些东西呃

36
00:01:21,359 --> 00:01:23,040
用16进制表达会比较方便

37
00:01:23,040 --> 00:01:25,439
所以呢我们做了一个百分号x

38
00:01:25,439 --> 00:01:28,840
我们把i的地址取出来

39
00:01:28,840 --> 00:01:30,359
交给百分号x

40
00:01:30,640 --> 00:01:32,920
其实有同学做错过程序

41
00:01:32,920 --> 00:01:34,629
已经看到过这种结果

42
00:01:34,629 --> 00:01:37,329
他以为print pf和scaf一样都要加个and

43
00:01:37,329 --> 00:01:38,709
在print pf那边加了个end

44
00:01:38,709 --> 00:01:40,569
然后没有得到他想要的那个结果

45
00:01:40,569 --> 00:01:42,280
其实他当时看到那个值

46
00:01:42,280 --> 00:01:44,120
就是i这个变量的地址

47
00:01:44,120 --> 00:01:45,920
我们来看看这样的程序编译运行

48
00:01:45,920 --> 00:01:47,340
会得到什么样的结果

49
00:01:48,540 --> 00:01:51,939
首先呢我们的编译器给了我们一个warning

50
00:01:52,159 --> 00:01:53,120
我还得说

51
00:01:53,120 --> 00:01:55,040
不是所有的编译器都会给这个warning的

52
00:01:55,040 --> 00:01:58,250
这个编译器说你的那个类型是on sound int

53
00:01:58,250 --> 00:02:00,109
我们我们说要摆放x对不对

54
00:02:00,109 --> 00:02:03,150
可是呢这个参数的类型是int的心

55
00:02:03,150 --> 00:02:04,230
ok什么是int的心

56
00:02:04,230 --> 00:02:05,790
我们等会儿再来说这件事情

57
00:02:05,790 --> 00:02:06,930
反正他说类型不匹配

58
00:02:06,930 --> 00:02:08,699
可是呢这只是一个warning

59
00:02:08,719 --> 00:02:11,240
他还是给我们看到了值0x bf

60
00:02:11,240 --> 00:02:12,379
12b70 

61
00:02:14,020 --> 00:02:15,000
这个值是什么意思

62
00:02:15,000 --> 00:02:15,659
我们不知道

63
00:02:15,659 --> 00:02:17,699
这这看上去像是一个蛮大的数字

64
00:02:17,699 --> 00:02:20,879
因为32位的一个数字的话

65
00:02:20,879 --> 00:02:23,819
这是已经这个高位为一了

66
00:02:23,819 --> 00:02:25,400
已经在比较大的地方了

67
00:02:25,679 --> 00:02:28,750
实际上呢这个网点是告诉我们说

68
00:02:28,750 --> 00:02:31,870
你要去想让print给你输出一个地址

69
00:02:31,870 --> 00:02:34,539
你不应该用百分号x用什么呢

70
00:02:34,539 --> 00:02:38,019
实际上它需要你用的是百分号p

71
00:02:39,699 --> 00:02:40,419
我们来看一下

72
00:02:40,419 --> 00:02:41,258
如果用百分号p

73
00:02:41,258 --> 00:02:42,840
我们会得到什么样的结果

74
00:02:44,338 --> 00:02:45,258
一模一样

75
00:02:45,258 --> 00:02:46,818
和百分号x一模一样

76
00:02:46,818 --> 00:02:50,099
百分号p会把这个值作为一个地址来输出

77
00:02:50,099 --> 00:02:51,000
他在输出的时候

78
00:02:51,000 --> 00:02:52,020
前面会加0x

79
00:02:52,020 --> 00:02:53,879
并且以16进制的方式来输出

80
00:02:53,879 --> 00:02:55,080
这个地址给你看

81
00:02:55,800 --> 00:03:00,379
这是一个我们说他返回的这个取地址符

82
00:03:00,379 --> 00:03:01,400
给你的是一个地址

83
00:03:01,400 --> 00:03:04,469
而这个地址呢我们看上去很像一个整数

84
00:03:04,469 --> 00:03:05,129
我们可以试一下

85
00:03:05,129 --> 00:03:06,629
如果我们有另外一个变量

86
00:03:06,629 --> 00:03:07,860
比如说int

87
00:03:08,778 --> 00:03:12,609
然后我们说让这个p等于and i会行不行

88
00:03:12,609 --> 00:03:16,060
当然这次编译在这个地方

89
00:03:16,060 --> 00:03:17,860
他就会说p等于and i

90
00:03:17,860 --> 00:03:20,370
会有一个类型转换的问题

91
00:03:20,370 --> 00:03:21,389
虽然还是个warning好

92
00:03:21,389 --> 00:03:23,520
那我们来做一个强制类型转换

93
00:03:23,520 --> 00:03:25,949
我们强制把这个取地址得到的结果

94
00:03:25,949 --> 00:03:27,060
转换成int

95
00:03:27,060 --> 00:03:31,099
然后我们希望他给我们看到这个p

96
00:03:31,099 --> 00:03:32,539
而不是那个and i

97
00:03:32,539 --> 00:03:35,900
我们把i的地址强制转换成一个int

98
00:03:35,900 --> 00:03:37,039
交给一个int的变量

99
00:03:37,039 --> 00:03:38,240
然后让这个int的变量

100
00:03:38,240 --> 00:03:40,209
以16g的形式去输出

101
00:03:40,209 --> 00:03:44,479
我们看到这个整形的这个int型的变量

102
00:03:44,479 --> 00:03:46,879
和我们直接把这个地址打印出来

103
00:03:46,879 --> 00:03:49,039
他们的结果是一模一样的

104
00:03:49,039 --> 00:03:52,069
这是因为现在我在做编译的时候

105
00:03:52,069 --> 00:03:52,669
加了一个选项

106
00:03:52,669 --> 00:03:55,370
说我要以32位的架构去编译它

107
00:03:55,370 --> 00:03:56,879
如果我换一下

108
00:03:56,899 --> 00:03:58,218
我把它换成说

109
00:03:58,218 --> 00:04:00,139
我现在以64位的架构去编译它

110
00:04:00,139 --> 00:04:01,900
我们看看它还对不对

111
00:04:04,240 --> 00:04:07,259
我们看到编译没有给我们任何的亡灵

112
00:04:07,259 --> 00:04:09,000
因为我们做了强制转换

113
00:04:09,000 --> 00:04:09,479
他说好吧

114
00:04:09,479 --> 00:04:10,770
反正你要强制转换

115
00:04:10,770 --> 00:04:11,699
大家还记不记得

116
00:04:11,699 --> 00:04:14,580
我们在讨论区布置过这道讨论题

117
00:04:14,819 --> 00:04:17,790
整数的类型转换到底是怎么做的

118
00:04:17,790 --> 00:04:23,720
你看现在我们转换出来的int这是这么大

119
00:04:23,720 --> 00:04:27,470
而作为地址输出是这么大

120
00:04:27,470 --> 00:04:29,269
现在我是64位的架构喽

121
00:04:29,269 --> 00:04:31,129
我是64位的架构的时候

122
00:04:31,129 --> 00:04:34,560
我的int和我的地址就不一样了

123
00:04:34,560 --> 00:04:35,040
事实上

124
00:04:35,040 --> 00:04:36,660
我们还有另外一个方案来看这件事情

125
00:04:36,660 --> 00:04:37,709
我们知道size of

126
00:04:37,709 --> 00:04:38,579
所以

127
00:04:40,660 --> 00:04:41,850
我们来试一下

128
00:04:41,850 --> 00:04:43,709
现在在64位的架构上

129
00:04:43,709 --> 00:04:47,420
size of int和size

130
00:04:48,980 --> 00:04:53,019
我要取那个and i的那个结果

131
00:04:53,019 --> 00:04:56,620
我要取i的这个地址的结果

132
00:04:56,620 --> 00:04:58,660
这两个size of是否相等

133
00:04:58,920 --> 00:05:01,470
我们看到在64位架构下

134
00:05:01,470 --> 00:05:03,350
int是四个字节

135
00:05:03,350 --> 00:05:06,199
而size of那个地址那个地址取出来

136
00:05:06,199 --> 00:05:07,160
它是八个字节

137
00:05:07,160 --> 00:05:09,319
如果我们再换到32位架构

138
00:05:09,319 --> 00:05:10,879
现在我们在32位架构下面

139
00:05:10,879 --> 00:05:12,170
我们重新来运行这个代码

140
00:05:12,170 --> 00:05:16,709
我们看到int和地址都是四个字节

141
00:05:16,709 --> 00:05:17,610
不管怎么说

142
00:05:17,610 --> 00:05:19,410
我们刚才的演示看到说

143
00:05:19,410 --> 00:05:22,259
and可以给我们取出一个变量的地址

144
00:05:22,259 --> 00:05:24,800
但是这个地址的大小

145
00:05:24,800 --> 00:05:27,410
它的数据类型和int是否相等

146
00:05:27,410 --> 00:05:28,579
取决于边一起

147
00:05:28,579 --> 00:05:30,350
取决于你是64位架构

148
00:05:30,350 --> 00:05:31,720
还是32位架构

149
00:05:32,819 --> 00:05:35,540
所以我们要去让print f

150
00:05:35,540 --> 00:05:36,560
给我们输出一个地址

151
00:05:36,560 --> 00:05:38,449
我们需要用的是百分2p

152
00:05:38,449 --> 00:05:41,019
而不是真的直接把它当成整数

153
00:05:41,720 --> 00:05:45,129
地址和整数并不永远是相同的

154
00:05:45,129 --> 00:05:46,939
这和你的架构是有关的

155
00:05:47,000 --> 00:05:49,180
我们要去取地址的时候

156
00:05:49,180 --> 00:05:51,639
and这个取地址的符运算符

157
00:05:51,639 --> 00:05:53,860
它必须对一个变量去取地址

158
00:05:53,860 --> 00:05:56,689
所以如果它的右边不是一个变量

159
00:05:56,689 --> 00:05:57,800
就不能取地址

160
00:05:57,800 --> 00:05:58,970
我们来试试看

161
00:05:58,970 --> 00:06:01,548
如果我们想要说p等于

162
00:06:01,548 --> 00:06:06,228
and i加pi和p两个都是整数

163
00:06:06,228 --> 00:06:07,249
所以他们可以做相加

164
00:06:07,249 --> 00:06:07,939
对不对

165
00:06:08,199 --> 00:06:10,180
这个编译的结果就会是一个error

166
00:06:10,180 --> 00:06:14,860
他说不能取这种东西的地址啊

167
00:06:14,860 --> 00:06:15,970
这个地址是取不来的

168
00:06:15,970 --> 00:06:18,620
或者我可不可以做i加加

169
00:06:18,899 --> 00:06:21,300
他也说不能做i加加的地址

170
00:06:21,300 --> 00:06:22,879
能不能做加加i呢

171
00:06:23,158 --> 00:06:25,319
他也说不能做加加i的地址

172
00:06:25,319 --> 00:06:27,598
也就是说在取地址符的右边

173
00:06:27,598 --> 00:06:29,038
你必须有一个什么

174
00:06:29,038 --> 00:06:31,819
必须有一个明确的变量

175
00:06:31,819 --> 00:06:33,500
你才能够去取他的地址

176
00:06:33,500 --> 00:06:34,879
那我们可以再试试

177
00:06:34,879 --> 00:06:37,879
这些东西能不能取相邻的变量的地址

178
00:06:37,879 --> 00:06:39,439
ok我们看看他们会是怎么样

179
00:06:39,439 --> 00:06:42,620
我们有i和p这两个整型的变量

180
00:06:42,620 --> 00:06:43,639
它们是相邻的

181
00:06:43,639 --> 00:06:45,500
我们看一下i和p这两个变量的地址

182
00:06:45,500 --> 00:06:46,559
是怎么样子的

183
00:06:46,559 --> 00:06:48,119
我们看到一个是6c

184
00:06:48,119 --> 00:06:49,360
一个是六八

185
00:06:49,560 --> 00:06:51,360
ok这里头有很多东西可以琢磨的

186
00:06:51,360 --> 00:06:53,560
首先6c和六八差多少

187
00:06:54,399 --> 00:06:55,560
这是16进制

188
00:06:55,560 --> 00:06:57,540
所以c相当于十进制的12

189
00:06:57,540 --> 00:06:58,800
12-8=4

190
00:06:58,800 --> 00:07:00,810
而我们知道现在32位的架构底下

191
00:07:00,810 --> 00:07:02,100
我们的int就是四

192
00:07:02,100 --> 00:07:04,790
所以这两个它们的差

193
00:07:04,790 --> 00:07:06,949
正好就是差了一个东西

194
00:07:06,949 --> 00:07:08,720
因此这代表着什么意思呢

195
00:07:08,720 --> 00:07:10,649
这说明在我们的内存里头

196
00:07:10,649 --> 00:07:13,620
其实他们两个是紧挨着的放的

197
00:07:15,100 --> 00:07:17,730
这是六八的那一位

198
00:07:17,730 --> 00:07:19,199
他的地址在这儿

199
00:07:19,199 --> 00:07:21,139
它需要占据四个字节

200
00:07:21,579 --> 00:07:24,069
然后接下去是6c的那一位

201
00:07:24,069 --> 00:07:25,980
他也要占据四个字节

202
00:07:26,279 --> 00:07:28,079
可是你有没有注意到谁是六八

203
00:07:28,079 --> 00:07:29,040
谁是6c

204
00:07:29,420 --> 00:07:31,220
我们回过头去再去看一下

205
00:07:31,220 --> 00:07:33,860
i是6c p是六八

206
00:07:33,860 --> 00:07:36,569
也就是说这是i

207
00:07:36,569 --> 00:07:37,949
而这是p

208
00:07:37,949 --> 00:07:39,850
我们知道i是我们定义在

209
00:07:39,850 --> 00:07:41,170
先定义的那个变量

210
00:07:41,170 --> 00:07:42,399
p是后定义的那个变量

211
00:07:42,399 --> 00:07:44,920
但是呢他们俩在内存里头位置

212
00:07:44,920 --> 00:07:47,290
i在更高的地方

213
00:07:47,290 --> 00:07:49,100
而p在更低的地方

214
00:07:49,100 --> 00:07:51,050
这是因为我们以后会讲到

215
00:07:51,050 --> 00:07:52,579
c语言的内存模型

216
00:07:52,800 --> 00:07:54,240
我们的这两个变量

217
00:07:54,240 --> 00:07:56,160
我们的这两个变量都是本地变量

218
00:07:56,160 --> 00:07:57,660
它们分配在内存的

219
00:07:57,660 --> 00:07:59,779
我们一种叫做堆栈的地方

220
00:08:01,740 --> 00:08:04,579
所以呢在对战里面我们分配内存呢

221
00:08:04,579 --> 00:08:07,579
我们分配变量呢是自顶向下来分配的

222
00:08:07,579 --> 00:08:08,660
从上往下分配

223
00:08:08,660 --> 00:08:11,060
所以我们会看到我们先写的那个变量

224
00:08:11,060 --> 00:08:12,470
它的地址更高

225
00:08:12,470 --> 00:08:14,360
后写的那个变量地址更低

226
00:08:14,360 --> 00:08:15,889
但是呢他们是紧挨着的

227
00:08:15,889 --> 00:08:18,329
因为他们的这个差距就是四

228
00:08:18,329 --> 00:08:20,279
这个四刚好等于size of int

229
00:08:20,279 --> 00:08:22,319
我们看过了and的结果的

230
00:08:22,319 --> 00:08:23,129
size of

231
00:08:23,129 --> 00:08:25,500
在32位和64位架构他们不一样

232
00:08:25,500 --> 00:08:27,060
我们来看看数组的地址怎么样

233
00:08:27,060 --> 00:08:28,379
还有数组单元的地址

234
00:08:28,379 --> 00:08:30,000
还有相邻的数字单元的地址

235
00:08:30,000 --> 00:08:31,350
我们来看看关于数组

236
00:08:31,350 --> 00:08:32,929
我们怎么去取地址出来

237
00:08:32,929 --> 00:08:35,029
我们看我们做了一个int的数组a

238
00:08:35,029 --> 00:08:36,649
它是十个ink的数组

239
00:08:36,649 --> 00:08:38,210
然后我们设了四件事情

240
00:08:38,210 --> 00:08:41,519
第一件事情是把a交给取地址符

241
00:08:41,519 --> 00:08:42,990
去取出他的地址

242
00:08:42,990 --> 00:08:46,230
第二件事情是直接把a拿来当做一个地址

243
00:08:46,230 --> 00:08:47,789
我们好像之前从来没有做过这件事情

244
00:08:47,789 --> 00:08:48,210
对不对

245
00:08:48,210 --> 00:08:49,169
我们在讲数组的时候

246
00:08:49,169 --> 00:08:50,190
曾经提到过一件事情

247
00:08:50,190 --> 00:08:52,559
就是说一一个地方曾经提到过

248
00:08:52,559 --> 00:08:53,399
这种样子的用法

249
00:08:53,399 --> 00:08:55,500
我们说如果你有另外一个

250
00:08:55,519 --> 00:08:58,259
我们当时说如果你有另外一个数组b

251
00:08:58,419 --> 00:09:01,000
然后你不可以说a等于b等于a

252
00:09:01,000 --> 00:09:02,698
这件事情你是不能做的

253
00:09:02,919 --> 00:09:04,960
可是现在我们做的事情是说

254
00:09:04,960 --> 00:09:08,590
我们直接拿这个a这个数组变量的名字

255
00:09:08,590 --> 00:09:10,299
试图把它交给print f

256
00:09:10,299 --> 00:09:12,490
试图把它当做一个地址去输出

257
00:09:12,490 --> 00:09:14,000
我们看看这件事情能不能做

258
00:09:14,000 --> 00:09:15,860
然后在这儿做的事情是

259
00:09:15,860 --> 00:09:18,019
我们让他去取出a0 的地址

260
00:09:18,019 --> 00:09:20,309
也就是a里面的第一个元素的地址

261
00:09:20,309 --> 00:09:21,629
和a一的地址

262
00:09:21,629 --> 00:09:23,429
这是a里面的第一个元素的地址

263
00:09:23,429 --> 00:09:25,889
我们看看这个代码执行的结果会是怎么样

264
00:09:25,889 --> 00:09:30,679
我们看到这是a的地址四四

265
00:09:30,679 --> 00:09:34,190
这是试图直接拿a当做地址来输出

266
00:09:34,190 --> 00:09:35,299
也是四四

267
00:09:35,299 --> 00:09:36,620
而且编译是过了的

268
00:09:36,620 --> 00:09:39,169
这是a0 的地址还是四四

269
00:09:39,169 --> 00:09:41,240
而这是a一的地址

270
00:09:41,240 --> 00:09:42,479
这是四八

271
00:09:43,120 --> 00:09:44,159
这说明什么

272
00:09:44,159 --> 00:09:48,519
我们做了一个数组里面有十个int

273
00:09:49,379 --> 00:09:54,458
这是a我们发现说and的a和a是相等的

274
00:09:55,000 --> 00:09:57,100
它也等于因为这是第零个元素

275
00:09:57,100 --> 00:10:00,460
它也等于a0 的地址

276
00:10:00,460 --> 00:10:02,379
而a一的地址呢

277
00:10:02,379 --> 00:10:04,029
他们俩之间的差距是四

278
00:10:04,029 --> 00:10:05,019
如果我们一直看下去

279
00:10:05,019 --> 00:10:05,860
我们会发现

280
00:10:05,860 --> 00:10:08,169
相邻的数组单元之间的地址的差距

281
00:10:08,169 --> 00:10:09,200
永远是四

