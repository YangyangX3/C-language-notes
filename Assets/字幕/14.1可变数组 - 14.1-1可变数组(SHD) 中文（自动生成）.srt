1
00:00:04,459 --> 00:00:06,259
我们知道这个c语言的数组

2
00:00:07,820 --> 00:00:09,039
它是固定大小的

3
00:00:09,519 --> 00:00:10,900
尽管c99 

4
00:00:10,900 --> 00:00:14,619
我们可以用变量来定义一个数组的大小

5
00:00:14,619 --> 00:00:17,120
但是一旦我们有了这么一个数组

6
00:00:17,379 --> 00:00:20,920
我们在运行过程当中是无法改变它的

7
00:00:20,920 --> 00:00:22,199
这个大小的

8
00:00:23,320 --> 00:00:25,620
假如我们一开始不知道我们要有多多少

9
00:00:25,620 --> 00:00:26,940
这个数据要放

10
00:00:26,940 --> 00:00:30,820
那么传统上呢我们只有一个办法啊

11
00:00:30,820 --> 00:00:31,940
尽量搞个大点

12
00:00:32,759 --> 00:00:34,219
大点的也有可能不够啊

13
00:00:35,299 --> 00:00:36,560
你总不能说我开个速度

14
00:00:36,560 --> 00:00:37,939
把内存全部用完吧

15
00:00:39,240 --> 00:00:41,719
所以我们今天要来考虑

16
00:00:41,719 --> 00:00:45,140
你说我们怎么样自己做一个东西

17
00:00:45,560 --> 00:00:49,399
我们用c语言的代码自己去实现

18
00:00:49,399 --> 00:00:52,299
那么一个可以变大小的数组

19
00:00:54,579 --> 00:00:57,179
我们想要做这么一个东西

20
00:00:58,000 --> 00:01:00,600
他应该有这么几个特点

21
00:01:00,600 --> 00:01:03,399
一个呢它是可以长大的

22
00:01:04,439 --> 00:01:07,019
一开始可能比如说100个整数

23
00:01:07,640 --> 00:01:09,040
100个不够放了

24
00:01:09,040 --> 00:01:11,219
它能够自动给我涨到120个

25
00:01:11,459 --> 00:01:13,260
120个又不够放了

26
00:01:13,260 --> 00:01:15,090
给我涨到140个

27
00:01:15,090 --> 00:01:16,899
我希望他有这个特点

28
00:01:18,120 --> 00:01:21,469
第二个呢呃我有这么一个东西之后

29
00:01:21,469 --> 00:01:22,700
显然我要有一个办法

30
00:01:22,700 --> 00:01:24,539
能够知道他现在有多大

31
00:01:24,959 --> 00:01:25,620
我们知道

32
00:01:25,620 --> 00:01:26,819
比如说对于c的数组来说

33
00:01:26,819 --> 00:01:28,739
我们可以什么size of去除啊

34
00:01:28,739 --> 00:01:29,219
除啊什么的

35
00:01:29,219 --> 00:01:30,530
我们可以得到那个东西

36
00:01:30,530 --> 00:01:32,269
那么现在我们自己做这么一东西

37
00:01:32,269 --> 00:01:34,069
我们也要有个办法能够知道它有多大

38
00:01:34,069 --> 00:01:35,569
因为我们要对他做便利啊什么的

39
00:01:35,569 --> 00:01:37,379
有很多事情和这个是相关的

40
00:01:37,840 --> 00:01:39,489
然后当然最重要的

41
00:01:39,489 --> 00:01:42,200
我们要能够访问当中的单元单元啊

42
00:01:42,379 --> 00:01:43,640
对于c的数组

43
00:01:43,640 --> 00:01:46,099
我们是用方括号加一个数字

44
00:01:46,099 --> 00:01:47,840
那么我们自己做的这种东西

45
00:01:47,840 --> 00:01:49,400
我们也要有一个方便的方法

46
00:01:49,400 --> 00:01:52,299
合理的方法能够去访问到他当中的单元

47
00:01:54,340 --> 00:01:55,159
怎么做呢

48
00:01:56,200 --> 00:02:00,659
那我们可以实现一个函数库

49
00:02:01,439 --> 00:02:03,319
我们定义一些函数

50
00:02:03,319 --> 00:02:07,790
这些函数可以给我们提供这么一种

51
00:02:07,790 --> 00:02:09,860
能够自动增长的

52
00:02:09,860 --> 00:02:11,939
能够变大小的那么一个数组

53
00:02:12,359 --> 00:02:13,769
这个函数库里面呢

54
00:02:13,769 --> 00:02:18,280
我们先考虑我们要有这么一些函数create

55
00:02:18,280 --> 00:02:20,169
所有的函数都是array开头啊

56
00:02:20,169 --> 00:02:23,879
create表示说用来创建一个数组

57
00:02:24,099 --> 00:02:26,020
那我们自然有办法去把这个数组给创

58
00:02:26,020 --> 00:02:26,860
建出来对吧

59
00:02:26,860 --> 00:02:30,439
然后free呢用来把这个数组的空间给回收了

60
00:02:30,780 --> 00:02:31,680
size

61
00:02:31,680 --> 00:02:32,280
告诉我们

62
00:02:32,280 --> 00:02:35,439
这个数组里头现在有多少个单元可以用

63
00:02:36,080 --> 00:02:37,180
我们要获得

64
00:02:37,180 --> 00:02:39,580
我们要去访问那个数字当中某个单元

65
00:02:39,659 --> 00:02:41,520
而且大家记得在数组当中

66
00:02:41,520 --> 00:02:44,099
我们知道说我们访问它的某个单元的时候

67
00:02:44,099 --> 00:02:45,240
我们是可以读

68
00:02:45,240 --> 00:02:46,028
也可以写

69
00:02:46,028 --> 00:02:46,989
可以做左值

70
00:02:46,989 --> 00:02:47,889
也可以做右指的

71
00:02:47,889 --> 00:02:49,329
那么我们这个函数能不能做

72
00:02:49,329 --> 00:02:50,879
我们下面仔细去研究啊

73
00:02:50,879 --> 00:02:54,659
infit这是我们看上去像是一个核心的函数

74
00:02:54,659 --> 00:02:57,819
他做的事情是让这个数组长大

75
00:02:58,319 --> 00:02:59,460
当然怎么做

76
00:02:59,460 --> 00:03:00,900
我们具体看代码

77
00:03:00,900 --> 00:03:04,259
其实首先呢我们先要去定义出这个2a

78
00:03:04,780 --> 00:03:06,759
我们定义arena是这样啊

79
00:03:06,759 --> 00:03:08,740
我们定义一个结构

80
00:03:08,740 --> 00:03:11,020
这个结构里面呢有两个成员

81
00:03:11,020 --> 00:03:14,500
一个成员呢是一个int的数组啊

82
00:03:14,500 --> 00:03:15,939
实际上是一个int的指针啊

83
00:03:15,939 --> 00:03:17,949
一个成员第一个成员是一个int的指针

84
00:03:17,949 --> 00:03:20,719
第二个成员呢是一个size

85
00:03:20,859 --> 00:03:22,959
那么这两个成员合起来

86
00:03:22,959 --> 00:03:24,699
我们用这个结构来表达

87
00:03:24,699 --> 00:03:27,399
我们做的我们自己做的那种数组

88
00:03:27,399 --> 00:03:28,118
可变的数组

89
00:03:28,118 --> 00:03:29,360
我们把它叫做2v

90
00:03:29,699 --> 00:03:31,500
这里我们就会有一个疑问啊

91
00:03:31,500 --> 00:03:34,439
实际上呢这个我们在有些别人的写的

92
00:03:34,439 --> 00:03:35,969
第三方库里面会看到

93
00:03:35,969 --> 00:03:38,759
他们会习惯于呢把它定义成这个样子

94
00:03:38,759 --> 00:03:41,000
说我在这儿有个新号

95
00:03:41,740 --> 00:03:42,960
在这儿有个星号的

96
00:03:42,960 --> 00:03:45,889
意思是说如果你有个变量ra

97
00:03:45,889 --> 00:03:48,659
那么这个a呢其实是个指针

98
00:03:48,679 --> 00:03:49,399
为什么呢

99
00:03:49,399 --> 00:03:51,079
你看我们的这些函数里面

100
00:03:51,079 --> 00:03:53,329
很多地方要的是个指针

101
00:03:53,329 --> 00:03:54,649
要的是个指针

102
00:03:54,649 --> 00:03:55,938
要的是个指针

103
00:03:55,938 --> 00:03:57,340
要的是个指针

104
00:03:57,439 --> 00:03:59,240
我们在结构那一章里面

105
00:03:59,240 --> 00:04:00,319
在结构那一周里面

106
00:04:00,319 --> 00:04:01,689
我们明确讲过

107
00:04:01,689 --> 00:04:04,870
如果你有个结构要传到函数里头去

108
00:04:04,870 --> 00:04:06,430
如果你传的是结构本身

109
00:04:06,430 --> 00:04:09,340
那是一个比较成本比较大的事情

110
00:04:09,340 --> 00:04:12,520
所以我们传个指针呢会比较轻巧一点

111
00:04:12,520 --> 00:04:15,460
那既然我们函数到处都是要用指针的

112
00:04:15,460 --> 00:04:17,899
如果我定义说array是一个指针

113
00:04:17,899 --> 00:04:19,699
你看我们现在这样typedef的话

114
00:04:19,699 --> 00:04:22,038
意味着整个这个东西是一个array

115
00:04:22,038 --> 00:04:23,399
而这个东西是个指针

116
00:04:23,399 --> 00:04:26,420
那那个时候呢我们这些信号就可以去掉了

117
00:04:26,420 --> 00:04:28,279
看起来没有星号

118
00:04:28,279 --> 00:04:29,839
好像看起来比较好看

119
00:04:29,839 --> 00:04:30,620
对不对

120
00:04:30,620 --> 00:04:34,939
但是这样子以后有一个很大的缺点

121
00:04:34,939 --> 00:04:37,220
就是如果假如说我们这有一个函数

122
00:04:37,220 --> 00:04:39,529
比如说有个f函数

123
00:04:39,529 --> 00:04:42,379
然后我要想在f函数里面有个本地变量

124
00:04:42,379 --> 00:04:43,079
array

125
00:04:43,120 --> 00:04:44,439
我就做不出来了

126
00:04:44,439 --> 00:04:46,089
因为我现在得到的这个a

127
00:04:46,089 --> 00:04:49,660
它一定是从某个地方去给我制造出来的

128
00:04:49,660 --> 00:04:50,519
一个东西

129
00:04:50,620 --> 00:04:52,980
比如说动态申请一块内存

130
00:04:53,680 --> 00:04:58,079
现在呢我们让它只是一个只是一个结构

131
00:04:58,079 --> 00:04:59,040
而不是一个指针

132
00:04:59,040 --> 00:05:01,350
那么就意味着如果我写下rva的话

133
00:05:01,350 --> 00:05:03,100
a就是一个本地变量

134
00:05:03,279 --> 00:05:04,689
他就在这里

135
00:05:04,689 --> 00:05:06,699
他不在别的地方啊

136
00:05:06,699 --> 00:05:10,100
所以其实现在的人们更加习惯于说

137
00:05:10,100 --> 00:05:12,970
当我去定义一个这个新的类型的时候

138
00:05:12,970 --> 00:05:14,379
不要把信号带进去

139
00:05:14,379 --> 00:05:17,829
换句话说不要定义出一种指针类型来

140
00:05:17,829 --> 00:05:20,500
因为如果你定义了一个指针类型

141
00:05:20,500 --> 00:05:21,879
我们还有个附带的缺点

142
00:05:21,879 --> 00:05:24,139
就是啊现在人家看到这个样子

143
00:05:24,218 --> 00:05:26,019
看到这一行代码的人

144
00:05:26,019 --> 00:05:28,860
会想到说a其实是一个指针吗

145
00:05:29,540 --> 00:05:30,759
他不容易想到

146
00:05:30,759 --> 00:05:31,300
对不对

147
00:05:31,300 --> 00:05:34,980
所以宁愿我们不带这个指针

148
00:05:35,500 --> 00:05:36,819
这是第一件事情

149
00:05:36,819 --> 00:05:39,100
我们的结构体长成这个样子

150
00:05:39,639 --> 00:05:42,009
然后这是我们的头文件

151
00:05:42,009 --> 00:05:44,439
接下来我们该有一个lv.c

152
00:05:44,439 --> 00:05:46,620
来把这些函数都实现一下了

153
00:05:46,658 --> 00:05:48,038
当然在a.c里面

154
00:05:48,038 --> 00:05:49,559
我们要include这个a.h

155
00:05:49,559 --> 00:05:53,470
然后我们要开始逐一地实现这些东西

156
00:05:53,470 --> 00:05:55,180
我们可以先把这些东西呢

157
00:05:55,180 --> 00:05:57,100
都抄到2a.c里头来

158
00:05:57,100 --> 00:05:59,379
然后在这儿加上注释

159
00:05:59,379 --> 00:06:00,788
这是给我们看看的

160
00:06:00,788 --> 00:06:01,869
这是函数的原型

161
00:06:01,869 --> 00:06:04,860
我们开始要逐一把它变成真的函数的body了

162
00:06:04,879 --> 00:06:07,540
第一个函数是create

163
00:06:08,860 --> 00:06:12,029
这个函数呢它的参数是size

164
00:06:12,029 --> 00:06:13,980
一开始你希望这个数组是多大

165
00:06:13,980 --> 00:06:16,060
然后他给你一个array

166
00:06:17,639 --> 00:06:18,918
我们的做法是说

167
00:06:20,178 --> 00:06:22,699
我们在这儿呢做一个lv的变量

168
00:06:22,699 --> 00:06:25,899
a这是一个结构变量

169
00:06:25,899 --> 00:06:26,589
对不对

170
00:06:26,589 --> 00:06:28,740
它就会有size

171
00:06:28,740 --> 00:06:31,500
我们让size呢等于这个in it size

172
00:06:31,500 --> 00:06:34,069
然后让他的array呢

173
00:06:34,069 --> 00:06:36,860
等于呢我们去做一个malloc

174
00:06:36,860 --> 00:06:39,079
当然别忘了这是int型

175
00:06:39,079 --> 00:06:43,418
所以我们要类型转换size of int

176
00:06:43,418 --> 00:06:47,579
去乘以这个a的size

177
00:06:48,920 --> 00:06:52,980
最后我们return这个a就这个样子

178
00:06:54,579 --> 00:06:57,059
这个样子做的时候呢

179
00:06:57,059 --> 00:06:59,730
我们返回类型是一个arrider

180
00:06:59,730 --> 00:07:02,129
变量本身不是指针

181
00:07:02,129 --> 00:07:04,439
为什么返回阿瑞不返回a的指针呢

182
00:07:04,439 --> 00:07:06,000
因为这是本地变量啊

183
00:07:06,000 --> 00:07:06,899
你返回指针的话

184
00:07:06,899 --> 00:07:08,579
这个本地变量不就无效了吗

185
00:07:08,579 --> 00:07:09,178
对不对

186
00:07:09,178 --> 00:07:11,218
那为什么我不在这里

187
00:07:11,218 --> 00:07:14,100
mlock出一个array的结构来

188
00:07:14,100 --> 00:07:16,290
然后返回那个mlock出去的东西呢

189
00:07:16,290 --> 00:07:20,259
那会使得我们对这个rv的使用比较复杂

190
00:07:20,420 --> 00:07:21,800
因为你看

191
00:07:21,800 --> 00:07:23,959
如果我们有一个这样的二维函数的话

192
00:07:23,959 --> 00:07:24,980
create函数的话

193
00:07:24,980 --> 00:07:26,620
那在我们的main里头

194
00:07:27,079 --> 00:07:33,050
我们就可以说我们有个arra等于array的create

195
00:07:33,050 --> 00:07:34,439
比如说100

196
00:07:35,639 --> 00:07:39,619
这看上去就很像c的正常的代码

197
00:07:39,619 --> 00:07:41,358
那在这个过程当中呢

198
00:07:41,358 --> 00:07:43,309
我们有一个本地变量a

199
00:07:43,309 --> 00:07:46,838
它会用我们在a recreate里面

200
00:07:46,838 --> 00:07:49,899
所制作出来的这个结构来初始化

201
00:07:49,899 --> 00:07:53,819
换句话说这个a呢是存在于命的本地的

202
00:07:53,819 --> 00:07:55,500
它里面的所有的变量

203
00:07:55,500 --> 00:07:56,610
所有的成员

204
00:07:56,610 --> 00:07:59,160
就是我们从a recreate返回出来的

205
00:07:59,160 --> 00:08:00,899
那个a里面所有的成员

206
00:08:02,000 --> 00:08:03,370
以这种方式呢

207
00:08:03,370 --> 00:08:05,319
我们让它返回一个结构体

208
00:08:05,319 --> 00:08:08,439
就使得我们在外面可以有比较灵活的方式

209
00:08:08,439 --> 00:08:10,120
去使用这个a recreate

210
00:08:10,120 --> 00:08:13,040
返回的那个制造出来的那个arr

211
00:08:13,158 --> 00:08:14,749
如果不是这么做的

212
00:08:14,749 --> 00:08:16,639
我们可能另外一种做法是说

213
00:08:16,639 --> 00:08:18,499
我们宁愿先希望他说

214
00:08:18,499 --> 00:08:24,579
我如果这个array create是返回一个指针的

215
00:08:24,579 --> 00:08:27,759
那我们可能希望他说你给我一个array

216
00:08:27,759 --> 00:08:30,819
然后给我一个in it size

217
00:08:31,920 --> 00:08:34,620
然后我做了一些事情之后

218
00:08:34,620 --> 00:08:36,179
我就return那个a给你

219
00:08:36,179 --> 00:08:39,120
但我做的事情可能就是a所指的size呢

220
00:08:39,120 --> 00:08:41,100
等于in it the size

221
00:08:41,100 --> 00:08:46,799
然后a所指的这个array呢等于什么什么

222
00:08:47,259 --> 00:08:49,779
当然这是一种可能的做法

223
00:08:49,779 --> 00:08:53,909
可是在这种做法里面有一个潜在的风险

224
00:08:53,909 --> 00:08:57,539
就是如果别人使用了你这个函数的时候

225
00:08:57,539 --> 00:09:01,440
传给你的这个a有两种可能

226
00:09:01,440 --> 00:09:02,460
造成它是有问题的

227
00:09:02,460 --> 00:09:04,839
第一种可能如果a等于now

228
00:09:06,860 --> 00:09:11,019
第二种可能如果a已经是一个已经指向了

229
00:09:11,019 --> 00:09:12,639
那么一个有效的

230
00:09:12,639 --> 00:09:15,438
以前曾经制作出来过的一个数组

231
00:09:15,480 --> 00:09:19,120
那你岂不是先得要去做free的事情吗

232
00:09:19,460 --> 00:09:20,419
对不对

233
00:09:20,419 --> 00:09:23,299
所以与其处理的那么复杂

234
00:09:23,299 --> 00:09:24,259
不如呢

235
00:09:24,279 --> 00:09:24,639
好吧

236
00:09:24,639 --> 00:09:25,539
我们都不要了

237
00:09:25,539 --> 00:09:27,250
我们就做成这样一个create

238
00:09:27,250 --> 00:09:29,059
让它返回一个arr

239
00:09:29,399 --> 00:09:31,590
ok当然你们要理解一件事情

240
00:09:31,590 --> 00:09:32,820
我在这儿说

241
00:09:32,820 --> 00:09:35,789
我现在以这种方式来实现这些东西

242
00:09:35,789 --> 00:09:37,659
这是他的一种可能

243
00:09:37,759 --> 00:09:39,860
这不是他的全部的可能

244
00:09:39,860 --> 00:09:41,840
这也不一定不见得

245
00:09:41,840 --> 00:09:44,240
在所有的情况下是最好的

246
00:09:44,240 --> 00:09:46,619
可能只是我在教你们说

247
00:09:46,619 --> 00:09:48,989
我会用这种方式来做这个事情

248
00:09:48,989 --> 00:09:51,239
我会告诉你们说我怎么想的

249
00:09:51,239 --> 00:09:52,259
在这个过程当中

250
00:09:52,259 --> 00:09:56,600
但是他不见得在你将来所遇到的那种环境

251
00:09:56,600 --> 00:09:58,940
那种场景底下也是最优秀的

252
00:09:58,940 --> 00:10:01,539
你们要理解大学的功课就是这样子

253
00:10:03,820 --> 00:10:07,279
ok接下来我们说free free要做什么

254
00:10:08,500 --> 00:10:11,330
如果我已经有了一个array了

255
00:10:11,330 --> 00:10:14,299
比如说像在我已经create出一个array了

256
00:10:14,299 --> 00:10:18,299
这个array本身这个a本身在离开in的时候

257
00:10:18,480 --> 00:10:20,220
它的空间是会被回收的

258
00:10:20,220 --> 00:10:22,350
因为a本身是一个本地变量

259
00:10:22,350 --> 00:10:25,289
可是a这个结构里面有这个2a

260
00:10:25,289 --> 00:10:27,330
有这个指针所指的那个东西

261
00:10:27,330 --> 00:10:28,889
这个指针所指的那个东西

262
00:10:28,889 --> 00:10:31,110
你需要有恰当的方式去释放它

263
00:10:31,110 --> 00:10:33,759
所以其实在离开这个函数之前

264
00:10:33,759 --> 00:10:36,519
我们应该要去做一次他的free

265
00:10:36,519 --> 00:10:38,779
把那个a交给他

266
00:10:39,320 --> 00:10:41,600
所以这个free要做的事情

267
00:10:41,600 --> 00:10:44,059
其实是针对那个a来说的

268
00:10:44,059 --> 00:10:48,120
所以我们要做的就是free那个a所指的2a

269
00:10:50,000 --> 00:10:51,958
把它给free掉

270
00:10:52,159 --> 00:10:54,440
但做完之后保险起见

271
00:10:54,440 --> 00:10:57,919
我们可以让a的size等于零

272
00:10:59,019 --> 00:11:01,289
当然再保险起见

273
00:11:01,289 --> 00:11:04,938
我们可以做完之后让a的lv呢也等于

274
00:11:05,980 --> 00:11:09,990
为什么这样的话防止别人掉两次对吧

275
00:11:09,990 --> 00:11:11,669
他第二次在做的时候没关系了

276
00:11:11,669 --> 00:11:13,889
因为我们知道我们之前讲到malik的时候

277
00:11:13,889 --> 00:11:15,179
提到过free 0

278
00:11:15,179 --> 00:11:17,139
free now是无害的

279
00:11:17,559 --> 00:11:18,779
ok这是free

