1
00:00:04,339 --> 00:00:05,660
函数的每一次运行

2
00:00:05,660 --> 00:00:08,259
就会产生一个独立的变量空间

3
00:00:08,619 --> 00:00:11,169
在这个变量空间当中的变量

4
00:00:11,169 --> 00:00:14,289
是函数的这一次运行所独有的

5
00:00:14,289 --> 00:00:17,059
那么把它们称作本地变量

6
00:00:18,320 --> 00:00:19,809
从另外角度看

7
00:00:19,809 --> 00:00:22,660
所有我们定义在函数内部的变量

8
00:00:22,660 --> 00:00:23,920
就是本地变量

9
00:00:25,519 --> 00:00:26,500
到目前为止

10
00:00:26,500 --> 00:00:28,089
我们所学过的所有的变量

11
00:00:28,089 --> 00:00:29,859
都是定义在函数内部的变量

12
00:00:29,859 --> 00:00:30,699
我们还没有学过

13
00:00:30,699 --> 00:00:32,649
怎么去定义不在函数内部的变量

14
00:00:32,649 --> 00:00:33,159
对不对

15
00:00:33,159 --> 00:00:35,649
所以我们之前所做的所写的程序里面

16
00:00:35,649 --> 00:00:37,518
所有的变量全部都是本地变量

17
00:00:37,740 --> 00:00:39,240
当然本地变量呃

18
00:00:39,240 --> 00:00:41,640
我们有的时候还会看到不同的教科书

19
00:00:41,640 --> 00:00:42,780
可能会给他不同的名词

20
00:00:42,780 --> 00:00:44,159
比如说有人叫它局部变量

21
00:00:44,159 --> 00:00:46,530
因为英文我们叫做local variables

22
00:00:46,530 --> 00:00:48,240
那么这个local你把它翻译翻译出来

23
00:00:48,240 --> 00:00:50,310
本地也可以把它翻译成局部也可以

24
00:00:50,310 --> 00:00:53,219
然后呢也有的地方会把它叫做自动变量

25
00:00:53,299 --> 00:00:54,439
我的叫做自动变量

26
00:00:54,439 --> 00:00:56,719
是和我们后面讲的一件事情有关系

27
00:00:56,719 --> 00:01:01,509
它的生存期和这个作用域的关系啊

28
00:01:01,509 --> 00:01:02,799
把它叫做自动变量

29
00:01:02,799 --> 00:01:04,599
是因为它的生存期是自动的

30
00:01:04,599 --> 00:01:05,079
这是这一点

31
00:01:05,079 --> 00:01:07,620
我们马上接下来来讲呃

32
00:01:07,620 --> 00:01:08,459
另外还有一件事情

33
00:01:08,459 --> 00:01:11,340
就是我们写在函数的参数表

34
00:01:11,340 --> 00:01:12,480
里面的那些参数

35
00:01:12,480 --> 00:01:14,219
它们也是本地变量

36
00:01:14,219 --> 00:01:17,590
它们和本地变量具有一样的生成器

37
00:01:17,590 --> 00:01:19,618
具有一样的作用域

38
00:01:21,099 --> 00:01:23,219
什么是变量的生存期和作用域呢

39
00:01:23,219 --> 00:01:25,379
生存期是说什么时候开始

40
00:01:25,379 --> 00:01:26,780
这个变量出现了

41
00:01:27,260 --> 00:01:28,879
在这个时刻之前

42
00:01:28,879 --> 00:01:31,189
这个变量没有不存在

43
00:01:31,189 --> 00:01:33,500
到什么时候它消亡了

44
00:01:33,500 --> 00:01:34,400
也就到什么时候

45
00:01:34,400 --> 00:01:36,239
这个变量又不存在了

46
00:01:36,599 --> 00:01:39,819
作用域呢是说在什么范围内

47
00:01:39,819 --> 00:01:41,829
我们可以去访问这个变量

48
00:01:41,829 --> 00:01:43,420
也就是这个变量可以起作用

49
00:01:43,420 --> 00:01:45,219
就是它起作用的领域

50
00:01:45,219 --> 00:01:46,709
所以叫做作用域

51
00:01:46,709 --> 00:01:48,980
那么对于本地变量来说

52
00:01:49,180 --> 00:01:54,019
这两个术语这两个概念它们是统一的

53
00:01:54,500 --> 00:01:57,290
这个统一的答案就是大括号

54
00:01:57,290 --> 00:02:00,170
我们把大括号呢叫做快

55
00:02:00,170 --> 00:02:02,840
我们继续用刚才的sp来研究这件事情

56
00:02:02,840 --> 00:02:06,500
我们知道说对于dbc加加来说呢

57
00:02:06,500 --> 00:02:07,939
他会做这样一件事情

58
00:02:09,459 --> 00:02:11,639
如果这个变量不存在

59
00:02:11,639 --> 00:02:15,580
他会说not found incurrent context

60
00:02:15,580 --> 00:02:16,270
如果存在

61
00:02:16,270 --> 00:02:17,560
那么它会给出值

62
00:02:17,560 --> 00:02:19,240
所以通过这件事情

63
00:02:19,240 --> 00:02:21,528
我们就可以来看一个变量

64
00:02:21,528 --> 00:02:22,938
什么时候开始出现

65
00:02:22,938 --> 00:02:24,079
什么时候消亡

66
00:02:24,079 --> 00:02:26,620
我们看swap里面的x和y

67
00:02:26,819 --> 00:02:29,139
我们重新开始来运行我们的程序

68
00:02:29,379 --> 00:02:32,500
现在我们程序停在这个地方的时候

69
00:02:32,500 --> 00:02:35,020
a和b是我们现在正在命里头

70
00:02:35,020 --> 00:02:36,780
所以a和b是存在的

71
00:02:37,179 --> 00:02:38,979
a和b是存在的

72
00:02:38,979 --> 00:02:41,259
x y还有t都是不存在的

73
00:02:41,259 --> 00:02:44,020
现在我们要进入这个swap函数

74
00:02:44,020 --> 00:02:46,030
我们现在进了这个swap函数了

75
00:02:46,030 --> 00:02:48,009
现在我们的x y是存在的

76
00:02:48,009 --> 00:02:51,438
而我们的a和b就不存在了

77
00:02:51,438 --> 00:02:54,039
因为现在我们在swap里头

78
00:02:54,860 --> 00:02:57,400
现在我们在swap里头的时候

79
00:02:57,400 --> 00:03:00,508
a和b他们还在那里

80
00:03:00,508 --> 00:03:04,019
但是呢我们不能在当前的这个上下文

81
00:03:04,019 --> 00:03:05,219
去访问他们

82
00:03:05,860 --> 00:03:07,770
作为生存来说

83
00:03:07,770 --> 00:03:10,770
他们还在作为作用来说

84
00:03:10,770 --> 00:03:14,719
它们不在当前的作用预览里面了

85
00:03:15,580 --> 00:03:18,780
但是现在呢我们有了x y t

86
00:03:18,780 --> 00:03:22,379
因为我们进了x y t所在的那个大括号

87
00:03:22,379 --> 00:03:24,680
也就是swap这个函数的大括号了

88
00:03:25,219 --> 00:03:28,460
在这个里面我们走啊走啊走啊

89
00:03:28,460 --> 00:03:31,930
走到最后函数的最后我们要离开了

90
00:03:31,930 --> 00:03:33,969
我们离开就回到了main

91
00:03:33,969 --> 00:03:34,990
回到main以后

92
00:03:34,990 --> 00:03:39,180
t x y就都不存在了

93
00:03:39,180 --> 00:03:41,759
就都不存在了啊

94
00:03:42,780 --> 00:03:46,490
当然这个时候呢a和b又回来了

95
00:03:46,490 --> 00:03:51,729
a和b又回到了当前的这个上下文当中啊

96
00:03:51,729 --> 00:03:54,550
我们又进入了a和b的作用域

97
00:03:54,550 --> 00:03:57,159
所以我们又可以去访问a和b

98
00:03:57,159 --> 00:04:00,870
那这个时候x y t它们是不存在了

99
00:04:00,870 --> 00:04:03,650
还是我们仅仅是离开了它的作用域

100
00:04:03,650 --> 00:04:06,169
就好像刚才我们从main进入swap一样呢

101
00:04:06,169 --> 00:04:07,189
它们是不存在的

102
00:04:07,189 --> 00:04:08,960
因为我们已经结束了

103
00:04:08,960 --> 00:04:10,699
那个swap函数的运行

104
00:04:11,139 --> 00:04:13,000
所以我们现在的局面呢是说

105
00:04:13,000 --> 00:04:14,469
在我们这个mean这个地方

106
00:04:14,469 --> 00:04:17,990
它有一个他自己的变量空间

107
00:04:17,990 --> 00:04:19,579
在这个变量空间里面呢

108
00:04:19,579 --> 00:04:22,819
有他自己的a和b跟别人没关系

109
00:04:23,000 --> 00:04:24,379
现在当我们做到这一步

110
00:04:24,379 --> 00:04:26,360
我们要去做swap ab的时候呢

111
00:04:26,360 --> 00:04:29,620
他就要转身去调那个swap

112
00:04:29,740 --> 00:04:31,720
当他转身去调那个swap

113
00:04:31,720 --> 00:04:33,310
进入到swap的时候呢

114
00:04:33,310 --> 00:04:36,160
我们的swap也有自己的一个变量空间

115
00:04:36,160 --> 00:04:39,740
那里头有他的a有他的b有他的t

116
00:04:40,540 --> 00:04:42,959
当我们离开main函数

117
00:04:42,959 --> 00:04:45,240
去调用swap函数的时候

118
00:04:45,240 --> 00:04:47,040
我们是要离开in的

119
00:04:47,040 --> 00:04:49,930
离开什么就是离开它的变量空间

120
00:04:49,930 --> 00:04:51,730
我们不再在这个空间里了

121
00:04:51,730 --> 00:04:53,110
我们现在在这个空间里了

122
00:04:53,110 --> 00:04:53,829
在main函数里面

123
00:04:53,829 --> 00:04:55,290
我们在内main函数

124
00:04:55,290 --> 00:04:55,829
在main函数里面

125
00:04:55,829 --> 00:04:56,970
我们在main函数的变量空间

126
00:04:56,970 --> 00:04:57,569
在缩盘数

127
00:04:57,569 --> 00:04:58,990
我们在sp函数的变量空间

128
00:04:58,990 --> 00:05:00,550
所以当我们正在这里做事情

129
00:05:00,550 --> 00:05:02,110
做这个做这个做这个的时候

130
00:05:02,110 --> 00:05:03,670
我们用到的a我们用到的b

131
00:05:03,670 --> 00:05:05,290
我们用到的t都是我们自己的

132
00:05:05,290 --> 00:05:09,529
a b t和命里面的ab没有任何关系

133
00:05:09,529 --> 00:05:11,810
因此我们在这儿怎么对a赋值

134
00:05:11,810 --> 00:05:12,769
怎么对b赋值

135
00:05:12,769 --> 00:05:14,449
都不会影响这里的a和b

136
00:05:14,449 --> 00:05:16,459
因为他们不在一起

137
00:05:17,120 --> 00:05:19,819
当我们从swap函数做完

138
00:05:19,819 --> 00:05:21,740
我们要从这里回去的时候

139
00:05:21,740 --> 00:05:23,269
我们的swap就没有了

140
00:05:23,269 --> 00:05:25,089
它的变量空间就没有了

141
00:05:25,089 --> 00:05:27,399
我们回到main里面的a和b

142
00:05:27,399 --> 00:05:30,250
还是在原来他的那个变量空间里面的

143
00:05:30,250 --> 00:05:34,379
a和b那本地变量有些什么样的规则呢

144
00:05:34,899 --> 00:05:38,699
第一条规则是本地变量是定义在块内的

145
00:05:38,699 --> 00:05:40,259
这个快我们刚才说了

146
00:05:40,259 --> 00:05:41,279
就是大括号

147
00:05:41,279 --> 00:05:44,620
那么这个块呢可以是函数的块内

148
00:05:44,920 --> 00:05:46,720
可以是语句的话

149
00:05:46,720 --> 00:05:48,129
那我们来看

150
00:05:48,129 --> 00:05:51,459
如果呢我们在这个swap后头呢来一句

151
00:05:51,459 --> 00:05:54,819
说if a小于b

152
00:05:56,620 --> 00:05:58,300
然后我们就有了一对大括号

153
00:05:58,300 --> 00:05:58,660
对不对

154
00:05:58,660 --> 00:06:00,019
在这对大括号里面

155
00:06:00,478 --> 00:06:01,798
在这个大括号里边

156
00:06:01,798 --> 00:06:02,879
你就可以定义变量

157
00:06:02,879 --> 00:06:06,160
说int int i等于十

158
00:06:08,459 --> 00:06:10,850
那么这个情况下呢

159
00:06:10,850 --> 00:06:15,139
这个i就是定义在这个块里头的变量

160
00:06:15,300 --> 00:06:17,360
定在这个块里头的变量

161
00:06:17,360 --> 00:06:21,410
它的生存期和作用域就在这个块里头

162
00:06:21,410 --> 00:06:22,279
换句话说

163
00:06:22,279 --> 00:06:23,180
在这个块里头

164
00:06:23,180 --> 00:06:24,230
这个i是存在的

165
00:06:24,230 --> 00:06:26,759
离开这个快这个i就不存在了

166
00:06:26,839 --> 00:06:29,000
那么因为这是个条件语句

167
00:06:29,000 --> 00:06:29,449
对不对

168
00:06:29,449 --> 00:06:31,540
那就意味着程序的每次运行

169
00:06:32,000 --> 00:06:33,500
这个i存在不存在

170
00:06:33,500 --> 00:06:36,110
取决于a和b大小的关系

171
00:06:36,110 --> 00:06:37,040
换句话说

172
00:06:37,040 --> 00:06:38,750
不是每一次进这个may

173
00:06:38,750 --> 00:06:41,959
这个i都一定会有的啊

174
00:06:41,959 --> 00:06:43,430
它的生存期和作用域

175
00:06:43,430 --> 00:06:45,879
就受限于这个大括号了

176
00:06:45,959 --> 00:06:48,750
如果在这个括号的外面

177
00:06:48,750 --> 00:06:50,550
我们想要去使用那个i

178
00:06:50,550 --> 00:06:53,579
比如我们想说i加加编译

179
00:06:53,579 --> 00:06:55,860
我们就会得到错误说

180
00:06:57,860 --> 00:06:59,680
under decade

181
00:06:59,680 --> 00:07:01,139
没声明过

182
00:07:01,800 --> 00:07:03,079
明明我们i有的

183
00:07:03,079 --> 00:07:03,439
对不对

184
00:07:03,439 --> 00:07:06,800
可是那个i是在另外的一个大括号里面

185
00:07:06,800 --> 00:07:07,519
除了这个大括号

186
00:07:07,519 --> 00:07:08,600
这个i就不存在了

187
00:07:08,600 --> 00:07:09,860
你就不能再用它了

188
00:07:09,978 --> 00:07:13,338
甚至我们可以随便拿一堆大框来定义变量

189
00:07:13,338 --> 00:07:14,478
这事儿都是行的

190
00:07:14,478 --> 00:07:16,480
你看我们可以这么干

191
00:07:16,480 --> 00:07:17,920
在这儿来一堆大括号

192
00:07:17,920 --> 00:07:21,459
说这儿我们有一个int i等于零

193
00:07:22,939 --> 00:07:24,339
没任何问题

194
00:07:24,339 --> 00:07:25,899
在这个大括号里头

195
00:07:25,899 --> 00:07:27,220
这个i可以参与运算

196
00:07:27,220 --> 00:07:28,339
可以输出

197
00:07:28,560 --> 00:07:30,000
没有任何问题

198
00:07:30,680 --> 00:07:33,040
这一对大括号它没有依附于任何语句

199
00:07:33,040 --> 00:07:34,480
但是对于c语言来说

200
00:07:34,480 --> 00:07:36,500
这是合理的一种写法

201
00:07:36,500 --> 00:07:39,800
程序进入这个块之前当中的变量不存在

202
00:07:39,800 --> 00:07:43,629
离开这个快当中的变量呢也消失了

203
00:07:43,629 --> 00:07:46,509
我们可以来再来看看这件事情

204
00:07:46,509 --> 00:07:49,149
我们知道现在a是小于b的

205
00:07:49,149 --> 00:07:50,470
sb不会去交做交换

206
00:07:50,470 --> 00:07:52,478
所以我们把这个断点去掉

207
00:07:52,478 --> 00:07:53,678
我们在这设个断点

208
00:07:53,678 --> 00:07:55,988
我们可以看看进入这个之前i在不在

209
00:07:55,988 --> 00:07:57,038
离开这个之后

210
00:07:57,038 --> 00:07:57,939
i还有没有

211
00:07:57,939 --> 00:08:00,339
我们把这个给这句给删了哈

212
00:08:00,339 --> 00:08:02,399
我们来调试运行

213
00:08:02,519 --> 00:08:03,810
现在我们在这儿

214
00:08:03,810 --> 00:08:05,819
现在呢a和b都是有的

215
00:08:05,819 --> 00:08:08,680
现在的i呢not found好

216
00:08:08,680 --> 00:08:11,680
然后我们下一步下一步我们就进去了

217
00:08:11,680 --> 00:08:13,100
现在i就有值了

218
00:08:13,339 --> 00:08:14,480
没有初始化嘛

219
00:08:14,480 --> 00:08:17,509
所以在在做这个i的触发之前

220
00:08:17,509 --> 00:08:19,519
i这个变量已经存在了

221
00:08:19,538 --> 00:08:21,579
现在他是一个乱七八糟的纸

222
00:08:21,579 --> 00:08:22,088
对不对

223
00:08:22,088 --> 00:08:25,079
然后下一步下一步我们就离开了

224
00:08:25,079 --> 00:08:26,819
这个时候i还在不在呢

225
00:08:26,819 --> 00:08:29,620
not found incurrent context啊

226
00:08:29,620 --> 00:08:31,300
所以它的作用域

227
00:08:31,300 --> 00:08:34,578
它的生存期就仅仅限于你对他括号

228
00:08:34,860 --> 00:08:37,080
但是在快外面定义的变量

229
00:08:37,080 --> 00:08:38,639
在快的里面仍然有效

230
00:08:38,639 --> 00:08:39,870
这句话什么意思呢

231
00:08:39,870 --> 00:08:42,099
我们在这里头有一个快

232
00:08:42,159 --> 00:08:43,779
我们在外面定义了a和b

233
00:08:43,779 --> 00:08:45,370
a和b在里面有没有用呢

234
00:08:45,370 --> 00:08:48,599
如果我们现在让他来输出a的值

235
00:08:50,440 --> 00:08:51,389
没问题

236
00:08:51,389 --> 00:08:53,318
他输出了这个a的值五

237
00:08:53,440 --> 00:08:58,269
所以在外面定义的变量到里面仍然存在

238
00:08:58,269 --> 00:09:01,879
里面定义的变量出来到外面就不存在了

239
00:09:02,019 --> 00:09:05,169
如果在块里面定义了和外面同名的变量

240
00:09:05,169 --> 00:09:06,879
就把外面的给掩盖了

241
00:09:06,879 --> 00:09:07,960
这句话什么意思呢

242
00:09:07,960 --> 00:09:11,220
如果我在这儿也定义一个a

243
00:09:11,220 --> 00:09:13,120
你觉得编译会过吗

244
00:09:13,399 --> 00:09:16,220
编译过了运行结果这个a是多少呢

245
00:09:16,220 --> 00:09:17,840
好我们在这儿来一个a

246
00:09:17,840 --> 00:09:19,519
等于看起来明白一点

247
00:09:19,519 --> 00:09:20,919
a等于零

248
00:09:21,700 --> 00:09:22,590
也就是说

249
00:09:22,590 --> 00:09:25,320
因为我们在这个更加里面的块里面

250
00:09:25,320 --> 00:09:27,330
定义了一个和外面同名的变量

251
00:09:27,330 --> 00:09:28,860
那么在这个块里面

252
00:09:28,860 --> 00:09:31,828
这个a就是他自己的那个a

253
00:09:31,828 --> 00:09:32,788
当然出来以后

254
00:09:32,788 --> 00:09:34,168
因为里面这个a不存在了

255
00:09:34,168 --> 00:09:36,028
所以外面这一句在输出的时候

256
00:09:36,028 --> 00:09:37,458
这个a呢还是那个五

257
00:09:38,440 --> 00:09:40,899
这个事情蛮令人惊讶的

258
00:09:40,899 --> 00:09:41,578
对不对

259
00:09:41,639 --> 00:09:44,759
你在一个比较深入的小

260
00:09:44,759 --> 00:09:48,100
更小范围的大括号里面那个块里面

261
00:09:48,100 --> 00:09:49,899
你可以定义一个和外面透明的变量

262
00:09:49,899 --> 00:09:51,279
然后把外面给盖住

263
00:09:51,279 --> 00:09:54,000
不是所有的编程人员都是这么干的

264
00:09:54,620 --> 00:09:56,659
比如说java语言就不是这么干的

265
00:09:56,940 --> 00:09:58,259
虽然外呃

266
00:09:58,259 --> 00:10:00,480
虽然在块里面可以定义和外面同名的变量

267
00:10:00,480 --> 00:10:02,580
但是呢在同一个块里头

268
00:10:02,580 --> 00:10:03,899
你不能去定义同名的变量

269
00:10:03,899 --> 00:10:04,850
我们来试一下

270
00:10:04,850 --> 00:10:06,350
如果现在这儿在这儿

271
00:10:06,350 --> 00:10:07,370
我们再定义一个a

272
00:10:09,649 --> 00:10:13,190
编译的时候会说redefinition啊

273
00:10:13,190 --> 00:10:15,019
a重新定义了

274
00:10:15,019 --> 00:10:16,200
这是不行的

275
00:10:16,200 --> 00:10:17,700
还有一个事情我们都知道了

276
00:10:17,700 --> 00:10:20,159
本地变量不会被默认初始化啊

277
00:10:20,159 --> 00:10:22,299
它不会得到一个默认的初始的值

278
00:10:22,440 --> 00:10:25,320
我们在第六周的这个测验里头

279
00:10:25,320 --> 00:10:27,059
都给出了这样的题目对吧

280
00:10:27,059 --> 00:10:30,078
这个这个变量k它会得到一个任意的值

281
00:10:30,919 --> 00:10:33,019
而参数会不一样

282
00:10:33,019 --> 00:10:35,690
参数在进入函数的时候会被初始化

283
00:10:35,690 --> 00:10:39,049
你调用函数的时候一定要给参数对应的值

284
00:10:39,049 --> 00:10:40,850
那个值就会在进入函数的时候

285
00:10:40,850 --> 00:10:42,049
用来初始化参数

286
00:10:42,049 --> 00:10:43,440
所以这是不同的

