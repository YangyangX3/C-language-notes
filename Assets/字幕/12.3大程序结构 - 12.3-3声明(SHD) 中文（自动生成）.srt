1
00:00:04,459 --> 00:00:07,280
饺子整个项目当中啊

2
00:00:07,280 --> 00:00:09,859
某个呃源代码文件

3
00:00:09,859 --> 00:00:11,949
某个编译单元里面有个全局变量

4
00:00:11,949 --> 00:00:14,050
在别的地方想要使用这个群变量

5
00:00:14,050 --> 00:00:14,769
要怎么做呢

6
00:00:14,769 --> 00:00:17,739
比如说呃如果我们的这个max.c里头

7
00:00:17,739 --> 00:00:19,210
我们在这里有一个全局变量

8
00:00:19,210 --> 00:00:20,859
比如说这个int的g2 

9
00:00:21,300 --> 00:00:23,609
它有个初始值12啊

10
00:00:23,609 --> 00:00:26,498
如果我们想要在命点c里面

11
00:00:26,498 --> 00:00:28,539
也也要能够访问到那个g2 

12
00:00:28,539 --> 00:00:31,298
比如说我们想这个调用的时候呢

13
00:00:31,298 --> 00:00:34,759
这是用g2 a和gr去做比较是吧

14
00:00:34,759 --> 00:00:39,320
那么这个时候怎么能够让这个编译器知道

15
00:00:39,320 --> 00:00:41,119
这个吉奥是什么呢

16
00:00:41,700 --> 00:00:44,000
我们在这儿写下的这句话

17
00:00:44,000 --> 00:00:46,909
这是一个变量的定义

18
00:00:46,909 --> 00:00:49,250
我们定义说在max.c里头

19
00:00:49,250 --> 00:00:51,109
我们有这样一个全局变量

20
00:00:51,109 --> 00:00:52,909
那么到了main这边呢

21
00:00:52,909 --> 00:00:55,030
我们需要有一个声明

22
00:00:55,030 --> 00:00:57,369
我们需要有一个东西来声明说

23
00:00:57,369 --> 00:01:02,098
在项目的某处有那么一个全局变量

24
00:01:02,259 --> 00:01:05,620
就好像我们的这个max.h里面给出了

25
00:01:05,620 --> 00:01:08,560
说我们的这个max函数长这个样子

26
00:01:08,560 --> 00:01:09,549
这是一个声明

27
00:01:09,549 --> 00:01:12,000
它对应的定义在这儿

28
00:01:12,000 --> 00:01:13,079
这是它的定义

29
00:01:13,079 --> 00:01:16,920
那我们怎么去给出那个全局变量的

30
00:01:16,920 --> 00:01:18,480
一个声明呢

31
00:01:18,480 --> 00:01:20,219
我们的写法是这样的

32
00:01:20,219 --> 00:01:25,569
我们需要在这儿说我们有一个extern

33
00:01:25,569 --> 00:01:27,140
int g2 

34
00:01:27,659 --> 00:01:30,000
这个extern的关键词加在这

35
00:01:30,000 --> 00:01:34,510
就形成说我们告诉编译器呢

36
00:01:34,510 --> 00:01:36,549
在整个项目的某个地方

37
00:01:36,549 --> 00:01:38,420
有个叫做gr的东西

38
00:01:39,859 --> 00:01:41,769
然后呢这样子的话呢

39
00:01:41,769 --> 00:01:43,540
编译器在编译到这个东西的时候

40
00:01:43,540 --> 00:01:44,500
才会理解说哦

41
00:01:44,500 --> 00:01:45,909
只要是个int

42
00:01:45,909 --> 00:01:49,819
所以呢我要为这个int怎么调入到max里头

43
00:01:49,819 --> 00:01:51,439
去做一些相应的准备

44
00:01:51,439 --> 00:01:53,379
如果我们没有这句话

45
00:01:53,519 --> 00:01:55,618
那编译的时候呢

46
00:01:58,280 --> 00:02:00,700
编译器就会说诶这个吉奥啊

47
00:02:00,700 --> 00:02:01,510
没声明过

48
00:02:01,510 --> 00:02:03,159
不知道吉奥是什么

49
00:02:03,799 --> 00:02:05,319
我们有了这句话以后

50
00:02:07,900 --> 00:02:09,159
编辑就知道了

51
00:02:13,379 --> 00:02:15,409
ok我们编译就能过了对吧

52
00:02:15,409 --> 00:02:17,060
然后因为这个只要是12码

53
00:02:17,060 --> 00:02:18,319
显然比a要来的大马呢

54
00:02:18,319 --> 00:02:21,409
我们可以想见执行的结果肯定是二点啊

55
00:02:21,409 --> 00:02:22,520
这是没有问题了

56
00:02:22,520 --> 00:02:26,019
所以如果我们普通的写下一个变量

57
00:02:26,019 --> 00:02:27,900
那么这是变量的定义

58
00:02:28,299 --> 00:02:30,399
在这个前面加上extern

59
00:02:30,399 --> 00:02:32,620
它就成了一个变量的声明

60
00:02:32,939 --> 00:02:34,319
定义和声明

61
00:02:34,319 --> 00:02:36,689
在c语言当中是两种不同的东西

62
00:02:36,689 --> 00:02:40,189
函数的定义是定义函数的原形是声明

63
00:02:40,189 --> 00:02:43,669
变量的定义是定义extern的变量的声明

64
00:02:43,669 --> 00:02:44,979
那是一个声明

65
00:02:45,039 --> 00:02:46,300
当然作为声明

66
00:02:46,300 --> 00:02:47,500
你在写extern的时候

67
00:02:47,500 --> 00:02:49,210
你后面不能给他初始化对吧

68
00:02:49,210 --> 00:02:51,500
因为初始化那是定义的一方做的事情

69
00:02:52,759 --> 00:02:57,269
在c语言当中的声明是不产生代码的东西

70
00:02:57,269 --> 00:02:58,649
比如说函数原型啊

71
00:02:58,649 --> 00:02:59,848
变量的声明啊

72
00:02:59,848 --> 00:03:01,438
也就加了东西啊

73
00:03:01,438 --> 00:03:02,680
结构的声明

74
00:03:02,680 --> 00:03:03,819
红的声明

75
00:03:03,819 --> 00:03:04,659
枚举的声明

76
00:03:04,659 --> 00:03:05,319
类型的声明

77
00:03:05,319 --> 00:03:06,370
typedef的东西

78
00:03:06,370 --> 00:03:08,740
还有我们没讲的in line函数

79
00:03:08,740 --> 00:03:10,780
这些都是叫做声明

80
00:03:10,780 --> 00:03:14,430
而定义呢是和他们相对会产生代码的东西

81
00:03:14,430 --> 00:03:18,569
比如说函数全局变量没了

82
00:03:18,569 --> 00:03:19,560
就这两种

83
00:03:19,560 --> 00:03:21,780
这两种是会产生代码的东西

84
00:03:21,780 --> 00:03:23,969
除此以外都是不会产生代码的东西

85
00:03:23,969 --> 00:03:25,979
什么叫做不会产生代码的东西

86
00:03:25,979 --> 00:03:29,280
就是编译器看到你的一个声明

87
00:03:29,280 --> 00:03:31,319
其实他并不为你去产生代码

88
00:03:31,319 --> 00:03:33,599
而是把这个声明自己默默地记下来

89
00:03:33,659 --> 00:03:35,250
他有个小抄本的

90
00:03:35,250 --> 00:03:36,840
你说有个extern int

91
00:03:36,840 --> 00:03:39,879
ok它抄下来那句extern int的意思

92
00:03:39,879 --> 00:03:41,080
就告诉别人去说

93
00:03:41,080 --> 00:03:44,500
我知道在这个项目的某个地方

94
00:03:44,500 --> 00:03:48,000
有那么个g2 那个东西我不知道他在哪儿

95
00:03:48,000 --> 00:03:48,719
反正他肯定在

96
00:03:48,719 --> 00:03:51,419
你相信我就好了啊

97
00:03:51,419 --> 00:03:52,539
这叫做声明

98
00:03:53,699 --> 00:03:55,580
那对于头文件来说

99
00:03:55,580 --> 00:03:57,080
我们有一个规则

100
00:03:57,080 --> 00:03:59,979
只有声明才可以被放在头文件里头

101
00:04:00,338 --> 00:04:02,199
但是这是规则

102
00:04:02,199 --> 00:04:03,308
不是法律

103
00:04:03,308 --> 00:04:04,929
如果你不是这么做

104
00:04:04,929 --> 00:04:07,299
你你在头文件里面放的不是声明

105
00:04:07,299 --> 00:04:10,069
而是定义会造成问题的

106
00:04:10,069 --> 00:04:13,370
类似的一个问题是在同一个编译单元里面

107
00:04:13,370 --> 00:04:16,439
同名的结构不能够被重复的声明

108
00:04:16,579 --> 00:04:19,488
如果你的头文件里面有结构的声明

109
00:04:19,488 --> 00:04:21,139
那很难做到

110
00:04:21,139 --> 00:04:23,718
这个头文件不会在一个编译单元里面

111
00:04:23,718 --> 00:04:25,100
被include多次

112
00:04:25,180 --> 00:04:26,860
为什么会出现这种情况呢

113
00:04:26,860 --> 00:04:27,639
我们来试一下

114
00:04:27,639 --> 00:04:29,879
看我们先来试这件事情

115
00:04:29,879 --> 00:04:32,040
假如说我们在这儿定义了一个struck

116
00:04:32,040 --> 00:04:33,000
比如说叫做node

117
00:04:33,000 --> 00:04:35,980
然后呢里面有个int value

118
00:04:37,000 --> 00:04:39,459
然后可能还有一个char的心

119
00:04:39,459 --> 00:04:40,860
叫做name啊

120
00:04:40,860 --> 00:04:41,850
比如说是这样子

121
00:04:41,850 --> 00:04:44,358
然后呢如果单纯是这样

122
00:04:44,358 --> 00:04:45,499
当然不会有问题

123
00:04:45,499 --> 00:04:48,019
如果我们在一个点

124
00:04:48,019 --> 00:04:50,879
c里面放了两个这样的东西

125
00:04:51,579 --> 00:04:53,220
那编译的时候呢

126
00:04:55,819 --> 00:04:59,800
他会说这个东西啊重复定义了啊

127
00:04:59,800 --> 00:05:01,600
这个结构呢重复定义了

128
00:05:01,600 --> 00:05:03,579
也就是说在一个点c里头啊

129
00:05:03,579 --> 00:05:06,600
你不能够让一个结构的声明出现两次

130
00:05:06,600 --> 00:05:08,279
可是怎么会出现两次呢

131
00:05:08,279 --> 00:05:09,420
如果放在这儿

132
00:05:09,420 --> 00:05:10,740
当然不会出现两次是吧

133
00:05:10,740 --> 00:05:13,798
假如说我们现在呢是这样

134
00:05:13,798 --> 00:05:16,678
我们把这部分东西呢放到头文件里头去

135
00:05:16,678 --> 00:05:19,079
因为这是一个很多地方可能用到的

136
00:05:19,079 --> 00:05:21,560
所以呢比如说我们都放到max点区里头去了

137
00:05:22,660 --> 00:05:25,620
ok啊这应该也不会有问题对吧

138
00:05:25,620 --> 00:05:26,699
然后呢我们在这儿

139
00:05:26,699 --> 00:05:27,389
当然他呃

140
00:05:27,389 --> 00:05:30,279
我们就不需要再在这里继续有这个东西

141
00:05:30,279 --> 00:05:31,750
我们就including max

142
00:05:31,750 --> 00:05:33,459
我们就可以用这个strong node了

143
00:05:34,379 --> 00:05:37,769
假如现在局面是说我们还有另外一个点

144
00:05:37,769 --> 00:05:38,550
这很正常

145
00:05:38,550 --> 00:05:39,810
比如说我们有另外一个点c

146
00:05:39,810 --> 00:05:41,610
所以它会有对应的另外一个点h

147
00:05:41,610 --> 00:05:44,279
我们新建一个源代码

148
00:05:46,439 --> 00:05:50,920
比如说我们把它叫做命点h

149
00:05:52,779 --> 00:05:55,680
然后呢命点一曲里面呢做了一件事情

150
00:05:55,680 --> 00:05:58,658
我们在命点一曲里面去include max点

151
00:05:58,658 --> 00:06:00,218
这也很常见啊

152
00:06:00,218 --> 00:06:01,478
比如说我们在命点一句里面

153
00:06:01,478 --> 00:06:04,790
要用到那个jnload等等之类的事情好

154
00:06:04,790 --> 00:06:06,920
然后我们在命点c里面

155
00:06:06,920 --> 00:06:08,959
原本已经include max h了

156
00:06:08,959 --> 00:06:12,439
我们又include了一下命点h

157
00:06:14,540 --> 00:06:16,000
这时候会发生什么事呢

158
00:06:16,000 --> 00:06:18,220
因为我们知道include做的事情是文本插入

159
00:06:18,220 --> 00:06:18,730
对不对

160
00:06:18,730 --> 00:06:21,899
我们可以在这里想象说

161
00:06:21,899 --> 00:06:25,810
我们这一句max include max点会做的事情呢

162
00:06:25,810 --> 00:06:28,029
就会在这儿把max点进去

163
00:06:28,029 --> 00:06:29,529
里面所有东西都插进来

164
00:06:29,529 --> 00:06:32,769
所以呢我们会在这里得到了这个

165
00:06:32,769 --> 00:06:33,519
对不对

166
00:06:33,519 --> 00:06:36,009
然后我们要include mdh

167
00:06:36,009 --> 00:06:38,050
而mdh要做这么一件事情

168
00:06:38,050 --> 00:06:39,250
include max h

169
00:06:39,250 --> 00:06:42,490
所以呢就相当于我们在这儿有了一句这个

170
00:06:42,490 --> 00:06:43,420
而这一句呢

171
00:06:43,420 --> 00:06:44,199
又相当于

172
00:06:44,199 --> 00:06:49,579
我们把这些东西又都拿进来了一遍

173
00:06:50,600 --> 00:06:54,040
那现在我们这个代码不就是在这个点

174
00:06:54,040 --> 00:06:55,720
c里面有两个struct吗

175
00:06:56,120 --> 00:07:01,220
好我们可以把这些演示的东西都拿掉

176
00:07:01,220 --> 00:07:03,358
然后我们可以试一下

177
00:07:03,358 --> 00:07:05,620
如果我现在来编译这个程序

178
00:07:09,680 --> 00:07:12,779
他会告诉你诶这个里面呢

179
00:07:16,019 --> 00:07:20,000
命点c里面所include那个命点h里面呢

180
00:07:20,000 --> 00:07:21,920
重复定义了struct node

181
00:07:22,860 --> 00:07:23,779
所以

182
00:07:27,480 --> 00:07:28,730
你可能会说哦

183
00:07:28,730 --> 00:07:30,680
那那那我要避免做这样的事情了

184
00:07:30,680 --> 00:07:32,750
但是你很难避免做这样的事情

185
00:07:32,750 --> 00:07:34,908
我们现在应用程序结构还很简单

186
00:07:34,908 --> 00:07:36,798
当你程序结构复杂了之后

187
00:07:41,829 --> 00:07:43,420
这个混合的放在一起

188
00:07:43,420 --> 00:07:46,540
你很难避免出现这样的重复引用的事情

189
00:07:46,540 --> 00:07:50,430
所以呢传统上我们需要做这样一件事情

190
00:07:50,430 --> 00:07:52,290
我们需要引入一种东西

191
00:07:52,290 --> 00:07:54,149
叫做标准头文件结构

192
00:07:54,149 --> 00:07:56,790
我们需要在max.h里面呢放上这么几句话

193
00:07:56,790 --> 00:08:01,180
说if n d f max h

194
00:08:02,860 --> 00:08:04,819
那我们就define max

195
00:08:08,079 --> 00:08:11,848
最后呢来个e d f

196
00:08:11,848 --> 00:08:13,379
这是什么呢

197
00:08:13,420 --> 00:08:16,680
这是一个条件编译指令

198
00:08:16,680 --> 00:08:18,990
同样这是p这是punch开头的

199
00:08:18,990 --> 00:08:21,750
这还是呃预编预处理指令对吧

200
00:08:21,750 --> 00:08:24,499
他说呢如果没有定义这个红的话

201
00:08:24,499 --> 00:08:26,449
那么我们就定义这个红

202
00:08:26,449 --> 00:08:28,339
然后这是e d f

203
00:08:28,339 --> 00:08:30,740
所以如果已经定义了这个红的话

204
00:08:30,740 --> 00:08:32,539
那么这些东西呢

205
00:08:32,539 --> 00:08:36,970
就不会出现在你的点i文件里头

206
00:08:36,970 --> 00:08:37,600
你还记得吧

207
00:08:37,600 --> 00:08:39,700
我们的点c先经过编译处理

208
00:08:39,700 --> 00:08:40,779
形成点i文件

209
00:08:40,779 --> 00:08:41,860
编译预处理的时候

210
00:08:41,860 --> 00:08:44,620
会看这个东西有没有存在过

211
00:08:44,620 --> 00:08:45,639
有没有存在

212
00:08:45,639 --> 00:08:46,240
指的是什么呢

213
00:08:46,240 --> 00:08:48,429
我们前面在说我们的编译器

214
00:08:48,429 --> 00:08:50,950
同一个时间只编译一个点c文件的

215
00:08:50,950 --> 00:08:52,600
所以有没有存在过

216
00:08:52,600 --> 00:08:54,970
是指在这个点c里头有没有存在过

217
00:08:54,970 --> 00:08:56,629
因此回到main这里来

218
00:08:56,629 --> 00:09:00,230
我们在include max.h的时候

219
00:09:00,230 --> 00:09:02,159
它会include进来的东西

220
00:09:07,039 --> 00:09:07,840
是这么多

221
00:09:09,039 --> 00:09:11,019
因此我们从头往下看呢

222
00:09:11,019 --> 00:09:13,600
第一个这个if n define

223
00:09:13,600 --> 00:09:15,580
如果没有定义过这个这个条件是成立的

224
00:09:15,580 --> 00:09:16,840
因为我们确实没有定义过

225
00:09:16,840 --> 00:09:18,240
于是呢我们就定义了这个

226
00:09:18,240 --> 00:09:20,279
然后呢我们就有了这一堆东西

227
00:09:20,279 --> 00:09:21,828
一直到emd f为止

228
00:09:21,828 --> 00:09:24,349
接下来我们要去include命点点h

229
00:09:24,349 --> 00:09:25,609
里面会include max.h

230
00:09:25,609 --> 00:09:28,059
于是他又会把这一段东西拿进来

231
00:09:28,220 --> 00:09:30,769
现在对于整个点c来说

232
00:09:30,769 --> 00:09:32,690
我们再从头往后看

233
00:09:32,690 --> 00:09:36,169
在第三行我们发现说max h没有定义过

234
00:09:36,169 --> 00:09:37,549
于是我们定义了max.h

235
00:09:37,549 --> 00:09:40,259
于是在第四行我们就有了max h

236
00:09:40,320 --> 00:09:41,940
在地图上有了max点进去

237
00:09:41,940 --> 00:09:44,059
这个这个宏定义之后

238
00:09:44,299 --> 00:09:46,100
到了这一行

239
00:09:46,100 --> 00:09:46,789
第17行

240
00:09:46,789 --> 00:09:50,210
它来判断说如果没有定义过max h的话

241
00:09:50,210 --> 00:09:52,620
现在这个条件是否定的

242
00:09:52,799 --> 00:09:55,620
因此呢从这一行往下

243
00:09:55,620 --> 00:09:58,529
一直到他的那个e n d e f为止

244
00:09:58,529 --> 00:10:02,659
所有的这些东西就不会出现在点i里头

245
00:10:02,659 --> 00:10:04,340
也就不会被编译了

246
00:10:05,480 --> 00:10:06,230
这样的话呢

247
00:10:06,230 --> 00:10:10,620
就可以避免头文件里面有重复引用的情况

248
00:10:10,620 --> 00:10:13,379
我们把这些演示用的代码去掉

249
00:10:13,379 --> 00:10:15,919
我们再来看一下现在编译是不是对呢

250
00:10:17,559 --> 00:10:19,080
我们include max

251
00:10:19,080 --> 00:10:20,279
在include main

252
00:10:20,279 --> 00:10:22,860
但是max呢已经加了标准通文件结构

253
00:10:22,860 --> 00:10:23,399
来做保护

254
00:10:23,399 --> 00:10:25,458
现在我们再来编译

255
00:10:27,299 --> 00:10:28,698
就没有问题了

256
00:10:28,940 --> 00:10:31,279
所以这个就叫做标准头文件结构啊

257
00:10:31,279 --> 00:10:33,139
呃通常呢我们就把它写成这个样子

258
00:10:33,139 --> 00:10:34,940
就是什么什么h啊

259
00:10:34,940 --> 00:10:36,519
然后带上翅膀啊

260
00:10:36,519 --> 00:10:37,539
前后两个下划线

261
00:10:37,539 --> 00:10:39,039
主要是为了保证这样的名字

262
00:10:39,039 --> 00:10:41,860
不可能和你正常要用到的这个红的名字

263
00:10:41,860 --> 00:10:42,759
重复是吧

264
00:10:42,759 --> 00:10:44,730
然后呢if undefine defined

265
00:10:44,730 --> 00:10:47,600
最后呢and if那这个叫做标准头文件结构

266
00:10:47,600 --> 00:10:49,639
这样呢就能够保证这个头文件

267
00:10:49,639 --> 00:10:51,259
在一个点c文件当中

268
00:10:51,259 --> 00:10:53,240
在一个编译的两个单元当中呢

269
00:10:53,240 --> 00:10:55,259
只会被include一次

270
00:10:55,399 --> 00:10:57,440
当然有的同学会发现说

271
00:10:57,440 --> 00:10:59,240
visual studio呢会支持另外一种写法

272
00:10:59,240 --> 00:11:00,639
叫做programa wants

273
00:11:00,639 --> 00:11:02,139
它也能够起到相同的作用

274
00:11:02,139 --> 00:11:03,580
但是不是所有的编译器都支持

275
00:11:03,580 --> 00:11:05,899
比如说gcc某些版本就是不支持的

276
00:11:06,059 --> 00:11:08,639
所以呢呃更通用的办法就是用这个

277
00:11:08,639 --> 00:11:09,539
if define

278
00:11:09,539 --> 00:11:11,220
if undefine define啊

279
00:11:11,220 --> 00:11:13,139
用这个我们叫做标准头文件结构

