1
00:00:04,500 --> 00:00:05,359
搜索

2
00:00:05,419 --> 00:00:09,380
这是现代计算机或者说互联网上面

3
00:00:09,380 --> 00:00:11,060
频繁在发生的事情

4
00:00:11,060 --> 00:00:14,900
人们广泛的在使用计算机在做搜索的事情

5
00:00:15,039 --> 00:00:18,519
我们来看看最最最最基本最简单的搜索

6
00:00:18,519 --> 00:00:19,210
要怎么去做

7
00:00:19,210 --> 00:00:22,079
如果我现在有一组数据了

8
00:00:23,600 --> 00:00:26,140
我要根据用户的输入来决定说

9
00:00:26,140 --> 00:00:27,820
它的输入的这个数字

10
00:00:27,820 --> 00:00:29,440
在不在我这组数据里头

11
00:00:29,440 --> 00:00:31,379
我要怎么写出的程序来

12
00:00:31,899 --> 00:00:34,000
我们来看一个线程写好的代码

13
00:00:34,000 --> 00:00:37,560
我们在命里面定义了一个数组

14
00:00:37,560 --> 00:00:39,420
可是这个数组的定义的样子

15
00:00:39,420 --> 00:00:41,759
好像跟我们前面讲的不太一样

16
00:00:42,100 --> 00:00:46,459
然后我们还定义了一个自己的函数

17
00:00:46,700 --> 00:00:49,549
我们把数组要作为参数

18
00:00:49,549 --> 00:00:51,329
传到那个函数里头去

19
00:00:51,329 --> 00:00:53,340
然后还要做一些运算

20
00:00:53,340 --> 00:00:53,850
好吧

21
00:00:53,850 --> 00:00:56,729
这程序好像有太多我们之前没见过的东西

22
00:00:56,729 --> 00:00:57,899
我们一点点来看

23
00:00:57,899 --> 00:01:01,820
这件事情叫做数组的集成初始化

24
00:01:01,820 --> 00:01:04,430
也就是说我定义数组变量的时候

25
00:01:04,430 --> 00:01:05,480
我有两种方案

26
00:01:05,480 --> 00:01:07,969
一种方案是我不去初始化它

27
00:01:07,969 --> 00:01:09,739
我们之前的例子都是这样子

28
00:01:09,739 --> 00:01:10,969
我就给个方括号

29
00:01:10,969 --> 00:01:11,900
括号里面有数字

30
00:01:11,900 --> 00:01:13,459
后面就是分号就结尾了

31
00:01:13,459 --> 00:01:14,260
就没有了

32
00:01:14,260 --> 00:01:16,329
但是第二种方案就像现在这样

33
00:01:16,329 --> 00:01:18,579
我们给他一组数字

34
00:01:18,579 --> 00:01:22,260
我们用这一组数字去初始化这个a的数组

35
00:01:22,260 --> 00:01:24,659
而且你看我们在这样写的时候

36
00:01:24,659 --> 00:01:26,219
我们在a后面那个方括号里面

37
00:01:26,219 --> 00:01:27,510
是没有给数字的

38
00:01:27,510 --> 00:01:30,930
我们没有给出具体的这个数组的大小

39
00:01:30,930 --> 00:01:33,420
我们让编译器替我们去数

40
00:01:33,420 --> 00:01:35,040
我们来看一下这个初始化会给

41
00:01:35,040 --> 00:01:36,420
会给我们一个什么样的结果

42
00:01:36,420 --> 00:01:38,310
我们可以在这一行之后

43
00:01:38,310 --> 00:01:40,509
就马上来写一段测试的代码

44
00:01:40,509 --> 00:01:41,828
我们在测试代码里面

45
00:01:41,828 --> 00:01:43,269
可以有自己的一个变量i

46
00:01:43,269 --> 00:01:45,549
然后我们要遍历这个数组

47
00:01:45,549 --> 00:01:46,099
对不对

48
00:01:46,099 --> 00:01:47,900
那我们要遍历到什么地方呢

49
00:01:47,900 --> 00:01:49,459
好吧暂时我们还没有学过的话

50
00:01:49,459 --> 00:01:50,359
我们来说说看

51
00:01:50,359 --> 00:01:54,099
12345678 90 11 12 13

52
00:01:54,099 --> 00:01:56,980
ok我们有13个r a加加

53
00:01:57,019 --> 00:01:59,269
然后我们要做的事情是

54
00:01:59,269 --> 00:02:02,390
让他给我们输出所有的那个数字

55
00:02:02,390 --> 00:02:03,920
所以百分号d

56
00:02:05,620 --> 00:02:11,219
a的i最后完了以后给我们来一个回车

57
00:02:13,460 --> 00:02:17,259
我们可以把剩下的代码先注释掉

58
00:02:17,259 --> 00:02:18,580
我们先不需要用它

59
00:02:18,580 --> 00:02:22,180
我们来看一下这个数组的这种集成

60
00:02:22,180 --> 00:02:24,680
初始化会给我们一个什么样的结果

61
00:02:25,319 --> 00:02:27,919
我们看到246713等等等等

62
00:02:27,919 --> 00:02:32,129
这就是我们这写在大括号里面的这些数字

63
00:02:32,129 --> 00:02:33,659
我们写在大括号里面的数字

64
00:02:33,659 --> 00:02:37,439
会依次用来初始化数组当中的每一个单元

65
00:02:37,439 --> 00:02:38,500
另外呢

66
00:02:38,500 --> 00:02:39,969
我们的数组的大小

67
00:02:39,969 --> 00:02:42,610
也是由编译器替我们去设定了

68
00:02:42,610 --> 00:02:43,659
我现在是13个

69
00:02:43,659 --> 00:02:45,139
于是它就13个了

70
00:02:45,618 --> 00:02:48,438
假如说我在写这个初始化的时候

71
00:02:48,438 --> 00:02:49,248
不是这么写的

72
00:02:49,248 --> 00:02:51,378
而是这样子说

73
00:02:51,378 --> 00:02:52,360
我有一个二

74
00:02:53,800 --> 00:02:57,539
可是呢我在这儿说我是有13个的

75
00:02:58,680 --> 00:03:00,259
这时候会有什么结果呢

76
00:03:01,819 --> 00:03:04,030
第一个a0 是二

77
00:03:04,030 --> 00:03:06,180
可是后面的全部都是零

78
00:03:07,099 --> 00:03:07,900
换句话说

79
00:03:07,900 --> 00:03:11,979
我们以这个方式给第一个单元赋了值

80
00:03:11,979 --> 00:03:14,110
然后下面单元我们没有给值的话

81
00:03:14,110 --> 00:03:16,520
他会把下面的单元全部负为零

82
00:03:16,739 --> 00:03:20,659
所以我们前面在初始化那个count的时候

83
00:03:20,659 --> 00:03:21,259
你们还记不记得

84
00:03:21,259 --> 00:03:24,050
我们前面是用了这样一个循环

85
00:03:24,050 --> 00:03:25,500
来初始化那个count

86
00:03:25,500 --> 00:03:28,050
其实我们还可以有一个更调皮的做法

87
00:03:28,050 --> 00:03:29,959
我们可以把它写成这样

88
00:03:29,959 --> 00:03:33,280
它起到的效果和这个循环是一样的

89
00:03:33,879 --> 00:03:36,280
他也可以把这个count这个数组

90
00:03:36,280 --> 00:03:38,919
全部的内容都初始化为零

91
00:03:38,919 --> 00:03:41,169
我们可以在这儿写一个代码来检查一下

92
00:03:41,169 --> 00:03:43,659
说如果我有i等于零

93
00:03:43,659 --> 00:03:48,088
i小于number i加加

94
00:03:48,088 --> 00:03:50,800
我们要输出那个count的i

95
00:03:51,139 --> 00:03:53,719
所以如果我们给他第一个就是零的话

96
00:03:53,719 --> 00:03:55,340
我们就会看到13个零

97
00:03:55,340 --> 00:03:55,949
对不对

98
00:03:55,949 --> 00:03:59,009
另外呢c99 还还还可以做这样一个呃

99
00:03:59,009 --> 00:03:59,849
有趣的事情

100
00:03:59,849 --> 00:04:02,759
它可以在那个初始化的那个大括号里头啊

101
00:04:02,759 --> 00:04:06,639
用这样的方式去给指定的位置赋值

102
00:04:06,639 --> 00:04:08,139
所以我们现在现在的想法就意味着

103
00:04:08,139 --> 00:04:09,308
我们给a0 呢

104
00:04:09,308 --> 00:04:11,810
二我们给a2 呢

105
00:04:11,810 --> 00:04:13,659
三这个六给谁呢

106
00:04:13,659 --> 00:04:15,310
a2 接下去那就是a3 

107
00:04:15,310 --> 00:04:16,509
所以a3 会得到六

108
00:04:16,509 --> 00:04:17,829
那么其他的数字

109
00:04:17,829 --> 00:04:20,038
比如说a一没有得到值的就是零

110
00:04:20,038 --> 00:04:22,048
a4 没有多少值得也是零

111
00:04:22,048 --> 00:04:22,858
我们来试一下

112
00:04:22,858 --> 00:04:26,879
这个现在呢我们不说这个是零了

113
00:04:26,879 --> 00:04:30,579
我们说它的一呢等于二

114
00:04:31,379 --> 00:04:34,740
然后呢四这是给他的a2 的

115
00:04:34,740 --> 00:04:37,170
说他的五呢等于六

116
00:04:37,170 --> 00:04:38,100
其他都没有

117
00:04:38,100 --> 00:04:40,079
我们看看这样子的话

118
00:04:41,120 --> 00:04:43,000
他的一是二一

119
00:04:43,000 --> 00:04:44,470
接下去那个是四

120
00:04:44,470 --> 00:04:47,319
然后345a5 得到了六

121
00:04:47,319 --> 00:04:49,488
其他都是零啊

122
00:04:49,488 --> 00:04:52,129
当然这个写法只有c9 才有用

123
00:04:52,129 --> 00:04:53,899
这个写法特别适合于什么呢

124
00:04:53,899 --> 00:04:55,999
就是你的那个初始化数据啊

125
00:04:55,999 --> 00:04:56,959
特别稀疏

126
00:04:57,098 --> 00:04:58,298
很多都是零

127
00:04:58,298 --> 00:05:00,899
但是呢当中有那么几个不是零

128
00:05:00,899 --> 00:05:02,670
那么如果你没有这个写法的时候呢

129
00:05:02,670 --> 00:05:04,470
你就得把这一串数字全写上去

130
00:05:04,470 --> 00:05:04,949
对不对

131
00:05:04,949 --> 00:05:06,000
就比较费事儿嘛

132
00:05:06,000 --> 00:05:08,158
那现在呢我们这样就不那么费事

133
00:05:08,158 --> 00:05:12,288
还有如果我在这儿没给出大小

134
00:05:12,288 --> 00:05:13,639
它也能支持

135
00:05:13,639 --> 00:05:14,809
当然在这种情况下

136
00:05:14,809 --> 00:05:17,119
因为我们最大值涉及到了五

137
00:05:17,119 --> 00:05:20,750
所以呢这个a的这个最大的下标

138
00:05:20,750 --> 00:05:21,649
就只有五啊

139
00:05:21,649 --> 00:05:23,329
而没有呃13个元素

140
00:05:23,329 --> 00:05:24,110
它只有六个元素

141
00:05:24,110 --> 00:05:26,459
所以我们从0~6的话呢

142
00:05:26,459 --> 00:05:27,240
我们来运行一下

143
00:05:27,240 --> 00:05:28,350
就可以看到这个六

144
00:05:28,350 --> 00:05:30,240
在我们刚才那个代码里头啊

145
00:05:30,240 --> 00:05:32,749
我们通过集成初始化

146
00:05:32,749 --> 00:05:34,639
可以让编译器替我们数出来

147
00:05:34,639 --> 00:05:35,879
这个数字有多大

148
00:05:35,879 --> 00:05:38,459
可是你看我们后来那个写的那个测试

149
00:05:38,459 --> 00:05:39,600
代码呢也很囧的

150
00:05:39,600 --> 00:05:41,699
我们还得自己一个个的去数对吧

151
00:05:42,079 --> 00:05:46,149
怎么能够让程序编译器给我们数了

152
00:05:46,149 --> 00:05:47,920
那我们自己的程序有没有什么办法

153
00:05:47,920 --> 00:05:49,480
可以知道这个速度是多大呢

154
00:05:49,480 --> 00:05:50,439
有办法的

155
00:05:50,439 --> 00:05:51,720
这个办法是这样子的

156
00:05:52,660 --> 00:05:54,360
我们的我们还学过

157
00:05:54,360 --> 00:05:55,800
还记得我们学过那个size of

158
00:05:55,800 --> 00:05:56,459
对不对

159
00:05:56,459 --> 00:05:57,899
size of是一个运算符

160
00:05:57,899 --> 00:05:59,519
它可以给我们告诉我们说

161
00:05:59,519 --> 00:06:01,660
这个变量或者说这个类型有多大

162
00:06:01,680 --> 00:06:04,139
那么如果你对一个数组去求size

163
00:06:04,139 --> 00:06:05,160
得到的是什么呢

164
00:06:05,160 --> 00:06:08,500
得到的是这个数组占据了多少个单元

165
00:06:08,500 --> 00:06:09,670
我们来试一下

166
00:06:09,670 --> 00:06:12,220
如果我们现在在这里加上这样一句

167
00:06:12,220 --> 00:06:13,000
我们来看一下

168
00:06:13,000 --> 00:06:15,220
说这个a的这个size of是多少呢

169
00:06:15,658 --> 00:06:18,620
我们看到他告诉我们说a size of是24

170
00:06:19,399 --> 00:06:21,040
24是什么意思

171
00:06:21,040 --> 00:06:24,490
是说这个a里面有24个单元吗

172
00:06:24,490 --> 00:06:25,720
显然不对对吧

173
00:06:25,720 --> 00:06:28,019
我们看到这儿没有那么多个

174
00:06:28,360 --> 00:06:29,740
如果我们再看一下

175
00:06:29,740 --> 00:06:33,579
说a的第一个单元有多大

176
00:06:33,579 --> 00:06:36,060
我们看到他说有四个

177
00:06:37,180 --> 00:06:38,519
于是我们就知道说

178
00:06:38,519 --> 00:06:41,279
如果我们拿24÷4

179
00:06:41,279 --> 00:06:43,480
我们就可以得到一个有意义的数字

180
00:06:43,480 --> 00:06:46,120
我们不妨对这个看一下

181
00:06:46,120 --> 00:06:48,069
我们之前的这个数字

182
00:06:48,069 --> 00:06:49,329
我们知道这是13个

183
00:06:49,329 --> 00:06:49,870
对不对

184
00:06:49,870 --> 00:06:51,250
现在我们来看一下

185
00:06:51,250 --> 00:06:53,959
他说a呢是52个那么大

186
00:06:54,060 --> 00:06:55,529
a是52个那么大

187
00:06:55,529 --> 00:06:57,660
而a0 呢是四个

188
00:06:57,660 --> 00:07:00,079
52÷43

189
00:07:03,598 --> 00:07:04,769
可以换成什么呢

190
00:07:04,769 --> 00:07:11,120
可以换成size of a去除以size a0 

191
00:07:13,779 --> 00:07:15,540
这就是一个安全的东西

192
00:07:15,540 --> 00:07:17,199
也就是说你有了一个数组

193
00:07:18,180 --> 00:07:20,540
你就可以用size那个数组去除

194
00:07:20,540 --> 00:07:22,699
以size那个数组的第一个单元

195
00:07:22,699 --> 00:07:25,579
得到的就是这个数组有多少个元素

196
00:07:25,579 --> 00:07:27,579
这句话永远是对的

197
00:07:29,420 --> 00:07:31,720
这样的代码最大的好处就是

198
00:07:31,720 --> 00:07:35,139
一旦我们去修改数组当中初始的数据

199
00:07:35,139 --> 00:07:37,269
我们不需要去修改便利的代码

200
00:07:37,269 --> 00:07:39,459
我们刚才那个代码什么地方用到它呢

201
00:07:39,459 --> 00:07:40,480
回头看一下

202
00:07:40,480 --> 00:07:41,470
在这里

203
00:07:41,470 --> 00:07:43,689
当我们去调用摄取函数的时候

204
00:07:43,689 --> 00:07:47,009
我们要告诉那个摄取函数这个数字有多大

205
00:07:47,009 --> 00:07:47,850
社区函数

206
00:07:47,850 --> 00:07:49,769
说它的这个lance

207
00:07:49,769 --> 00:07:51,990
lance这个参数是数组a的长度

208
00:07:51,990 --> 00:07:53,339
于是我们怎么给他呢

209
00:07:53,339 --> 00:07:56,009
我们就拿下绕a除以sza 0

210
00:07:56,009 --> 00:08:00,110
因此这个代码这一行代码

211
00:08:00,110 --> 00:08:03,920
和我现在这里头的数字是没有关系的

212
00:08:03,920 --> 00:08:06,170
我如果在这儿加一个数字三六

213
00:08:06,170 --> 00:08:08,089
我这个程序依然是正确的

214
00:08:08,089 --> 00:08:09,649
我去掉俩数字

215
00:08:09,649 --> 00:08:11,800
我这个程序依然是正确的

216
00:08:12,779 --> 00:08:15,860
顺便说我是故意的去掉俩数字的时候

217
00:08:15,860 --> 00:08:17,939
留下了最后边的那个逗号

218
00:08:18,379 --> 00:08:20,300
有的老的教科书会说

219
00:08:20,300 --> 00:08:23,759
这是一种古老的口耳相传的传统

220
00:08:23,978 --> 00:08:26,439
当我们要去初始化一个数组的时候

221
00:08:26,439 --> 00:08:28,240
最后那个数字后面留一个逗号

222
00:08:28,240 --> 00:08:31,110
这个逗号不会影响编译的任何的结果

223
00:08:31,110 --> 00:08:32,370
但是它的好处是

224
00:08:32,370 --> 00:08:34,289
如果后面你想加一个新数字

225
00:08:34,289 --> 00:08:35,549
你不用再敲逗号了

226
00:08:35,549 --> 00:08:37,919
当然为了让后来人更方便

227
00:08:37,919 --> 00:08:39,779
你再敲上一个逗号吧

228
00:08:40,620 --> 00:08:43,490
这这这这确实显得很没有意义是吧

229
00:08:43,490 --> 00:08:45,529
但是这确实是一个有逗号

230
00:08:45,529 --> 00:08:46,070
没逗号

231
00:08:46,070 --> 00:08:48,710
体现出你有没有在70年代

232
00:08:48,710 --> 00:08:50,578
80年代读过计算机书

233
00:08:50,879 --> 00:08:53,159
你可以用它来装一装的

234
00:08:53,159 --> 00:08:55,979
如果我有了一个数组

235
00:08:56,299 --> 00:08:58,940
比如说像我们刚才定义的那个数组集成

236
00:08:58,940 --> 00:08:59,889
初始化出来的

237
00:08:59,889 --> 00:09:01,960
然后我又定义了一个数组变量b

238
00:09:01,960 --> 00:09:06,139
我能不能把a这个数组赋给b那个数组呢

239
00:09:06,320 --> 00:09:09,458
答案是否定的

240
00:09:09,860 --> 00:09:11,299
数组不能做这样的赋值

241
00:09:11,299 --> 00:09:13,279
你不能直接拿一个数组变量

242
00:09:13,279 --> 00:09:14,480
赋给另外一个数组变量

243
00:09:14,480 --> 00:09:16,259
因为数组变量是特殊的

244
00:09:16,379 --> 00:09:17,820
事实上我们后面讲了

245
00:09:17,820 --> 00:09:18,360
讲到指针

246
00:09:18,360 --> 00:09:20,250
我们会来讲这件事情啊

247
00:09:20,250 --> 00:09:21,600
数组变量到底是什么

248
00:09:21,600 --> 00:09:23,940
时长速度变量是一种cost的东西啊

249
00:09:23,940 --> 00:09:25,120
我们后面再来讲

250
00:09:26,000 --> 00:09:28,000
所以你要把一个数组的所有元素

251
00:09:28,000 --> 00:09:28,840
交给另外一个数组

252
00:09:28,840 --> 00:09:30,250
你就必须采用便利

253
00:09:30,250 --> 00:09:34,070
也就是说你要写一个循环便利那个数组

254
00:09:34,070 --> 00:09:36,610
然后把它的每一个元素

255
00:09:36,610 --> 00:09:38,529
赋给另外一个数组的每个元素

256
00:09:38,529 --> 00:09:41,710
这是唯一能够把一个数组赋给另外

257
00:09:41,710 --> 00:09:42,669
一个数组的方法

258
00:09:42,669 --> 00:09:44,099
没有其他方法可以做

259
00:09:46,600 --> 00:09:49,500
我们之前看到了很多遍历数组的例子对吧

260
00:09:49,500 --> 00:09:51,600
我们遍历数组做赋值

261
00:09:51,600 --> 00:09:53,220
我们遍历数组做初始化

262
00:09:53,220 --> 00:09:56,950
我们遍历数组去判断这个

263
00:09:56,950 --> 00:09:59,139
我们要找的那个东西是否存在

264
00:09:59,139 --> 00:10:02,470
我们遍历数组去看这个结果要不要输出

265
00:10:02,470 --> 00:10:03,580
我们遍历数组

266
00:10:03,580 --> 00:10:07,539
去看我们的这个每一个的技术值得大小

267
00:10:08,580 --> 00:10:10,159
我们在做遍历的时候

268
00:10:10,159 --> 00:10:12,350
通常都是使用for循环

269
00:10:12,350 --> 00:10:14,000
让循环变量这个i呢

270
00:10:14,000 --> 00:10:16,470
从零到小于数组的长度

271
00:10:16,470 --> 00:10:17,970
为什么到小a柱的长度呢

272
00:10:17,970 --> 00:10:19,110
因为这样子做的话呢

273
00:10:19,110 --> 00:10:20,940
循环体内最大的i

274
00:10:20,940 --> 00:10:23,568
正好就是数组最大的有效下标

275
00:10:23,568 --> 00:10:26,328
所以程序员在写for循环的时候

276
00:10:26,328 --> 00:10:28,370
你会看到他们通常都会喜欢

277
00:10:28,370 --> 00:10:30,559
从零开始到小于某个数

278
00:10:30,559 --> 00:10:32,330
而很少会有人写

279
00:10:32,330 --> 00:10:34,818
从零开始到小于等于某个数

280
00:10:35,080 --> 00:10:37,539
同样的你写出来的循环是零开始

281
00:10:37,539 --> 00:10:38,139
当小于某个数

282
00:10:38,139 --> 00:10:38,860
还是一开始

283
00:10:38,860 --> 00:10:39,940
当小于等于某个数

284
00:10:39,940 --> 00:10:43,500
也是可以给你自己贴标签的那么一个东西

285
00:10:45,139 --> 00:10:47,950
那常见的错误就是循环结束条件

286
00:10:47,950 --> 00:10:49,779
是小于等于数组的长度

287
00:10:49,779 --> 00:10:51,519
或者还有一种常见的错误

288
00:10:51,519 --> 00:10:53,460
就是离开循环以后

289
00:10:53,460 --> 00:10:55,649
继续用那个循环变量i的值

290
00:10:55,649 --> 00:10:57,090
来做数组元素的下标

291
00:10:57,090 --> 00:10:59,100
因为你想当你这么写

292
00:10:59,100 --> 00:11:02,340
比如说我们这里说i小于li小于li小于number

293
00:11:02,340 --> 00:11:04,860
i小于s n t离开这个循环的时候

294
00:11:07,669 --> 00:11:08,269
正好是number

295
00:11:08,269 --> 00:11:09,080
正好是c n t

296
00:11:09,080 --> 00:11:14,360
正好就是那个数组无效的那个下标

297
00:11:16,580 --> 00:11:18,559
所以这是一种常见的错误

298
00:11:21,399 --> 00:11:23,700
所以回来说我们的这个搜索程序

299
00:11:23,700 --> 00:11:24,690
是怎么样子的呢

300
00:11:24,690 --> 00:11:28,139
我们在in程序里面定义了这么一个数组

301
00:11:28,139 --> 00:11:30,179
这是我们的基础数据

302
00:11:30,179 --> 00:11:32,458
然后我们让用户输入一个数字

303
00:11:32,779 --> 00:11:35,000
我们去调用那个search函数

304
00:11:35,000 --> 00:11:37,078
search函数会返回给我们一个lo

305
00:11:37,139 --> 00:11:38,490
因为摄取函数说

306
00:11:38,490 --> 00:11:40,799
他要找出key在数组a中的位置

307
00:11:40,799 --> 00:11:43,850
它的参数t呢是要寻找的那个数字

308
00:11:43,850 --> 00:11:45,590
a是要寻找的数组

309
00:11:45,590 --> 00:11:47,419
length是数组a的长度

310
00:11:47,419 --> 00:11:49,700
那如果找到返回它在a中的位置

311
00:11:49,700 --> 00:11:50,659
从零开始的

312
00:11:50,659 --> 00:11:52,200
如果找不到返回-1

313
00:11:52,200 --> 00:11:53,700
所以如果返回的不是-1

314
00:11:53,700 --> 00:11:56,340
那么我们就说这个数字呢在第几个位置上

315
00:11:56,340 --> 00:11:57,730
如果是-1

316
00:11:57,730 --> 00:11:59,590
那我们就说这个数字不存在

317
00:11:59,590 --> 00:12:01,629
而摄取函数呢是这么做的

318
00:12:01,629 --> 00:12:03,070
它里面做个循环

319
00:12:03,070 --> 00:12:06,419
对这个数组a做便利便利的

320
00:12:06,419 --> 00:12:09,509
每一次他拿出数组当中的一个单元

321
00:12:09,509 --> 00:12:11,610
来判断和key是否相等

322
00:12:11,610 --> 00:12:12,450
如果相等

323
00:12:12,450 --> 00:12:14,090
令i e t等于i

324
00:12:14,090 --> 00:12:15,059
然后break出来

325
00:12:15,059 --> 00:12:17,850
那么最后呢就把这个i t给返回i t

326
00:12:17,850 --> 00:12:19,620
最开始默认的值是-1

327
00:12:19,620 --> 00:12:21,960
所以如果走完了遍历完了

328
00:12:21,960 --> 00:12:23,299
整个数组都没有找到key

329
00:12:23,299 --> 00:12:24,559
it就是-1

330
00:12:24,559 --> 00:12:25,940
正好就是我们要的结果

331
00:12:25,940 --> 00:12:27,679
找不到返回-1

332
00:12:29,700 --> 00:12:34,080
所以当我们用数组作为参数的时候

333
00:12:34,080 --> 00:12:36,240
或者说当我们函数的参数是一个数组的时

334
00:12:36,240 --> 00:12:36,539
候

335
00:12:36,539 --> 00:12:39,480
我们往往呢必须再利用另外一个参数

336
00:12:39,480 --> 00:12:41,000
来传入数组的大小

337
00:12:41,179 --> 00:12:42,620
为什么呢

338
00:12:42,620 --> 00:12:47,220
因为首先在函数里头

339
00:12:47,220 --> 00:12:48,720
如果是参数传进来的话

340
00:12:48,720 --> 00:12:51,179
我们不能再利用size of来计算

341
00:12:51,179 --> 00:12:52,529
数组的元素个数了

342
00:12:52,529 --> 00:12:55,470
为什么不能用size of来算参数的那个

343
00:12:55,470 --> 00:12:56,578
元素个数

344
00:12:56,740 --> 00:12:59,139
这事情我们要到指针的时候再来说

345
00:12:59,879 --> 00:13:03,500
那么顺便呢我们也在参数当中呢给出

346
00:13:03,500 --> 00:13:04,519
如果给出一个数字

347
00:13:04,519 --> 00:13:05,750
说这个数组是多大

348
00:13:05,750 --> 00:13:06,860
也是没有任何意义的

349
00:13:06,860 --> 00:13:08,818
这些事情我们也要到后面再来解释

350
00:13:08,818 --> 00:13:11,789
所以当你要把一个数组作为参数

351
00:13:11,789 --> 00:13:13,049
传到另外一函数里头去的时候

352
00:13:13,049 --> 00:13:14,909
我们就需要用另外一个参数

353
00:13:14,909 --> 00:13:16,080
也就这里的这个lance

354
00:13:16,080 --> 00:13:17,490
来传入这个数组的大小

355
00:13:17,490 --> 00:13:19,580
要不然那个函数是没法做计算的

