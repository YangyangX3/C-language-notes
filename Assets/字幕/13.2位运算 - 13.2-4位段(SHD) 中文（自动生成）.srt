1
00:00:04,719 --> 00:00:05,860
在这张表上面呢

2
00:00:05,860 --> 00:00:09,519
我们也看到有一些东西它不是一个比特的

3
00:00:09,519 --> 00:00:10,599
比如说这是俩比特

4
00:00:10,599 --> 00:00:11,730
这也是俩比特

5
00:00:11,730 --> 00:00:13,289
它表明说这两个比特呢

6
00:00:13,289 --> 00:00:15,990
可以是000110114种组合是吧

7
00:00:15,990 --> 00:00:17,309
有的时候我们还会看到有三个比特

8
00:00:17,309 --> 00:00:18,760
四个比特的更复杂的

9
00:00:18,760 --> 00:00:19,839
那这种时候呢

10
00:00:19,839 --> 00:00:21,339
这两个比特我就没办法用

11
00:00:21,339 --> 00:00:22,420
我们刚才的这个技巧

12
00:00:22,420 --> 00:00:24,600
用这种技巧呢我们只能控制一个比特

13
00:00:24,600 --> 00:00:26,910
我们要控制两个比的比较麻烦对吧

14
00:00:26,910 --> 00:00:29,489
那c语言呢提供另外一种手段

15
00:00:29,489 --> 00:00:33,539
像这样我们可以写一个strong

16
00:00:33,859 --> 00:00:35,780
在这个rar里面的其他东西

17
00:00:35,780 --> 00:00:37,340
看上去和结构

18
00:00:37,340 --> 00:00:38,840
和我们之前讲的结构都一模一样

19
00:00:38,840 --> 00:00:41,539
但是不一样的是在每一个成员的后面

20
00:00:41,539 --> 00:00:43,100
我们有冒号

21
00:00:43,100 --> 00:00:44,810
冒号后面还有数字

22
00:00:44,810 --> 00:00:48,759
这个数字的意思是说这个成员占几个比特

23
00:00:48,899 --> 00:00:51,060
所以现在这个成员占三个比特

24
00:00:51,060 --> 00:00:51,780
他占一个比特

25
00:00:51,780 --> 00:00:52,679
他占一个比特

26
00:00:52,679 --> 00:00:54,140
他占11个比特

27
00:00:54,939 --> 00:00:55,979
总的来说

28
00:00:55,979 --> 00:00:58,530
最后他可能放在一个int里头

29
00:00:58,530 --> 00:01:01,549
而每一个成员在其中的某些比特

30
00:01:01,549 --> 00:01:04,079
这样我们就可以用来表达这张表格里面

31
00:01:04,079 --> 00:01:04,379
这些东西

32
00:01:04,379 --> 00:01:06,120
我们可以说这里两个比特

33
00:01:06,120 --> 00:01:06,840
这一个比特

34
00:01:06,840 --> 00:01:07,260
一个比特

35
00:01:07,260 --> 00:01:07,680
两个比特

36
00:01:07,680 --> 00:01:08,040
一个比特

37
00:01:08,040 --> 00:01:08,670
一个比特

38
00:01:08,670 --> 00:01:11,920
把它们变成一个位段当中的一个个的变量

39
00:01:12,099 --> 00:01:14,500
我们看一个具体的程序的例子

40
00:01:14,500 --> 00:01:16,920
我们定义了一个struct叫做幽灵

41
00:01:16,959 --> 00:01:19,030
它里面呢有一个leading的三

42
00:01:19,030 --> 00:01:19,780
有一个frag

43
00:01:19,780 --> 00:01:21,030
one frag to的

44
00:01:21,030 --> 00:01:22,109
我这是俩比特

45
00:01:22,109 --> 00:01:22,769
这是三比特

46
00:01:22,769 --> 00:01:26,099
然后呢这个chill呢放了一个27

47
00:01:26,099 --> 00:01:28,579
因为2+35

48
00:01:28,579 --> 00:01:30,379
5+27是32

49
00:01:30,379 --> 00:01:32,390
但是其实你这个training有没有没关系啊

50
00:01:32,390 --> 00:01:34,519
然后我们做了一个rap u0 啊

51
00:01:34,519 --> 00:01:37,700
u u那么我们给它里面填了点值

52
00:01:37,700 --> 00:01:38,209
这是二

53
00:01:38,209 --> 00:01:38,900
这是零

54
00:01:38,900 --> 00:01:40,370
这是一确定是零

55
00:01:40,370 --> 00:01:42,530
我们看一下size of u u是多少

56
00:01:42,530 --> 00:01:43,670
然后我们看一下

57
00:01:43,670 --> 00:01:46,890
如果把这个u当做一个整数

58
00:01:46,890 --> 00:01:50,250
我们用p r t bk p i t ban

59
00:01:50,250 --> 00:01:52,079
就是我们刚刚看过的那段代码

60
00:01:52,079 --> 00:01:53,700
输出二进制位啊

61
00:01:53,700 --> 00:01:56,640
我们把这个on saint的二进制位输出

62
00:01:56,640 --> 00:01:58,209
看一下是什么

63
00:01:58,209 --> 00:02:01,689
这这这这这这地方那么多符号在干嘛呢啊

64
00:02:01,689 --> 00:02:03,909
我们用了一点点比较龌龊的技巧哈

65
00:02:03,909 --> 00:02:06,590
我们取得了uu这个变量的地址

66
00:02:06,590 --> 00:02:10,069
那这个地址应该它的类型是一个指向strong

67
00:02:10,069 --> 00:02:11,599
幽灵的一个指针对吧

68
00:02:11,599 --> 00:02:13,370
然后我们把它强制类型转换为

69
00:02:13,370 --> 00:02:14,860
指向int的指针

70
00:02:15,819 --> 00:02:19,439
然后我们再取这个指针所指的那个int

71
00:02:19,439 --> 00:02:23,430
然后把这个int交给了p r t bin这个函数啊

72
00:02:23,430 --> 00:02:25,530
在底层程序当中

73
00:02:25,530 --> 00:02:26,969
在和硬件打交道程序当中

74
00:02:26,969 --> 00:02:29,960
其实这种做法呢还算是比较常见的

75
00:02:30,118 --> 00:02:33,179
呃虽然看上去不那么不那么道德哈

76
00:02:33,179 --> 00:02:35,699
我这这明明这个这是一个rap

77
00:02:35,699 --> 00:02:36,449
是一个结构

78
00:02:36,449 --> 00:02:39,780
可是呢我要把它当做一个int来做一些事情

79
00:02:39,780 --> 00:02:40,919
所以我就用这种手段

80
00:02:40,919 --> 00:02:42,840
瞒天过海的把它给换过去了

81
00:02:42,840 --> 00:02:43,379
不管怎么说

82
00:02:43,379 --> 00:02:45,180
我们来看一下这程序运行的结果

83
00:02:45,819 --> 00:02:49,860
他说这个uu的size呢是四一个int那么大

84
00:02:50,139 --> 00:02:52,860
然后呢钱呢全是零

85
00:02:53,479 --> 00:02:54,469
好全是零

86
00:02:54,469 --> 00:02:57,710
然后我们的这个leading说它是二

87
00:02:57,710 --> 00:02:58,969
是这俩比特

88
00:02:58,969 --> 00:02:59,750
这是二

89
00:02:59,750 --> 00:03:01,280
然后flag one是一

90
00:03:01,280 --> 00:03:03,849
是这个比啊

91
00:03:03,849 --> 00:03:05,740
我们的leading是有三个

92
00:03:05,740 --> 00:03:08,009
ok所以这三个比特是leading

93
00:03:08,009 --> 00:03:08,610
这是二

94
00:03:08,610 --> 00:03:10,379
然后呢这是flag one

95
00:03:10,379 --> 00:03:11,610
这是flag to

96
00:03:11,610 --> 00:03:14,159
剩下的全部都是training

97
00:03:15,240 --> 00:03:18,080
嗯哼我们可以稍微做一点改动哈

98
00:03:18,080 --> 00:03:20,259
假如说我们现在没有这个权力

99
00:03:20,939 --> 00:03:22,379
也就没有这个training

100
00:03:22,379 --> 00:03:23,219
我们再来看一下

101
00:03:24,360 --> 00:03:25,500
仍然是四

102
00:03:26,159 --> 00:03:29,550
可是呢前面的东西会比较乱

103
00:03:29,550 --> 00:03:32,960
因为我们没有去让这个吹0=0对吧

104
00:03:33,139 --> 00:03:34,699
后面的东西还是一样的

105
00:03:34,699 --> 00:03:35,840
这是那个leading

106
00:03:35,840 --> 00:03:37,159
这是那个一

107
00:03:37,159 --> 00:03:38,419
这是那个二

108
00:03:38,419 --> 00:03:39,199
然后呢

109
00:03:39,199 --> 00:03:43,819
剩下的这些呢就没有人对他去付出值了啊

110
00:03:43,819 --> 00:03:45,710
所以它就是一个乱七八糟的东西

111
00:03:45,710 --> 00:03:47,780
假如我们现在这样

112
00:03:48,019 --> 00:03:49,848
这个trading呢比较大

113
00:03:49,848 --> 00:03:52,800
比如说trading本身就有32个比特

114
00:03:53,558 --> 00:03:55,949
然后当然我们这儿还是让他去填零

115
00:03:55,949 --> 00:03:58,180
我们看看这样的结果会是什么样呢

116
00:03:58,399 --> 00:04:01,639
他就会说这个size of u u呢是吧

117
00:04:01,639 --> 00:04:06,060
因为这时候所有的位数加起来

118
00:04:06,060 --> 00:04:07,259
已经超过32了

119
00:04:07,259 --> 00:04:09,849
所以他就要用两个int来表达它啊

120
00:04:09,849 --> 00:04:12,189
用两个int来表达这个这个这个位段

121
00:04:12,189 --> 00:04:15,498
然后呢剩下的这些声音还是一样的啊

122
00:04:15,498 --> 00:04:17,158
我还是从最右边放弃

123
00:04:17,158 --> 00:04:18,838
定义了这样一个未断之后呢

124
00:04:18,838 --> 00:04:20,639
我们就可以直接用位段成员的名称

125
00:04:20,639 --> 00:04:22,360
来访问其中的某些笔画

126
00:04:22,360 --> 00:04:24,579
这个呢比一位啊鱼啊货啊

127
00:04:24,579 --> 00:04:26,740
那些其实都还要方便的多啊

128
00:04:26,779 --> 00:04:29,699
呃编译器呢会安排其中的v的排列

129
00:04:30,379 --> 00:04:31,839
不具有可移植性

130
00:04:31,839 --> 00:04:35,439
这是未断一个比较让人揪心的事情

131
00:04:35,439 --> 00:04:38,110
我们我们看到在我的这个编译器上面

132
00:04:38,110 --> 00:04:39,670
它是从最右边排起的

133
00:04:39,670 --> 00:04:41,350
你可能在你的编译器上面看到

134
00:04:41,350 --> 00:04:42,939
它是从最左边排起的

135
00:04:43,560 --> 00:04:44,220
呃

136
00:04:44,220 --> 00:04:45,509
另外呢我们也看到说

137
00:04:45,509 --> 00:04:47,910
当它所需要的位如果超过一个int的时候呢

138
00:04:47,910 --> 00:04:50,430
编译器会替你安排多个多个int啊

139
00:04:50,430 --> 00:04:51,060
总的来说

140
00:04:51,060 --> 00:04:53,939
位段主要就是用于这些比较底层的

141
00:04:53,939 --> 00:04:55,480
直接操作硬件的这些场合

