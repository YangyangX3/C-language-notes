1
00:00:04,360 --> 00:00:07,280
所以字符串在c语言就是这样一个地位

2
00:00:07,900 --> 00:00:10,140
相较于c语言之前的旧语言

3
00:00:10,140 --> 00:00:13,570
当然c语言有一些针对字符串的东西了

4
00:00:13,570 --> 00:00:15,849
但是呢相对于现代的新语言

5
00:00:15,849 --> 00:00:19,399
c语言对字符串的这个能力还是不足的

6
00:00:19,399 --> 00:00:20,629
所以比如说我们要说

7
00:00:20,629 --> 00:00:23,509
我们要有两个字符串的变量要做赋值

8
00:00:23,509 --> 00:00:25,189
但是实际上发生的是什么

9
00:00:25,189 --> 00:00:26,210
比如在这里的说

10
00:00:26,210 --> 00:00:29,149
我们这个呃train t呢等于title

11
00:00:29,149 --> 00:00:31,609
然后我们另外有个变量chasing s

12
00:00:31,609 --> 00:00:33,000
我们让s等于t

13
00:00:33,340 --> 00:00:35,799
他其实做的事情呢是这样的

14
00:00:35,799 --> 00:00:38,689
我们原本有一个变量叫做t

15
00:00:38,689 --> 00:00:42,380
他呢指向了某处的那么一个字符串

16
00:00:42,380 --> 00:00:44,810
里面的内容呢是title

17
00:00:44,810 --> 00:00:46,789
然后当然最后有个结尾的零

18
00:00:46,789 --> 00:00:50,060
然后我们有了另外的一个变量叫做s

19
00:00:50,060 --> 00:00:51,679
我们说s等于t

20
00:00:51,679 --> 00:00:56,418
结果是s指向了t所指的那个字符串

21
00:00:56,420 --> 00:00:58,490
这就是所谓的字符串的复制

22
00:00:58,490 --> 00:01:02,570
我们并没有另外再去制造一个新的s出来

23
00:01:02,570 --> 00:01:06,000
如何另外再制造一个新的字符串

24
00:01:06,000 --> 00:01:08,459
然后让t指向那个新的字符串

25
00:01:08,459 --> 00:01:10,200
也就是说如果你希望的事情

26
00:01:10,200 --> 00:01:14,239
不是说让t指向

27
00:01:14,239 --> 00:01:16,790
让s指向t所指的那个字符串

28
00:01:16,790 --> 00:01:19,579
而是我们希望得到这样一个结果

29
00:01:19,579 --> 00:01:23,269
这事情得等到我们学了字符串函数以后

30
00:01:23,269 --> 00:01:25,500
我们才有一个办法来做这个事情

31
00:01:25,500 --> 00:01:28,480
我们知道如果是c语言的基础类型

32
00:01:28,480 --> 00:01:30,280
比如说int float double

33
00:01:30,280 --> 00:01:31,599
我们有一些办法

34
00:01:31,599 --> 00:01:34,400
用print def和cf去做输入和输出

35
00:01:34,400 --> 00:01:35,780
对于字符串类型的

36
00:01:35,780 --> 00:01:39,198
print f和gf也有特殊的手段

37
00:01:39,198 --> 00:01:42,259
特殊的格式字符来对他们做输入和输出

38
00:01:42,259 --> 00:01:44,239
那个是百分号s

39
00:01:44,560 --> 00:01:47,180
所以我们可以用print f

40
00:01:47,180 --> 00:01:49,159
百分之s去输出一个stream

41
00:01:49,159 --> 00:01:52,109
我们也可以用scaf百分之s去读一个string

42
00:01:52,109 --> 00:01:54,030
但是去读一个卷in的时候

43
00:01:54,030 --> 00:01:55,829
到底读什么样的东西

44
00:01:55,829 --> 00:01:58,269
读到什么地方为止是很微妙的

45
00:01:58,269 --> 00:01:59,819
我们来试一下这个程序

46
00:01:59,959 --> 00:02:01,519
我们现在这个程序做的事情呢

47
00:02:01,519 --> 00:02:01,819
是说

48
00:02:01,819 --> 00:02:06,230
我们定义了一个八个字符的那么一个数组

49
00:02:06,230 --> 00:02:09,800
然后呢我们用scaf百分之s去读一些东西

50
00:02:09,800 --> 00:02:11,530
到这个数组里头去

51
00:02:11,530 --> 00:02:12,849
最后呢我们把它输出

52
00:02:12,849 --> 00:02:16,400
输出的时候带了一个结尾的反斜杠n

53
00:02:16,739 --> 00:02:18,538
但为了这件事情

54
00:02:18,538 --> 00:02:20,519
我们输出的时候能够看得更明白一点

55
00:02:20,519 --> 00:02:22,498
我们想在反斜杠n之前呢

56
00:02:22,498 --> 00:02:23,819
我们加两个井号

57
00:02:23,819 --> 00:02:26,639
这样子我们可以看到我们输入的东西的

58
00:02:26,639 --> 00:02:28,139
那个结尾的边界在哪

59
00:02:28,139 --> 00:02:28,259
好

60
00:02:28,259 --> 00:02:29,580
我们来试一下这个程序

61
00:02:29,580 --> 00:02:35,219
如果我们输入了hello world

62
00:02:35,800 --> 00:02:39,240
我们看到我们的百分号s cap的百分之s

63
00:02:39,240 --> 00:02:41,729
给我们读到了第一个单词hello

64
00:02:44,979 --> 00:02:48,218
第二个单词word呢他没有读到

65
00:02:48,218 --> 00:02:51,818
但如果你下一次再有一个scaf程序里头

66
00:02:51,818 --> 00:02:52,538
还有第二个

67
00:02:52,538 --> 00:02:53,879
他会读到那个word

68
00:02:54,500 --> 00:02:55,520
我们可以试一下

69
00:02:55,520 --> 00:02:58,159
如果程序里面还有第二个会读到那个word

70
00:02:58,159 --> 00:02:59,449
会不会读到那个空格

71
00:02:59,449 --> 00:03:02,188
我们这样的代码我们有两个word

72
00:03:02,188 --> 00:03:02,609
一个word

73
00:03:02,609 --> 00:03:03,598
一个word to啊

74
00:03:03,598 --> 00:03:05,120
然后我们读两次

75
00:03:05,299 --> 00:03:06,528
我们读两次

76
00:03:06,528 --> 00:03:07,549
完了以后呢

77
00:03:07,549 --> 00:03:11,900
我们输出第一个用两个井号再输出

78
00:03:11,900 --> 00:03:13,430
第二个再来两个井号

79
00:03:13,430 --> 00:03:16,009
这样我们可以知道它到底读到了什么东西

80
00:03:16,009 --> 00:03:17,269
如果这当中有空格

81
00:03:17,269 --> 00:03:19,699
这个空格会出现在井号和井号中间的

82
00:03:19,699 --> 00:03:20,598
我们来试一下

83
00:03:20,598 --> 00:03:23,508
我们看到第一个百分2s读到的是hello

84
00:03:23,508 --> 00:03:24,509
不带空格

85
00:03:24,509 --> 00:03:27,659
而第二个读到的是word也不带那个空格

86
00:03:27,659 --> 00:03:28,830
因为那个空格

87
00:03:28,830 --> 00:03:31,770
是用来区分这个单词和那个单词的

88
00:03:31,770 --> 00:03:33,599
它是一个分隔符

89
00:03:34,959 --> 00:03:37,438
如果我们的输入是这样的

90
00:03:37,438 --> 00:03:39,060
hello回车

91
00:03:39,299 --> 00:03:41,368
word回车

92
00:03:41,368 --> 00:03:44,599
我们看到那个回车也没有被他读进去

93
00:03:44,639 --> 00:03:48,319
他在输出的时候也是不带着那个回车的

94
00:03:48,319 --> 00:03:50,090
所以2%s读什么呢

95
00:03:50,090 --> 00:03:52,329
2%s读的是一个单词

96
00:03:52,329 --> 00:03:55,568
所谓的一个单词和是不是真的是一个

97
00:03:55,568 --> 00:03:57,308
英文的单词没有任何关系

98
00:03:57,308 --> 00:04:01,620
他只是说读到空格tab或者回车为止

99
00:04:01,639 --> 00:04:04,669
但是这个scaf是不安全的

100
00:04:04,669 --> 00:04:07,340
因为他不知道要读进去的内容的长度

101
00:04:07,340 --> 00:04:08,780
我们现在在程序里面说

102
00:04:08,780 --> 00:04:12,199
我们开了一个八个字节的数组

103
00:04:12,199 --> 00:04:13,949
八个character的数组

104
00:04:13,949 --> 00:04:14,849
因此意味着

105
00:04:14,849 --> 00:04:17,430
如果你输入的东西超过八个会怎么样

106
00:04:17,430 --> 00:04:19,350
你看我们去调用scaf的时候

107
00:04:19,350 --> 00:04:21,800
没有给他任何的信息

108
00:04:21,800 --> 00:04:24,110
关于我们的这个string有多大

109
00:04:25,430 --> 00:04:27,639
我们知道虽然这是一个数组

110
00:04:27,639 --> 00:04:29,449
但是我们在学数组的时候知道

111
00:04:29,449 --> 00:04:30,949
对于函数的参数来说

112
00:04:30,949 --> 00:04:33,740
你传进去的他接收的地方是个指针

113
00:04:33,740 --> 00:04:35,269
我们已经没有任何其他手段

114
00:04:35,269 --> 00:04:37,288
可以知道你传进去的这个指针

115
00:04:37,288 --> 00:04:38,728
到底只想多大东西

116
00:04:39,928 --> 00:04:43,389
除非我们另外给他一个数字

117
00:04:43,389 --> 00:04:45,220
告诉这个scaf函数

118
00:04:45,220 --> 00:04:46,870
我后面这个gin有多大

119
00:04:46,870 --> 00:04:48,370
所以对我们现在这个程序

120
00:04:48,370 --> 00:04:50,290
如果我给他的东西超过八个字符

121
00:04:50,290 --> 00:04:53,310
你看12345678

122
00:04:53,310 --> 00:04:56,040
这就已经超过他可以接受的极限了

123
00:04:56,040 --> 00:04:56,550
对不对

124
00:04:56,550 --> 00:04:59,990
我们开的是八个character的数组

125
00:04:59,990 --> 00:05:02,389
它最多只能接受七个字符

126
00:05:02,389 --> 00:05:03,709
因为还有那个结尾的零

127
00:05:03,709 --> 00:05:05,389
现在如果我们给他这样的东西

128
00:05:05,389 --> 00:05:08,120
然后下一个也是12345678

129
00:05:09,259 --> 00:05:13,809
他读到了的东西是什么

130
00:05:13,809 --> 00:05:15,379
第一个东西没了

131
00:05:15,718 --> 00:05:18,238
第二个东西得到了12345678

132
00:05:18,238 --> 00:05:22,589
为什么我们在讨论区去讨论这件事情

133
00:05:22,589 --> 00:05:25,889
因为这涉及到这些变量

134
00:05:25,889 --> 00:05:28,560
在内存里面是怎么排列的

135
00:05:28,560 --> 00:05:29,819
是怎么存放的

136
00:05:29,819 --> 00:05:31,259
当然我们运气好

137
00:05:31,259 --> 00:05:32,879
这一次我们的运气好

138
00:05:32,879 --> 00:05:34,120
它没有崩溃

139
00:05:35,199 --> 00:05:37,619
如果我们把我们的程序稍微改一改

140
00:05:37,619 --> 00:05:39,358
我们把我们要做的事情

141
00:05:39,358 --> 00:05:41,500
放到另外一个函数里头

142
00:05:41,680 --> 00:05:45,339
然后我们用刚才的方法去给他输入

143
00:05:45,339 --> 00:05:47,829
不恰当的这个这个输入

144
00:05:47,829 --> 00:05:49,220
看看他会怎么样

145
00:05:54,839 --> 00:05:56,519
我们之前见过这种东西

146
00:05:56,519 --> 00:05:57,209
对不对

147
00:05:57,209 --> 00:05:58,680
其实发生的是什么

148
00:05:58,680 --> 00:06:01,629
我们数组已经越界了

149
00:06:01,629 --> 00:06:04,569
我们这儿只有八个truck可以放

150
00:06:04,569 --> 00:06:06,459
我们在这两次读书的时候

151
00:06:06,459 --> 00:06:09,430
我们都给他放了超过八个的东西

152
00:06:09,430 --> 00:06:10,300
它已经越界了

153
00:06:10,300 --> 00:06:12,550
这个越界造成了严重的后果

154
00:06:12,550 --> 00:06:14,000
导致程序崩溃了

155
00:06:14,139 --> 00:06:15,339
那怎么做

156
00:06:15,339 --> 00:06:16,449
是安全的

157
00:06:16,449 --> 00:06:19,779
安全的方式是在百分号和s中间

158
00:06:19,779 --> 00:06:21,500
你可以加一个数字

159
00:06:21,680 --> 00:06:24,500
这个数字的目的是告诉这个scaf

160
00:06:24,500 --> 00:06:27,600
你最多只能读七个字符

161
00:06:28,060 --> 00:06:30,850
超过七个字符就不要了

162
00:06:30,850 --> 00:06:33,850
如果当然用户输入的小于小于七个字符

163
00:06:33,850 --> 00:06:34,930
没有问题

164
00:06:34,930 --> 00:06:37,329
你不是一定要读满七个字符

165
00:06:37,329 --> 00:06:40,300
这个棋只是说最多读七个东西

166
00:06:40,300 --> 00:06:41,420
我们来试一下

167
00:06:41,879 --> 00:06:44,370
我们的第一个呢给它三个

168
00:06:44,370 --> 00:06:47,779
第二个呢给他八个

169
00:06:48,319 --> 00:06:51,680
我们看到第一个他确实只读了三个

170
00:06:51,680 --> 00:06:52,279
没有问题

171
00:06:52,279 --> 00:06:54,439
不会因为我要百分号7s

172
00:06:54,439 --> 00:06:56,180
他就给我硬去读七个出来

173
00:06:56,180 --> 00:06:56,689
对不对

174
00:06:56,689 --> 00:06:59,850
然后第二个呢他只给我读了前七个

175
00:06:59,850 --> 00:07:01,100
后面一个丢掉了

176
00:07:01,259 --> 00:07:03,930
假如我现在是这样

177
00:07:03,930 --> 00:07:06,519
我第一个给他超过七个了

178
00:07:07,098 --> 00:07:10,399
我只按了一个回车程序就结束了

179
00:07:10,399 --> 00:07:12,918
没没有机会让我输入第二个

180
00:07:12,918 --> 00:07:13,459
为什么

181
00:07:13,459 --> 00:07:17,538
因为前面七个给了第一个scaf

182
00:07:17,538 --> 00:07:19,158
他把七个读掉了

183
00:07:19,158 --> 00:07:22,879
然后剩下的这个八给了第二个scaf

184
00:07:22,879 --> 00:07:24,720
正好满足了第二个kf

185
00:07:24,779 --> 00:07:27,600
当我们在百分号和s

186
00:07:27,600 --> 00:07:29,279
中间放了一个数字以后

187
00:07:29,279 --> 00:07:32,800
这个数字的意思是说最多读那么多个

188
00:07:32,819 --> 00:07:35,430
如果他就读到了那么多个

189
00:07:35,430 --> 00:07:39,730
那么后面的空格有没有就没有关系了

190
00:07:39,730 --> 00:07:42,189
不是依据空格来区分单词了

191
00:07:42,189 --> 00:07:45,540
而是根据这个数来划定这个单词

192
00:07:45,540 --> 00:07:49,019
所以下面的内容会交给下一个百分号

193
00:07:49,019 --> 00:07:52,240
s或者下面其他的这个scaf去阅读

194
00:07:52,240 --> 00:07:54,519
在面对c语言的字符串的时候

195
00:07:54,519 --> 00:07:56,288
非常常见的一种错误

196
00:07:56,288 --> 00:08:00,529
就是误以为创新就是字符串类型

197
00:08:00,529 --> 00:08:03,230
误以为我们定义一个创新的变量

198
00:08:03,230 --> 00:08:05,600
就是定义了一个字符串的变量

199
00:08:05,600 --> 00:08:08,620
然后这个字符串变量就可以直接用了

200
00:08:10,319 --> 00:08:14,060
比如说像这个页面当中说唉我就chasing string

201
00:08:14,060 --> 00:08:16,540
然后呢直接就skin f摆放s str

202
00:08:17,139 --> 00:08:20,680
实际上第一行charing stream做了什么

203
00:08:20,680 --> 00:08:23,860
我们只是定义了一个指针变量

204
00:08:23,860 --> 00:08:25,449
我们说string是一个

205
00:08:25,449 --> 00:08:30,360
将来要去指向某个这个字符字符串数组的

206
00:08:30,360 --> 00:08:30,930
那么一个

207
00:08:30,930 --> 00:08:33,419
指向某一块内存空间的那么一个指针

208
00:08:33,419 --> 00:08:35,039
但是在这个时刻

209
00:08:35,039 --> 00:08:36,958
这个指针没有被初始化

210
00:08:37,139 --> 00:08:40,740
然后我们知道这是个本地变量的话

211
00:08:40,740 --> 00:08:42,870
本地变量是没有默认初始值的

212
00:08:42,870 --> 00:08:44,519
原来在那个内存里面有什么

213
00:08:44,519 --> 00:08:45,318
它就是什么

214
00:08:45,318 --> 00:08:47,629
所以很有可能你这么做了

215
00:08:47,629 --> 00:08:49,099
他正好指到了某个地方

216
00:08:49,099 --> 00:08:49,578
他不是零

217
00:08:49,578 --> 00:08:50,599
他只到了某个地方

218
00:08:50,599 --> 00:08:52,999
然后你对他去做点什么skin f的操作

219
00:08:52,999 --> 00:08:55,719
往那个他所指的那颗内存里面写点东西

220
00:08:56,139 --> 00:08:58,929
不是每一次内运行都一定出错的

221
00:08:58,929 --> 00:09:02,019
说不定没什么坏事发生

222
00:09:02,019 --> 00:09:05,219
于是你就以为说哦程序可以怎么写

223
00:09:05,379 --> 00:09:09,039
但是一旦它正好等于到那个地方

224
00:09:09,039 --> 00:09:11,078
是个有害的地方的时候

225
00:09:11,320 --> 00:09:13,019
你的程序就会崩溃了

226
00:09:13,299 --> 00:09:14,500
这就是常见的

227
00:09:14,500 --> 00:09:15,759
为什么有人说诶

228
00:09:15,759 --> 00:09:17,559
这个程序在我这运行好好的

229
00:09:17,559 --> 00:09:19,029
为什么到那儿就不对了

230
00:09:19,029 --> 00:09:20,799
为什么在我的电脑上是好的

231
00:09:20,799 --> 00:09:22,859
考到他的电脑上就不好了

232
00:09:23,799 --> 00:09:26,019
指针用错了

233
00:09:26,059 --> 00:09:28,220
指针没有初始化

234
00:09:28,220 --> 00:09:32,039
没有让这个指针指向一个实际有效的地址

235
00:09:32,039 --> 00:09:34,049
这是我们在使用字符串的时候

236
00:09:34,049 --> 00:09:36,750
非常非常常见的初学者错误

237
00:09:36,750 --> 00:09:38,099
还有这个事情

238
00:09:39,139 --> 00:09:40,659
在这个情况下

239
00:09:40,919 --> 00:09:43,980
相邻的紧挨着的两个双引号

240
00:09:43,980 --> 00:09:47,190
他的意思是说这是一个空的字符串

241
00:09:47,190 --> 00:09:49,200
它依然是一个有效的字符串

242
00:09:49,200 --> 00:09:52,110
但是它的第一个就是零

243
00:09:52,110 --> 00:09:55,078
所以buffer的零呢就等于那个零

244
00:09:55,759 --> 00:09:57,370
它还是有效的字符串

245
00:09:57,370 --> 00:09:59,919
可是如果我们把程序写成这个样子

246
00:09:59,940 --> 00:10:01,620
我们期望呢

247
00:10:01,620 --> 00:10:05,559
编译器替我们去制造一个字符串出来

248
00:10:05,559 --> 00:10:08,649
替我们去决定这个数组的长度

249
00:10:08,649 --> 00:10:09,759
如果你这样写的话

250
00:10:09,759 --> 00:10:13,159
那么这个数组的长度只有一

251
00:10:14,220 --> 00:10:17,539
也就是说只有buffer 0是有效的

252
00:10:17,539 --> 00:10:18,649
buffer一就没有了

253
00:10:18,649 --> 00:10:20,059
buffer 0的内容是什么呢

254
00:10:20,059 --> 00:10:20,720
就是那个零

255
00:10:20,720 --> 00:10:22,340
因此其实这个buffer里头

