1
00:00:04,400 --> 00:00:05,799
我们要做这样一件事情

2
00:00:06,179 --> 00:00:07,230
看看怎么做

3
00:00:07,230 --> 00:00:09,630
我们需要正序的来分解一个整数

4
00:00:09,630 --> 00:00:11,199
我们之前做过

5
00:00:11,319 --> 00:00:13,730
在第四周的内容当中

6
00:00:13,730 --> 00:00:16,429
我们做过怎么样逆序的来输出一个数

7
00:00:16,429 --> 00:00:17,390
逆序比较好

8
00:00:17,390 --> 00:00:18,050
说好做

9
00:00:18,050 --> 00:00:18,719
对不对

10
00:00:18,719 --> 00:00:19,500
呃

11
00:00:19,500 --> 00:00:23,429
我们10%就得到它最后面那一位了

12
00:00:23,429 --> 00:00:25,140
但是我们要做证据

13
00:00:25,259 --> 00:00:28,469
假如说我们输入一个非负的整数

14
00:00:28,469 --> 00:00:30,388
比如12313425

15
00:00:30,388 --> 00:00:32,039
我们能够输出一空格三

16
00:00:32,039 --> 00:00:32,518
空格四

17
00:00:32,518 --> 00:00:34,939
空格二空格五啊

18
00:00:34,939 --> 00:00:36,380
正确的把每一位都输出

19
00:00:36,380 --> 00:00:37,909
每一位中间还要留个空格

20
00:00:37,909 --> 00:00:39,409
这事要怎么做呢

21
00:00:39,409 --> 00:00:42,079
如果我们现在已经有了一个x

22
00:00:42,939 --> 00:00:45,179
我们知道我们想要取出它的每一位

23
00:00:45,179 --> 00:00:48,039
我们过去的做法是说我们做个循环

24
00:00:48,500 --> 00:00:50,119
在循环的每一步呢

25
00:00:50,119 --> 00:00:53,520
我们让那个d呢等于百分号

26
00:00:53,520 --> 00:00:55,259
是拿到了他最右边的那一位

27
00:00:55,259 --> 00:00:56,880
然后让x呢粗

28
00:00:56,880 --> 00:00:59,039
等于是把它最右边那位给撇掉

29
00:00:59,039 --> 00:01:03,479
然后我们while呢是看他说你的这个x呢

30
00:01:03,479 --> 00:01:04,819
是不是还是大于零

31
00:01:05,700 --> 00:01:07,099
那么当然拿到了每一位

32
00:01:07,099 --> 00:01:09,980
我们就要print f来输出它的那一位

33
00:01:11,540 --> 00:01:13,780
输出那个d这样子做

34
00:01:13,780 --> 00:01:15,340
我们可以得到逆序的结果

35
00:01:15,340 --> 00:01:19,579
如果我们先让x等于13413425

36
00:01:20,379 --> 00:01:22,500
我们来看一下我们的运行结果

37
00:01:22,500 --> 00:01:24,399
就是52431

38
00:01:26,239 --> 00:01:27,939
那么当然首先这个这个结果

39
00:01:27,939 --> 00:01:28,840
我也不是很满意

40
00:01:28,840 --> 00:01:29,790
比如说呃

41
00:01:29,790 --> 00:01:31,349
我们本来应该在最后呢

42
00:01:31,349 --> 00:01:34,319
再来输出一个反斜杠n来回车一下

43
00:01:34,319 --> 00:01:36,060
我们现在的这个输出结果

44
00:01:36,060 --> 00:01:39,679
和下面的这句finish的这个在一行里头了

45
00:01:40,280 --> 00:01:41,200
加一个回车

46
00:01:41,200 --> 00:01:42,040
它们分成两行

47
00:01:42,040 --> 00:01:43,239
但是呢我们仍然不满意

48
00:01:43,239 --> 00:01:45,819
是这里还是有一个多出了一个末尾的空格

49
00:01:45,819 --> 00:01:46,349
对不对

50
00:01:46,349 --> 00:01:48,810
那么解决这个末尾空格的问题呢

51
00:01:48,810 --> 00:01:49,890
我们可以这样子

52
00:01:49,890 --> 00:01:52,500
我们在这里呢先不输出空格啊

53
00:01:52,620 --> 00:01:55,049
然后呢我们在这儿做个判断

54
00:01:55,049 --> 00:01:56,849
在某种条件下

55
00:01:56,849 --> 00:01:59,679
那我们才输出那个空格

56
00:02:00,480 --> 00:02:03,019
也就是说到了最后一轮的时候

57
00:02:03,019 --> 00:02:04,700
我们希望那个空格不输出

58
00:02:04,700 --> 00:02:05,120
对不对

59
00:02:05,120 --> 00:02:06,439
那么最后一轮的时候

60
00:02:06,439 --> 00:02:07,579
这个情况是什么呢

61
00:02:07,579 --> 00:02:08,780
最后一轮的时候

62
00:02:08,780 --> 00:02:11,620
那个x一定是个个位数

63
00:02:11,620 --> 00:02:16,718
因为如果x假如说x还等于十的话啊

64
00:02:16,718 --> 00:02:18,579
或者说大于等于十的话

65
00:02:18,579 --> 00:02:23,270
那么这个时候x除以十还会大于零

66
00:02:23,270 --> 00:02:26,800
只有当x小于十了

67
00:02:26,800 --> 00:02:30,030
那么x除以十呢会得到一零

68
00:02:30,030 --> 00:02:31,889
那么循环就不会再继续下去

69
00:02:31,889 --> 00:02:34,979
所以最后一轮的特点就是x小于十

70
00:02:34,979 --> 00:02:38,689
那么要让他在非最后一轮去输出那个空格

71
00:02:38,689 --> 00:02:41,150
那么我们的条件就可以是x大于等于十

72
00:02:41,150 --> 00:02:42,949
或者是x大于九

73
00:02:42,949 --> 00:02:43,959
这两个是等价的

74
00:02:43,959 --> 00:02:45,038
现在我们来试一下

75
00:02:45,038 --> 00:02:45,848
这样子的话

76
00:02:45,848 --> 00:02:49,218
我们就看到在这个一后面就没有空格了

77
00:02:49,218 --> 00:02:52,460
那我们就解决了最后的空格的问题

78
00:02:52,639 --> 00:02:54,560
但是这是逆序的

79
00:02:55,819 --> 00:02:57,919
怎么能把它正序倒过来呢

80
00:02:58,118 --> 00:03:00,938
我们知道我们之前还做过一件事情

81
00:03:00,938 --> 00:03:03,519
怎么去把一个整数给它倒过来对吧

82
00:03:03,519 --> 00:03:04,479
整数求逆

83
00:03:04,479 --> 00:03:06,038
假如说我们先做一件事情

84
00:03:06,038 --> 00:03:08,659
把这个整数给它逆过来行不行

85
00:03:08,659 --> 00:03:10,340
也就是说我们先做个循环

86
00:03:10,340 --> 00:03:12,379
我们知道我们逆整数也是做个循环

87
00:03:12,379 --> 00:03:13,490
我们先做个循环

88
00:03:13,490 --> 00:03:14,780
我们需要有另外一个变量

89
00:03:14,780 --> 00:03:18,219
比如说t来构建这个呃

90
00:03:18,219 --> 00:03:19,569
逆序过来以后的那个数

91
00:03:19,569 --> 00:03:20,650
那每一轮呢

92
00:03:20,650 --> 00:03:25,530
我们取出那个x 10%和10%的

93
00:03:25,530 --> 00:03:26,009
那个结果

94
00:03:26,009 --> 00:03:28,530
也就是x就最右边的那一位

95
00:03:28,530 --> 00:03:31,860
然后呢我们让t等于t乘以十呢

96
00:03:31,860 --> 00:03:33,210
去加上这个d

97
00:03:33,210 --> 00:03:36,039
这就把x的最右边那一位

98
00:03:36,039 --> 00:03:38,740
加到这个t哪去了

99
00:03:38,740 --> 00:03:39,400
对吧啊

100
00:03:39,400 --> 00:03:40,810
把它加到t哪去了

101
00:03:40,810 --> 00:03:43,810
然后呢我们要让x呢除

102
00:03:43,810 --> 00:03:45,639
等于是把它最右边那位丢掉

103
00:03:45,639 --> 00:03:47,469
那while的条件呢是什么呢

104
00:03:47,469 --> 00:03:49,520
就是这个x呢是要大于零

105
00:03:49,520 --> 00:03:51,259
好这样呢我们能做一个分解

106
00:03:51,259 --> 00:03:53,300
我们可以在这儿呢输出一个中间

107
00:03:53,300 --> 00:03:55,699
结果说这个时候t等于多少是吧

108
00:03:55,699 --> 00:03:57,789
我们看一下我们的这个呃

109
00:03:57,789 --> 00:03:59,949
逆序这件事情做的是不是对啊

110
00:04:01,270 --> 00:04:02,949
我们来先试一下这个事情

111
00:04:02,949 --> 00:04:06,069
我们看到呢t呢确实逆过来了啊

112
00:04:06,069 --> 00:04:08,969
52431是13425的逆序

113
00:04:08,969 --> 00:04:11,849
可是呢下面在做的时候不对

114
00:04:11,849 --> 00:04:12,509
为什么不对呢

115
00:04:12,509 --> 00:04:15,150
因为这个时候你想我们的x等于多少

116
00:04:15,150 --> 00:04:16,240
我们可以看一下

117
00:04:19,199 --> 00:04:23,059
当这一轮循环做完x的逆序给了t以后

118
00:04:23,059 --> 00:04:24,918
x自己就变成零了

119
00:04:24,918 --> 00:04:25,939
因为x如果不是零

120
00:04:25,939 --> 00:04:26,718
这个循环出不来的

121
00:04:26,718 --> 00:04:27,230
对不对

122
00:04:27,230 --> 00:04:29,569
所以我们想要让x再去参与第

123
00:04:29,569 --> 00:04:30,560
二轮循环的话

124
00:04:30,560 --> 00:04:34,220
我们需要在这里把t的值赋给x好

125
00:04:34,220 --> 00:04:35,500
我们现在来试一下

126
00:04:37,480 --> 00:04:40,230
t是543215252431

127
00:04:40,230 --> 00:04:42,720
然后最后再逆序输出的结果

128
00:04:42,720 --> 00:04:45,079
13425和我们的13425是一样的

129
00:04:45,500 --> 00:04:47,209
哎这看起来很完美对吧

130
00:04:47,209 --> 00:04:48,439
我们先逆序一遍

131
00:04:48,439 --> 00:04:49,639
然后再逆序输出好

132
00:04:49,639 --> 00:04:51,949
我们就得到了一个正序的结果了

133
00:04:51,949 --> 00:04:53,779
可是我们试一下

134
00:04:53,779 --> 00:04:55,300
如果x等于700

135
00:04:57,939 --> 00:04:59,160
x等于700

136
00:04:59,160 --> 00:05:01,480
逆序回来以后就只有七

137
00:05:01,579 --> 00:05:02,959
而不是007

138
00:05:02,959 --> 00:05:03,920
然后再逆序输出

139
00:05:03,920 --> 00:05:05,300
他就只剩下七了

140
00:05:05,300 --> 00:05:07,639
没有给我们七后面的两个零

141
00:05:08,339 --> 00:05:10,579
所以先逆序再逆序的方案

142
00:05:10,579 --> 00:05:13,970
只适用于末尾没有零的那种数字

143
00:05:13,970 --> 00:05:15,480
末尾有零的数字

144
00:05:15,879 --> 00:05:17,019
我们还得换个发

145
00:05:18,519 --> 00:05:20,500
还有什么办法可以解决这个问题呢

146
00:05:22,079 --> 00:05:22,939
你还记不记得

147
00:05:22,939 --> 00:05:25,338
我们在三位数逆序的那个题目里面

148
00:05:25,338 --> 00:05:27,540
我们怎么得到那个百位数字呢

149
00:05:28,220 --> 00:05:29,949
我们得到百位数字是

150
00:05:29,949 --> 00:05:33,610
如果我们这个x是13425

151
00:05:33,610 --> 00:05:35,529
我们想要得到的最高位那一位

152
00:05:35,529 --> 00:05:39,439
我们可以拿13425去除以一四个零

153
00:05:39,439 --> 00:05:40,699
我们就得到了那个一

154
00:05:40,699 --> 00:05:41,420
对不对

155
00:05:43,399 --> 00:05:46,490
啊所以如果我们做了这一步

156
00:05:46,490 --> 00:05:50,509
然后我们拿13425去百分号1万

157
00:05:50,509 --> 00:05:55,439
我们就可以得到把最高位撇掉43425

158
00:05:55,439 --> 00:05:59,009
然后我们让那个1万呢也去除以十

159
00:05:59,009 --> 00:06:01,899
得到一个比较小的那个就是1000

160
00:06:02,740 --> 00:06:07,139
然后剩下的3425去除1000

161
00:06:07,139 --> 00:06:09,389
就可以得到那个最高位三

162
00:06:09,389 --> 00:06:12,540
然后3425去百分号

163
00:06:12,540 --> 00:06:16,649
1000就可以得到那个425

164
00:06:16,649 --> 00:06:20,199
然后1000再除以十

165
00:06:20,199 --> 00:06:24,699
我们就可以得到100用于接下去的计算

166
00:06:24,699 --> 00:06:29,709
然后425÷100

167
00:06:29,709 --> 00:06:34,839
可以得到那一位4425

168
00:06:34,839 --> 00:06:38,379
百分号100可以得到25

169
00:06:38,779 --> 00:06:42,288
100再除以十可以得到十

170
00:06:42,288 --> 00:06:43,728
一直这么算下去

171
00:06:43,728 --> 00:06:45,288
直到什么好

172
00:06:45,288 --> 00:06:46,579
我们就把它算完吧

173
00:06:46,579 --> 00:06:50,699
我们的25要除以那个十来得到那个二

174
00:06:50,699 --> 00:06:55,930
25要百分号十来得到那个50

175
00:06:55,930 --> 00:06:59,079
要除以十来得到那个一

176
00:06:59,079 --> 00:07:05,160
最后我们的五要除以一来得到五五

177
00:07:05,160 --> 00:07:06,660
要百分号一

178
00:07:06,660 --> 00:07:09,120
当然这还是五而一

179
00:07:09,120 --> 00:07:13,379
再除以十的话就得到了零

180
00:07:15,459 --> 00:07:21,139
所以把这里面的这个这个

181
00:07:21,139 --> 00:07:26,779
这个这个这个拿出来就是我们的结果好

182
00:07:26,779 --> 00:07:28,040
我们照着这个来写写代码

183
00:07:28,040 --> 00:07:30,779
看我们这里所有的这些东西都不要了

184
00:07:31,158 --> 00:07:32,329
我们要的是

185
00:07:32,329 --> 00:07:33,499
首先我们得要有个变量

186
00:07:33,499 --> 00:07:34,668
比如说叫做mask

187
00:07:34,668 --> 00:07:36,019
我让它等于1万

188
00:07:36,139 --> 00:07:38,060
然后读一个循环

189
00:07:38,060 --> 00:07:39,589
在这个循环里面

190
00:07:39,589 --> 00:07:45,019
这个int d呢是等于x去除以mask

191
00:07:45,699 --> 00:07:49,959
然后我们让x呢百分号等于mask

192
00:07:49,959 --> 00:07:52,269
x等于x百分号mask

193
00:07:52,269 --> 00:07:55,000
然后mask除等于十

194
00:07:56,160 --> 00:07:57,740
当然循环的每一轮

195
00:07:57,740 --> 00:08:01,980
我们去print f百分号d那个

196
00:08:03,439 --> 00:08:07,490
可是这里的这个条件是什么

197
00:08:07,490 --> 00:08:10,800
以及while的条件是什么

198
00:08:12,800 --> 00:08:15,399
当然我们首先会想到y大于零不就行了吗

199
00:08:15,399 --> 00:08:16,360
跟我们原来是一样的

200
00:08:16,360 --> 00:08:17,079
对不对

201
00:08:19,519 --> 00:08:21,040
我们先这么写的

202
00:08:21,040 --> 00:08:21,850
y大于零

203
00:08:21,850 --> 00:08:23,500
我们先来试一下

204
00:08:23,500 --> 00:08:26,439
然后在这里我们刚才的条件是什么

205
00:08:26,439 --> 00:08:28,670
是x大于九

206
00:08:28,670 --> 00:08:30,019
我们先这么写着

207
00:08:30,019 --> 00:08:30,740
先来试一下

208
00:08:30,740 --> 00:08:33,799
我们看会不会有什么东西是不对的

209
00:08:33,799 --> 00:08:34,919
我们先来看

210
00:08:34,919 --> 00:08:36,360
当然现在要运行之前

211
00:08:36,360 --> 00:08:41,990
我们得把这一段演算的东西给他注释掉啊

212
00:08:41,990 --> 00:08:43,399
留在程序里面没什么啊

213
00:08:43,399 --> 00:08:45,139
这个呃这一段演算蛮好的

214
00:08:45,139 --> 00:08:46,340
我们留在程序里面

215
00:08:46,340 --> 00:08:47,840
有助于别人看懂它是什么

216
00:08:47,840 --> 00:08:49,759
然后我们现在来运行它一下

217
00:08:50,279 --> 00:08:51,200
看起来挺不错的

218
00:08:51,200 --> 00:08:51,500
对不对

219
00:08:51,500 --> 00:08:52,340
13425

220
00:08:52,340 --> 00:08:53,840
当然如果你觉得啊

221
00:08:53,840 --> 00:08:56,120
你对这其中的这些东西的变化还不熟悉

222
00:08:56,120 --> 00:08:57,049
我们可以这样

223
00:08:57,049 --> 00:08:59,600
我们把这一段输出呢先注释掉

224
00:08:59,600 --> 00:09:00,679
然后呢我们之前讲过

225
00:09:00,679 --> 00:09:02,419
我们可以在循环里面加一些输出语句

226
00:09:02,419 --> 00:09:04,039
来看循环每一步的变化

227
00:09:04,039 --> 00:09:06,909
所以我们希望看到说循环的每一步呢

228
00:09:06,909 --> 00:09:08,110
是怎么变的

229
00:09:08,110 --> 00:09:10,159
mask是怎么变的

230
00:09:10,159 --> 00:09:12,559
然后d是怎么变好

231
00:09:12,559 --> 00:09:16,610
于是呢我们要输出这个x mask和这个d

232
00:09:16,610 --> 00:09:18,740
我们来看看它是怎么变化的

233
00:09:18,740 --> 00:09:21,230
我们看到的一开始的时候

234
00:09:21,230 --> 00:09:22,309
最开始的时候

235
00:09:22,309 --> 00:09:25,460
x因为已经除以那个mask 10了啊

236
00:09:25,460 --> 00:09:26,899
已经除以百分号那个mask

237
00:09:26,899 --> 00:09:28,159
所以最高已经丢掉了

238
00:09:28,159 --> 00:09:29,750
最高位呢留到这里来了

239
00:09:29,750 --> 00:09:30,860
这是3425

240
00:09:30,860 --> 00:09:31,980
mask是1000

241
00:09:31,980 --> 00:09:33,899
然后呢mask逐渐又变下来

242
00:09:33,899 --> 00:09:35,399
mask变小变小变小

243
00:09:35,399 --> 00:09:37,769
一直到最后一轮mask已经变成零了

244
00:09:37,769 --> 00:09:40,200
那么当然最后挖了条件就不满足就会出来

245
00:09:40,200 --> 00:09:41,129
对不对啊

246
00:09:41,129 --> 00:09:43,909
这个x呢从34254252555

247
00:09:43,909 --> 00:09:45,649
逐渐的把最高位给丢掉

248
00:09:45,649 --> 00:09:47,990
而d呢就逐渐的得到了最高位来输出

249
00:09:47,990 --> 00:09:50,029
所以最后的d就是13425

250
00:09:50,029 --> 00:09:51,198
这是我们的结果

251
00:09:51,919 --> 00:09:52,960
这看起来挺不错的

252
00:09:52,960 --> 00:09:53,470
对不对

253
00:09:53,470 --> 00:09:56,299
我们再来想一个事情

254
00:09:56,299 --> 00:09:57,980
我们之前提到过一点

255
00:09:57,980 --> 00:10:01,000
说我们的程序要证明它是正确的

256
00:10:01,000 --> 00:10:02,950
不能只拿一个值来证明

257
00:10:02,950 --> 00:10:05,110
我们需要拿一些比较多的数字来说明

258
00:10:05,110 --> 00:10:05,830
我的程序是对的

259
00:10:05,830 --> 00:10:07,210
比如说一些边界的情况

260
00:10:07,210 --> 00:10:09,288
所以如果现在对于这个五位数

261
00:10:09,288 --> 00:10:12,639
我们来试一下7万的话会是怎么样

262
00:10:14,360 --> 00:10:15,779
我们看到不对

263
00:10:16,039 --> 00:10:18,620
我们没有得到期望中的期望

264
00:10:18,620 --> 00:10:20,870
我们得到了只是一个七

265
00:10:20,870 --> 00:10:22,039
只是一个七

266
00:10:22,039 --> 00:10:24,860
我们看到在第一轮过后

267
00:10:24,860 --> 00:10:27,320
因为你想我们对于7万来说

268
00:10:27,320 --> 00:10:28,220
做了个什么事情呢

269
00:10:28,220 --> 00:10:32,159
是那个7万去除了1万

270
00:10:32,320 --> 00:10:33,549
得到了七

271
00:10:33,549 --> 00:10:36,460
然后那个7万呢去百分号了

272
00:10:36,460 --> 00:10:38,169
1万得到了什么

273
00:10:38,169 --> 00:10:39,419
就是零了

274
00:10:41,059 --> 00:10:41,830
对不对

275
00:10:41,830 --> 00:10:44,500
所以我们的这个条件有问题

276
00:10:44,500 --> 00:10:47,879
我们的这个条件其实也会是有问题的

277
00:10:47,879 --> 00:10:51,299
你想当我们x我们的条件是x大于零

278
00:10:51,299 --> 00:10:52,200
对于7万来说

279
00:10:52,200 --> 00:10:53,779
第一轮下来x就是零了

280
00:10:53,779 --> 00:10:54,620
但实际上呢

281
00:10:54,620 --> 00:10:56,840
我们还需要还可以再继续走下去的

282
00:10:56,840 --> 00:10:59,519
因为我们的mask还没有到铃

283
00:10:59,799 --> 00:11:02,909
所以其实我们应该的条件是什么

284
00:11:02,909 --> 00:11:03,870
不是x0 

285
00:11:03,870 --> 00:11:04,649
而是mask

286
00:11:04,649 --> 00:11:06,179
道理我们先试一下这件事情

287
00:11:06,179 --> 00:11:07,830
如果我们让mask

288
00:11:07,830 --> 00:11:09,859
我们的条件判断说mask为零

289
00:11:11,039 --> 00:11:15,139
我们就会得到71234 7万

290
00:11:15,139 --> 00:11:17,000
这是我们想要的答案

291
00:11:17,820 --> 00:11:21,200
顺便这个地方也不能判断x对不对

292
00:11:21,200 --> 00:11:24,320
你看如果我们现在把这个注释给去掉

293
00:11:24,320 --> 00:11:25,220
让它能够显示出来

294
00:11:25,220 --> 00:11:26,940
然后我们把这个注释给加上

295
00:11:26,940 --> 00:11:29,220
我们看一下现在它的输出是什么

296
00:11:31,320 --> 00:11:33,980
它会输出七是带着空格的

297
00:11:33,980 --> 00:11:35,240
后面全部不带空格的

298
00:11:35,240 --> 00:11:35,690
为什么

299
00:11:35,690 --> 00:11:37,580
因为到后面x已经是零了嘛

300
00:11:37,580 --> 00:11:39,799
所以这也不能以x来判断

301
00:11:39,799 --> 00:11:42,200
而应该以mask来判断好

302
00:11:42,200 --> 00:11:44,000
现在这样子的话就对了

303
00:11:44,000 --> 00:11:46,458
我们得到了71234

304
00:11:47,340 --> 00:11:49,730
可是我们的这个代码

305
00:11:49,730 --> 00:11:52,379
现在的这个mask是一个固定的值

306
00:11:52,759 --> 00:11:55,219
对于五位数它是适用的

307
00:11:55,539 --> 00:11:58,029
对于四位数它应该用1000

308
00:11:58,029 --> 00:11:59,889
对于三位数它应该用100

309
00:11:59,889 --> 00:12:03,719
所以这个mask不应该是这样固定的一个数

310
00:12:04,320 --> 00:12:05,539
那么怎么做呢

311
00:12:05,539 --> 00:12:07,519
我们怎么去让程序能够

312
00:12:07,519 --> 00:12:10,839
根据输入的这个x来计算得到这个mask

313
00:12:12,240 --> 00:12:14,179
有一个方案是不是可以这样

314
00:12:14,279 --> 00:12:15,899
我们以前做过另外一件事情

315
00:12:15,899 --> 00:12:18,720
就是去计算一个整数的位数

316
00:12:18,720 --> 00:12:20,039
所以我们能不能这样

317
00:12:20,039 --> 00:12:21,979
我们有一个c n t等于零

318
00:12:22,860 --> 00:12:24,529
然后我们做个循环

319
00:12:24,529 --> 00:12:28,159
我们在循环里面让x除等于十

320
00:12:28,159 --> 00:12:30,019
然后c n t加加

321
00:12:30,279 --> 00:12:33,089
那while呢是这个x大于零

322
00:12:33,089 --> 00:12:35,308
这样子当这一轮循环出来以后

323
00:12:35,308 --> 00:12:38,009
我们可以得到一个x的位数的知识

324
00:12:38,009 --> 00:12:39,549
我们可以先来看一下

325
00:12:39,549 --> 00:12:41,169
我们现在做的这个c nt

326
00:12:41,169 --> 00:12:42,769
这一轮循环是不是对的

327
00:12:42,769 --> 00:12:45,279
我们对于这个13425来说

328
00:12:47,539 --> 00:12:49,339
他的c n t是五

329
00:12:49,799 --> 00:12:51,120
确实这是五位数

330
00:12:51,120 --> 00:12:51,600
对不对

331
00:12:51,600 --> 00:12:51,929
好

332
00:12:51,929 --> 00:12:53,669
如果我们已经得到五位数了

333
00:12:53,669 --> 00:12:56,789
接下来我们怎么能够得到这个五位数的

334
00:12:56,789 --> 00:12:58,289
这个mask呢

335
00:12:58,289 --> 00:13:01,779
这是十的几次方呢

336
00:13:02,980 --> 00:13:04,339
这是十的

337
00:13:05,000 --> 00:13:06,279
十的二次方是100

338
00:13:06,279 --> 00:13:08,339
三次方是1000 十的四次方

339
00:13:09,220 --> 00:13:10,019
11万

340
00:13:10,019 --> 00:13:10,620
对不对

341
00:13:10,620 --> 00:13:13,700
十的四次方就四个是乘起来嘛

342
00:13:13,700 --> 00:13:16,490
所以我们需要去构造一个

343
00:13:16,490 --> 00:13:19,220
十和c n t减一次方

344
00:13:19,220 --> 00:13:22,549
那么其实有同学可能已经知道说

345
00:13:22,549 --> 00:13:24,049
在c里头呢

346
00:13:24,049 --> 00:13:27,769
我们可以用一个函数叫做pw

347
00:13:27,769 --> 00:13:30,458
去替我们算出这个1万来

348
00:13:33,299 --> 00:13:34,820
当然我们可以这么干

349
00:13:34,820 --> 00:13:38,289
但是呢这么干有点没意思

350
00:13:38,289 --> 00:13:43,019
因为你想在我们做这个事情的时候

351
00:13:43,100 --> 00:13:45,740
我们在不断的把x在除时

352
00:13:45,740 --> 00:13:47,960
我们不断在c n t在加加的时候

353
00:13:47,960 --> 00:13:49,759
我们能不能让那个mask

354
00:13:49,759 --> 00:13:51,980
从一开始蹭蹭蹭蹭蹭乘上去

355
00:13:51,980 --> 00:13:52,549
对不对

356
00:13:52,549 --> 00:13:54,259
所以也许我们可以这样做

357
00:13:54,259 --> 00:13:56,440
说我们把mask呢放到这里来

358
00:13:56,440 --> 00:13:58,179
在他厨师的每一轮

359
00:13:58,179 --> 00:14:00,399
我们让mask呢乘等于十

360
00:14:00,399 --> 00:14:02,679
那这个时候我们c n t可以不要他

361
00:14:03,039 --> 00:14:05,259
然后呢我们在这个结束之后

362
00:14:05,259 --> 00:14:06,909
我们来看看mask等于多少

363
00:14:06,909 --> 00:14:10,039
看看这个mask能不能是我们想要的一个值

364
00:14:13,019 --> 00:14:14,779
对于13425

365
00:14:14,779 --> 00:14:19,259
我们的mask是一后面五个零大了一点

366
00:14:19,259 --> 00:14:19,958
对不对

367
00:14:20,100 --> 00:14:21,419
是不是大了一点

368
00:14:21,419 --> 00:14:23,009
我们要一后面四个零就好了

369
00:14:23,009 --> 00:14:23,940
那怎么做呢

370
00:14:23,940 --> 00:14:24,659
那有同学说啊

371
00:14:24,659 --> 00:14:25,200
那这样

372
00:14:25,200 --> 00:14:27,779
那那我出来以后就mask除等于十好了

373
00:14:27,779 --> 00:14:28,818
再除一个十

374
00:14:29,360 --> 00:14:30,799
其实没必要嘛

375
00:14:30,799 --> 00:14:32,059
我们现在差在哪里

376
00:14:32,059 --> 00:14:34,610
差就差在说你循环多跑了一轮嘛

377
00:14:34,610 --> 00:14:36,320
循环多跑一轮就会多乘个十

378
00:14:36,320 --> 00:14:36,740
对不对

379
00:14:36,740 --> 00:14:39,149
所以我们要循环少跑一轮就好了嘛

380
00:14:39,149 --> 00:14:41,789
我们循环结束的条件是x大于九

381
00:14:41,789 --> 00:14:42,509
而不是大于零

382
00:14:42,509 --> 00:14:43,859
现在这样对不对呢

383
00:14:44,019 --> 00:14:46,269
现在这样我们的mask就对了

384
00:14:46,269 --> 00:14:48,698
那么现在这样是不是就是对了呢

385
00:14:48,759 --> 00:14:50,799
啊我们之前反复在说

386
00:14:50,799 --> 00:14:52,000
你一个程序对不对

387
00:14:52,000 --> 00:14:54,399
不是靠一个两个数据可以证明的

388
00:14:54,399 --> 00:14:56,200
你尤其要考虑一些边界情况

389
00:14:56,200 --> 00:14:58,259
比方说如果是十

390
00:14:58,539 --> 00:15:00,129
mask是十

391
00:15:00,129 --> 00:15:00,970
这是对的

392
00:15:00,970 --> 00:15:04,009
因为我们第一次要拿十去除以十

393
00:15:04,009 --> 00:15:04,850
得到那个一

394
00:15:04,850 --> 00:15:06,590
可是如果我是个位数一

395
00:15:06,590 --> 00:15:08,720
我希望我的mask其实是一

396
00:15:08,720 --> 00:15:09,740
而不是十

397
00:15:09,740 --> 00:15:11,649
那么我们怎么改

398
00:15:11,649 --> 00:15:13,620
实际上在这个时候啊

399
00:15:14,019 --> 00:15:16,000
我们之所以对各位是不是会错

400
00:15:16,000 --> 00:15:17,919
因为我们用的是do while循环

401
00:15:18,320 --> 00:15:19,220
不管怎么样

402
00:15:19,220 --> 00:15:20,570
mask都会乘以十的

403
00:15:20,570 --> 00:15:21,379
对不对

404
00:15:23,649 --> 00:15:24,789
我们先判断一下

405
00:15:24,789 --> 00:15:28,029
说如果这个x是大于九的

406
00:15:28,029 --> 00:15:32,169
那我们才需要去让mask做一点变化

407
00:15:32,169 --> 00:15:34,539
否则的话mask就是一就可以了

408
00:15:34,539 --> 00:15:37,919
所以现在这样子呢对于个位数它是对的

409
00:15:37,919 --> 00:15:40,899
甚至对于零他也是对的

410
00:15:40,899 --> 00:15:43,120
对于十它是对的

411
00:15:43,120 --> 00:15:43,779
我们只要十

412
00:15:43,779 --> 00:15:45,620
那么对于刚才的7万呢

413
00:15:45,860 --> 00:15:47,740
当然他还是对的

414
00:15:48,320 --> 00:15:51,110
所以我们在这儿这个while

415
00:15:51,110 --> 00:15:52,460
这个是第一个循环

416
00:15:52,460 --> 00:15:53,179
应该用while

417
00:15:53,179 --> 00:15:56,039
而不是用do while好

418
00:15:56,039 --> 00:15:58,320
然后这样子算完以后

419
00:15:58,320 --> 00:16:00,149
但是我们看到下面

420
00:16:00,149 --> 00:16:04,000
为什么这个变成00007呢

421
00:16:04,000 --> 00:16:05,500
而不是7万呢

422
00:16:05,500 --> 00:16:09,580
因为如果在这儿加上一个输出

423
00:16:09,580 --> 00:16:12,159
说我现在第一轮做完以后x是多少

424
00:16:12,159 --> 00:16:13,720
你看到第一轮做完以后

425
00:16:13,720 --> 00:16:14,980
x已经变成七了

426
00:16:14,980 --> 00:16:18,100
如果我这是13425

427
00:16:18,100 --> 00:16:19,509
第一轮做完以后

428
00:16:19,509 --> 00:16:20,500
x变成一了

429
00:16:20,500 --> 00:16:21,879
只留下最高的一位了

430
00:16:21,879 --> 00:16:23,129
所以怎么办

431
00:16:23,129 --> 00:16:24,690
也就是说在第一轮运算当中

432
00:16:24,690 --> 00:16:26,009
我们已经把s给消耗掉了

433
00:16:26,009 --> 00:16:26,549
对不对

434
00:16:26,549 --> 00:16:29,490
所以那当然呢我们就需要有另外一个变量

435
00:16:29,490 --> 00:16:30,659
让它等于x

436
00:16:30,659 --> 00:16:33,299
然后在第一轮里面我们用t来做运算

437
00:16:33,299 --> 00:16:34,500
而不是用x来做运算

438
00:16:34,500 --> 00:16:36,779
这样我们就可以保持我们的x不变

439
00:16:36,779 --> 00:16:39,159
于是13425就对了

440
00:16:39,159 --> 00:16:40,720
我们可以再试试一下

441
00:16:40,720 --> 00:16:43,690
对于7万它是对的

442
00:16:43,690 --> 00:16:46,809
对于七它是对的

443
00:16:46,809 --> 00:16:49,600
对于十它是对的

444
00:16:49,600 --> 00:16:53,159
那么对于零呢他还是对的

445
00:16:53,159 --> 00:16:55,860
这才是我们正确的程序

