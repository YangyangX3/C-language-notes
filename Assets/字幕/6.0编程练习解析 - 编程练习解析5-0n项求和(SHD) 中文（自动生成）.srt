1
00:00:04,639 --> 00:00:05,660
好我们再看这道题目

2
00:00:05,660 --> 00:00:07,339
求序列的前n项的和这道题目

3
00:00:07,339 --> 00:00:08,689
我们在类似的题目

4
00:00:08,689 --> 00:00:10,490
我们在这个课程当中讲过对吧

5
00:00:10,490 --> 00:00:12,589
我们讲的是一加分之1+1/3

6
00:00:12,589 --> 00:00:14,869
我们还讲了一加分之1-1/3等等

7
00:00:14,869 --> 00:00:16,760
呃1-1/2+1/3啊

8
00:00:16,760 --> 00:00:18,350
呃我们讲过类似的东西

9
00:00:18,350 --> 00:00:20,929
那么这道题目其实很相似啊

10
00:00:20,929 --> 00:00:23,940
我们要呃做前n项的和

11
00:00:23,940 --> 00:00:26,699
那么基本来说这没有什么难度的对吧

12
00:00:26,699 --> 00:00:28,379
呃第一项是1/2

13
00:00:28,379 --> 00:00:32,139
那么第二项呢就是分子呢是前两项的分子

14
00:00:32,139 --> 00:00:35,420
分母和分母呢是前一项的这个啊分子

15
00:00:35,420 --> 00:00:36,859
那么呃在这个当中

16
00:00:36,859 --> 00:00:39,079
其实有点类似于我们之前说过

17
00:00:39,079 --> 00:00:41,420
我们怎么样去做a和b两个变量的交换

18
00:00:41,420 --> 00:00:41,780
对吧

19
00:00:41,780 --> 00:00:43,490
因为它体现了有一种交换

20
00:00:43,490 --> 00:00:45,710
你如果直接拿来做加经验可能会有问题

21
00:00:45,710 --> 00:00:47,909
我们来看这个程序可以写成什么样子

22
00:00:47,909 --> 00:00:49,979
所以呢这个程序其实并不复杂哈

23
00:00:49,979 --> 00:00:52,899
呃我们有先读进来一个

24
00:00:52,899 --> 00:00:54,700
然后呢我们有两个变量啊

25
00:00:54,700 --> 00:00:56,560
david呢是那个分子

26
00:00:56,560 --> 00:00:57,969
deviser呢是那个分母

27
00:00:57,969 --> 00:01:00,250
所以呢我们先让他们是一开始的那个

28
00:01:00,250 --> 00:01:01,689
二合一是吧

29
00:01:01,689 --> 00:01:02,200
然后呢

30
00:01:02,200 --> 00:01:05,349
我们呃因为这个这个呃i呢

31
00:01:05,349 --> 00:01:06,310
要从第一项开始

32
00:01:06,310 --> 00:01:09,430
所以我们呃让它从等于一到小于等于n

33
00:01:09,430 --> 00:01:10,510
i呢每次加价

34
00:01:10,510 --> 00:01:12,459
那么我们有一个变量sum

35
00:01:12,459 --> 00:01:14,650
那么这个some呢就等于呃division

36
00:01:14,650 --> 00:01:16,569
分子除以分母devices

37
00:01:16,569 --> 00:01:17,170
然后呢

38
00:01:17,170 --> 00:01:19,629
我们用一个临时变量te去交换一下

39
00:01:19,629 --> 00:01:20,590
dividend和deviser

40
00:01:20,590 --> 00:01:22,689
因为dividend呢会变成dividend加device

41
00:01:22,689 --> 00:01:25,519
就下一项的分子会变成分子加分母

42
00:01:25,519 --> 00:01:27,558
而下一项的分母会变成原来那个分子

43
00:01:27,558 --> 00:01:29,709
所以我们要用这个t去暂存一下

44
00:01:29,709 --> 00:01:31,269
然后整个循环做出来就可以了

45
00:01:31,269 --> 00:01:33,069
那很多同学这个都能做对

46
00:01:33,069 --> 00:01:36,030
然后呢但是很多同学一开始做的时候

47
00:01:36,030 --> 00:01:37,530
因为我们的那个分子

48
00:01:37,530 --> 00:01:39,569
分母明显表现出来是一种整数嘛

49
00:01:39,569 --> 00:01:41,659
所以他会用int来做这件事情

50
00:01:41,659 --> 00:01:42,019
好

51
00:01:42,019 --> 00:01:44,420
这道题目呢表面上看起来人畜无害的是吧

52
00:01:44,420 --> 00:01:45,650
这很简单一道题目

53
00:01:45,650 --> 00:01:47,659
可是很多同学交上去以后发现说诶

54
00:01:47,659 --> 00:01:50,099
为什么我最后一个测试点数据就不对了

55
00:01:51,500 --> 00:01:54,219
实际上我们可以考虑一下这件事情

56
00:01:54,219 --> 00:01:58,079
你想我们在循环里头要不断的让division diva

57
00:01:58,079 --> 00:01:59,790
division device要去加起来

58
00:01:59,790 --> 00:02:00,959
不断的去加起来

59
00:02:00,959 --> 00:02:03,480
这个累积的过程可能是很快的

60
00:02:03,480 --> 00:02:04,260
我们可以试一下

61
00:02:04,260 --> 00:02:06,379
如果我们在循环结束以后

62
00:02:06,379 --> 00:02:09,500
去输出一下我们的deviant和device的值

63
00:02:09,500 --> 00:02:11,659
我们看看当我们n等于

64
00:02:11,659 --> 00:02:15,340
比如说如果n等于这个十的时候

65
00:02:15,340 --> 00:02:16,729
这个值是多少呢

66
00:02:16,729 --> 00:02:18,560
这是233和144

67
00:02:18,560 --> 00:02:19,550
看起来还比较小

68
00:02:19,550 --> 00:02:20,000
对不对

69
00:02:20,000 --> 00:02:21,300
当它是20的时候

70
00:02:21,300 --> 00:02:24,719
这个值呢就已经变成2万多和1万多

71
00:02:24,719 --> 00:02:26,370
而当它是200的时候

72
00:02:26,370 --> 00:02:30,280
我们看到这个david和device已经变成负的了

73
00:02:31,618 --> 00:02:32,778
为什么会变成负的

74
00:02:32,778 --> 00:02:33,889
它不是加起来的吗

75
00:02:33,889 --> 00:02:34,579
越加越大

76
00:02:34,579 --> 00:02:36,229
怎么会加重负的来呢

77
00:02:36,229 --> 00:02:40,098
这和计算机里头整数或者说c语言里头

78
00:02:40,098 --> 00:02:41,359
整数是怎么表达的

79
00:02:41,359 --> 00:02:42,129
是有关系的

80
00:02:42,129 --> 00:02:44,800
这正是我们在第六周要学习的内容

81
00:02:44,800 --> 00:02:46,270
我们的整数是有范围的

82
00:02:46,270 --> 00:02:47,219
不是无限的

83
00:02:47,219 --> 00:02:49,319
当它大大大大大大到一定程度

84
00:02:49,319 --> 00:02:52,370
要越过那个整数的上界的时候

85
00:02:52,370 --> 00:02:54,939
它就会翻回来变成负的

86
00:02:55,079 --> 00:02:57,149
所以这道题目的问题是在于说

87
00:02:57,149 --> 00:03:00,139
如果你用int来表达dividend和devor

88
00:03:00,479 --> 00:03:02,969
我们的这个最后的结果还很小

89
00:03:02,969 --> 00:03:05,560
但是我们在计算过程当中

90
00:03:05,560 --> 00:03:08,139
dividend和device已经不对了

91
00:03:08,139 --> 00:03:11,740
所以我们要用更大的范围的变量来表类型

92
00:03:11,740 --> 00:03:12,280
来表达它

93
00:03:12,280 --> 00:03:14,680
我们刚我们已经学过的只有另外一种类型

94
00:03:14,680 --> 00:03:15,449
就是double

95
00:03:15,449 --> 00:03:19,169
所以如果我们用double来表达devia和divide的

96
00:03:19,169 --> 00:03:21,060
那么当然我们的t也要变成double

97
00:03:21,060 --> 00:03:23,240
这个时候我们还可以在中间来监视一下

98
00:03:23,240 --> 00:03:26,300
如果我们这个输出division和device的结果

99
00:03:26,300 --> 00:03:28,580
我们现在看到如果是这样的话

100
00:03:28,580 --> 00:03:30,930
你看在n等于200的时候

101
00:03:30,930 --> 00:03:33,449
这已经是相当大的数字了

102
00:03:33,449 --> 00:03:36,338
已经是相当大的数字了啊

103
00:03:36,338 --> 00:03:39,068
事实上这个式子算不到非常大

104
00:03:39,068 --> 00:03:40,620
如果到2000的时候

105
00:03:41,919 --> 00:03:42,780
到2000的时候

106
00:03:42,780 --> 00:03:45,060
我们看到dividend和devor的输出

107
00:03:45,060 --> 00:03:47,400
结果已经是i n f

108
00:03:47,400 --> 00:03:48,990
意思是越界了

109
00:03:48,990 --> 00:03:52,560
然后最后的一个some的结果是n a n e4 式

110
00:03:52,560 --> 00:03:56,028
这是一个你已经是一个无效的浮点数了啊

111
00:03:56,028 --> 00:03:58,969
所以其实因为我们要做david和device的

112
00:03:58,969 --> 00:04:00,229
加这个累积以后

113
00:04:00,229 --> 00:04:02,330
它会变得长得非常的快啊

114
00:04:02,330 --> 00:04:03,259
长得非常的快

115
00:04:03,259 --> 00:04:06,360
所以呃其实它不能算很多项啊

116
00:04:06,360 --> 00:04:09,599
而且我们还得用double这样的这个数据类型

117
00:04:09,599 --> 00:04:11,759
来表达这里面的division和device

