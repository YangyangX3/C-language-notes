1
00:00:05,059 --> 00:00:09,259
佐伊做的事情是说用两个很形象对吧

2
00:00:09,259 --> 00:00:10,580
两个小于号表达式

3
00:00:10,580 --> 00:00:13,330
左1i小于小于j的意思是说

4
00:00:13,330 --> 00:00:17,739
我们要把i当中所有的位向左移动

5
00:00:17,739 --> 00:00:18,699
减一个位置

6
00:00:18,699 --> 00:00:20,699
而右边呢填零

7
00:00:21,039 --> 00:00:23,559
也就是说ok啊

8
00:00:23,559 --> 00:00:28,550
假如说我们现在有10100101

9
00:00:28,550 --> 00:00:29,690
所以这是a5 

10
00:00:29,690 --> 00:00:30,469
对不对

11
00:00:30,469 --> 00:00:33,098
我们要求它呢往左边移两位

12
00:00:33,240 --> 00:00:36,479
那一位就意味着这两位呢会被移出去对吧

13
00:00:36,479 --> 00:00:38,549
它其实移到外面去了一零

14
00:00:38,549 --> 00:00:40,409
然后0101

15
00:00:40,409 --> 00:00:42,698
最后右边呢填两位零

16
00:00:42,719 --> 00:00:44,520
因此这样留下来的是什么呢

17
00:00:44,520 --> 00:00:45,689
这是九

18
00:00:45,689 --> 00:00:46,979
这是四

19
00:00:47,399 --> 00:00:48,780
我们来写写程序

20
00:00:48,780 --> 00:00:50,829
试试看这个呃移位的运算哈

21
00:00:50,829 --> 00:00:53,829
如果呢我们现在有一个a5 啊

22
00:00:53,829 --> 00:00:55,240
就像我们刚才那个a51 样

23
00:00:55,240 --> 00:00:57,670
那么这是如果我们输出啊

24
00:00:57,670 --> 00:00:58,909
直接输出就是a5 

25
00:00:58,909 --> 00:01:00,710
如果我们要输出

26
00:01:00,710 --> 00:01:03,159
说他左移两位

27
00:01:04,780 --> 00:01:06,599
那么我们要做的是c

28
00:01:08,760 --> 00:01:09,780
所以两位

29
00:01:11,840 --> 00:01:13,930
但我们编译就会遇到一个warning

30
00:01:13,930 --> 00:01:14,859
为什么呢

31
00:01:14,859 --> 00:01:18,340
这个亡灵是说这个运算的类型

32
00:01:18,340 --> 00:01:21,579
这个结果已经是一个int了

33
00:01:22,040 --> 00:01:25,280
所有的这种安慰运算呃

34
00:01:25,299 --> 00:01:27,280
但是这和编译器有关哈

35
00:01:27,280 --> 00:01:28,810
在我们现在这个编译器里头

36
00:01:28,810 --> 00:01:30,519
所有的这些安慰运算的结果

37
00:01:30,519 --> 00:01:32,370
都被当做是int了

38
00:01:32,370 --> 00:01:33,930
所以我们可以先试试看

39
00:01:33,930 --> 00:01:35,670
如果我们按照int的方式来输出

40
00:01:35,670 --> 00:01:37,039
它是会怎么样子的

41
00:01:39,379 --> 00:01:42,260
啊我们得到说上面这个叫做a5 

42
00:01:42,260 --> 00:01:43,799
下面这个是294

43
00:01:44,319 --> 00:01:44,680
呃

44
00:01:44,680 --> 00:01:46,239
我们刚才在那边看到了九四

45
00:01:46,239 --> 00:01:48,129
其实我们左边移出去的那两位

46
00:01:48,129 --> 00:01:50,819
刚好形成了一个16进制的二对吧

47
00:01:51,060 --> 00:01:52,560
呃我们还可以再看一下

48
00:01:52,560 --> 00:01:56,099
如果我们不拿它当做这个16进制来

49
00:01:56,099 --> 00:01:58,618
我们把它当作十进制来输出的时候

50
00:01:59,359 --> 00:02:01,000
一个是165

51
00:02:01,000 --> 00:02:02,679
一个是660

52
00:02:03,519 --> 00:02:05,280
有没有数学好的

53
00:02:05,280 --> 00:02:06,299
立刻算一下

54
00:02:06,299 --> 00:02:09,080
165和660之间是什么关系呢

55
00:02:11,718 --> 00:02:13,989
四倍的关系啊

56
00:02:13,989 --> 00:02:15,819
这正好是四倍的关系

57
00:02:16,239 --> 00:02:18,639
如果我们把一个数往左移一位

58
00:02:18,639 --> 00:02:20,269
就等价于它乘二

59
00:02:20,269 --> 00:02:21,468
往左移两位

60
00:02:21,468 --> 00:02:22,729
等价于它乘四

61
00:02:22,729 --> 00:02:23,989
往左移n位

62
00:02:23,989 --> 00:02:26,659
等价于它乘二的n次方

63
00:02:27,498 --> 00:02:30,098
那我们最多可以多少位呢

64
00:02:32,079 --> 00:02:33,680
取决于你的int有多大

65
00:02:35,438 --> 00:02:36,479
对于左移

66
00:02:36,479 --> 00:02:38,998
我们还有右移右移的意思呢

67
00:02:38,998 --> 00:02:41,800
所有的位向右移若干位

68
00:02:42,219 --> 00:02:44,859
那么所有小于int类型

69
00:02:44,859 --> 00:02:47,139
一位是以int方式做的结果还是int啊

70
00:02:47,139 --> 00:02:49,379
这个我们前面在讲左一的时候已经看到了

71
00:02:49,379 --> 00:02:50,580
对于on side

72
00:02:50,580 --> 00:02:51,719
如果你的int是inside

73
00:02:51,719 --> 00:02:53,199
那么在左边会填零

74
00:02:53,199 --> 00:02:55,689
但是如果你你的int是sign的

75
00:02:55,689 --> 00:02:57,669
左边会填原来的最高位

76
00:02:57,669 --> 00:02:59,969
换句话说保持符号不变

77
00:02:59,969 --> 00:03:00,930
这是什么意思呢

78
00:03:00,930 --> 00:03:01,919
我们试一下

79
00:03:02,419 --> 00:03:05,780
我们有一个int a是等于零

80
00:03:05,780 --> 00:03:08,919
x80000000 

81
00:03:09,000 --> 00:03:10,409
这个数是什么意思呢

82
00:03:10,409 --> 00:03:15,860
这个数是一个四位的整数

83
00:03:15,860 --> 00:03:18,979
四字节的整数所能够表达的一个

84
00:03:18,979 --> 00:03:20,419
最大的负数

85
00:03:22,000 --> 00:03:24,099
我的高位为一了嘛

86
00:03:24,099 --> 00:03:26,120
所以他一定是个负数啊

87
00:03:26,399 --> 00:03:29,579
然后我们另外有一个unsigned int b呢

88
00:03:33,079 --> 00:03:36,580
那我们来看一下这个a等于多少

89
00:03:36,919 --> 00:03:38,240
百分号d的形式啊

90
00:03:38,240 --> 00:03:43,399
我们来说说a然后呢b等于多少

91
00:03:43,399 --> 00:03:45,438
也是也是100分号d的形式

92
00:03:45,438 --> 00:03:47,080
来输出这个a啊

93
00:03:47,080 --> 00:03:48,699
当然这时候可能用d不合适

94
00:03:48,699 --> 00:03:49,419
因为d是有-2

95
00:03:49,419 --> 00:03:51,250
等我们1%又来输出啊

96
00:03:51,250 --> 00:03:52,840
然后呢我们要做下一位

97
00:03:52,840 --> 00:03:55,419
我们让它向右移一位

98
00:03:59,699 --> 00:04:01,139
这是b啊

99
00:04:01,560 --> 00:04:04,080
然后呢右移一位

100
00:04:04,080 --> 00:04:06,300
b呢也右移一位是吧

101
00:04:06,300 --> 00:04:09,580
然后这是我们要看右移一位以后的结果

102
00:04:12,139 --> 00:04:17,399
我们看到的a是一个负数啊

103
00:04:17,399 --> 00:04:20,639
b呢是一个正数

104
00:04:21,939 --> 00:04:26,639
然后a又移了一位以后

105
00:04:26,639 --> 00:04:28,439
它还是一个复数

106
00:04:29,000 --> 00:04:30,879
b又移了一位以后呢

107
00:04:30,879 --> 00:04:33,908
它也还是一个正数

108
00:04:33,908 --> 00:04:35,738
它并没有变富

109
00:04:36,759 --> 00:04:42,560
本来你想如果说a作为一个非负数啊

110
00:04:42,560 --> 00:04:45,470
啊a作为一个这个非呃

111
00:04:45,470 --> 00:04:47,259
作为一个有符号的整数

112
00:04:47,439 --> 00:04:49,480
它实际上如果我们把它写成二进制

113
00:04:49,480 --> 00:04:50,379
相当于这样

114
00:04:52,519 --> 00:04:54,079
很多个零

115
00:04:55,079 --> 00:04:56,598
如果你直接移

116
00:04:56,598 --> 00:04:57,858
说我要往右移

117
00:04:57,858 --> 00:05:00,800
那就变成会是这样子的一个东西对吧

118
00:05:02,519 --> 00:05:05,660
那么这样子一个数呢就不是负数

119
00:05:05,660 --> 00:05:06,639
而是正数了

120
00:05:06,639 --> 00:05:09,399
现在我们看到把a又移了一位以后

121
00:05:09,399 --> 00:05:11,110
它仍然是一个负数

122
00:05:16,259 --> 00:05:17,459
没有被移走

123
00:05:17,459 --> 00:05:20,038
这一位一留在了那里

124
00:05:20,038 --> 00:05:22,800
而这一位一被移到这儿来了

125
00:05:24,519 --> 00:05:27,959
所以他其实得到的是这个这个数

126
00:05:27,959 --> 00:05:30,059
我们把这位一移过去

127
00:05:30,059 --> 00:05:32,579
然后还填上了原来的那个保持的那个方位

128
00:05:32,579 --> 00:05:33,079
一

129
00:05:33,560 --> 00:05:34,850
我们可以试一下

130
00:05:34,850 --> 00:05:37,220
如果我现在a不是八

131
00:05:37,220 --> 00:05:40,579
你看因为这个对于16进制来说是什么呢

132
00:05:40,579 --> 00:05:42,439
a b c这是c

133
00:05:42,860 --> 00:05:43,699
我们看一下

134
00:05:43,699 --> 00:05:45,319
如果这是0c的话

135
00:05:45,319 --> 00:05:47,740
大家可以记一下这个数

136
00:05:49,000 --> 00:05:49,800
看到没有

137
00:05:49,800 --> 00:05:50,899
就是这个啊

138
00:05:52,480 --> 00:05:54,990
所以往右移的时候

139
00:05:54,990 --> 00:05:57,540
有符号和没符号是不一样的

140
00:05:57,540 --> 00:05:58,769
而往左移呢

141
00:05:58,769 --> 00:06:00,439
不管这个符号位的事情

142
00:06:00,639 --> 00:06:02,120
我们来试一下

143
00:06:02,279 --> 00:06:05,100
我们还是用刚才的这个高位为一的

144
00:06:05,100 --> 00:06:06,389
那个八啊

145
00:06:06,389 --> 00:06:07,449
用这个数

146
00:06:07,449 --> 00:06:10,750
然后呢我们做它的左移

147
00:06:10,750 --> 00:06:12,980
我们看看得到什么结果

148
00:06:13,180 --> 00:06:15,879
你看无论有符号无符号

149
00:06:15,879 --> 00:06:20,240
往往佐以以后的结果都变成零了

150
00:06:20,699 --> 00:06:21,660
为什么

151
00:06:21,660 --> 00:06:24,000
因为这个数不就是10万

152
00:06:24,000 --> 00:06:25,379
后面很多个零对吧

153
00:06:25,379 --> 00:06:27,000
然后我们现在说啊

154
00:06:27,000 --> 00:06:27,810
往左移一格

155
00:06:27,810 --> 00:06:28,620
大家都移过去

156
00:06:28,620 --> 00:06:31,180
然后还是0000

157
00:06:31,560 --> 00:06:33,060
结果大家都变成零了

158
00:06:33,060 --> 00:06:35,040
所以往左移的时候是不管符号位的啊

159
00:06:35,040 --> 00:06:36,709
往右移是要管符号位的

160
00:06:36,709 --> 00:06:39,410
另外呢移位的时候负这个位数啊

161
00:06:39,410 --> 00:06:40,129
不要用复数

162
00:06:40,129 --> 00:06:43,970
你不要想着往左移两位和往右移-2位

163
00:06:43,970 --> 00:06:44,899
是不是一回事

164
00:06:44,899 --> 00:06:47,389
这是没有定义的行为呃

165
00:06:47,389 --> 00:06:49,879
不同的编译器完全可能给出不同的结果

166
00:06:49,879 --> 00:06:53,300
甚至给出跟一位没有关系的结果

167
00:06:53,300 --> 00:06:55,019
所以一位的位数不要用复数

