1
00:00:04,299 --> 00:00:06,700
可是这个整数在计算机的内部

2
00:00:06,700 --> 00:00:07,480
又是怎么表达呢

3
00:00:07,480 --> 00:00:09,189
我们现在知道说一个int

4
00:00:09,189 --> 00:00:11,320
表达的是一个寄存器的大小

5
00:00:11,320 --> 00:00:14,560
比int小的表达的是计算机当中的某些位

6
00:00:14,560 --> 00:00:16,899
比int大的可能是几个计算机拼起来

7
00:00:16,899 --> 00:00:18,160
那在计算机内部

8
00:00:18,160 --> 00:00:20,019
我们怎么去表达一个整数呢

9
00:00:20,339 --> 00:00:21,359
在计算机内部

10
00:00:21,359 --> 00:00:22,739
当然一切都是二进制

11
00:00:22,739 --> 00:00:24,269
不管你是整数还是浮点数

12
00:00:24,269 --> 00:00:26,070
最终他们都是二进制的东西

13
00:00:26,070 --> 00:00:29,239
只是说我们以什么方式去看待它

14
00:00:29,239 --> 00:00:31,010
这句话非常重要

15
00:00:31,010 --> 00:00:34,000
所有的类型最终的意义是说

16
00:00:34,000 --> 00:00:35,560
我们以什么方式去看待它

17
00:00:35,560 --> 00:00:38,289
而并不是表明它在内部是怎么表达的

18
00:00:38,289 --> 00:00:40,780
比如说如果我们有一个整数叫做18

19
00:00:40,780 --> 00:00:41,859
我举这个例子是

20
00:00:41,859 --> 00:00:44,109
因为大家如果做过b c d那个题目

21
00:00:44,109 --> 00:00:47,340
一定被这个18还有什么0x12 啊

22
00:00:47,340 --> 00:00:49,128
给给给折腾的够呛

23
00:00:49,128 --> 00:00:50,719
如果说我们有一个18

24
00:00:50,719 --> 00:00:53,149
那么这个18在计算机内部

25
00:00:53,149 --> 00:00:55,789
它是00010010

26
00:00:55,789 --> 00:00:57,950
这样的一个二进制数来表达

27
00:00:57,950 --> 00:00:58,829
这个18

28
00:00:58,829 --> 00:00:59,850
如果是零

29
00:00:59,850 --> 00:01:01,109
那么在计算机内部

30
00:01:01,109 --> 00:01:03,058
它就是00000000

31
00:01:03,140 --> 00:01:06,019
可是如果是一个复试吧

32
00:01:06,099 --> 00:01:08,829
他在计算机内部应该被表达为什么样子的

33
00:01:08,829 --> 00:01:10,299
我们十进制的时候

34
00:01:10,299 --> 00:01:13,859
我们用一个负号来表达复数

35
00:01:14,239 --> 00:01:16,340
然后在我们做计算的时候

36
00:01:16,340 --> 00:01:18,019
实际上我们是怎么去做计算的

37
00:01:18,019 --> 00:01:20,239
比如说如果现在我们想要算

38
00:01:20,239 --> 00:01:24,099
说12加上那个负的18

39
00:01:25,180 --> 00:01:27,040
实际上我们就会把它换成说

40
00:01:27,040 --> 00:01:29,620
我要把这个这个加号

41
00:01:29,620 --> 00:01:30,879
因为和后面是个负数

42
00:01:30,879 --> 00:01:32,469
所以我把加号变成减号

43
00:01:32,469 --> 00:01:35,359
我就变成12-18

44
00:01:35,359 --> 00:01:37,609
最后我得到一个-6的结果

45
00:01:37,609 --> 00:01:38,750
如果是做减法的

46
00:01:38,750 --> 00:01:40,670
我说12要去减-18

47
00:01:40,670 --> 00:01:44,750
那么实际上我们就会把它变成12+18

48
00:01:44,750 --> 00:01:47,150
然后我们得到了一个30的结果

49
00:01:47,150 --> 00:01:48,769
我们在做十进制运算的时候

50
00:01:48,769 --> 00:01:50,000
那个负号是特别的

51
00:01:50,000 --> 00:01:51,439
是在数字之外的

52
00:01:51,439 --> 00:01:53,150
它不是和数字在一起的

53
00:01:53,150 --> 00:01:55,680
是在数值之外来表达这个啊

54
00:01:55,680 --> 00:01:57,659
它是一个负数的那么一个特殊的符号

55
00:01:57,659 --> 00:02:00,250
我们用这个特殊的符号来做呃表达

56
00:02:00,250 --> 00:02:01,209
然后在计算的时候

57
00:02:01,209 --> 00:02:02,409
我们要对它做特殊的处理

58
00:02:02,409 --> 00:02:06,280
所以如果我们要做12乘以-18的时候

59
00:02:06,280 --> 00:02:11,758
实际上我们会做的是12x18的结果

60
00:02:11,758 --> 00:02:12,969
再取负

61
00:02:12,969 --> 00:02:14,289
如果我们要做除法

62
00:02:14,289 --> 00:02:16,389
说12除以-18的时候

63
00:02:16,389 --> 00:02:18,310
实际上我们做的也是负的

64
00:02:18,310 --> 00:02:19,519
12÷18

65
00:02:19,519 --> 00:02:20,899
我们在十进制的时候

66
00:02:20,899 --> 00:02:23,689
其实我们总是把那个负号给抛掉

67
00:02:23,689 --> 00:02:25,669
把它当做一个整数来做运算

68
00:02:25,669 --> 00:02:28,009
然后在运算的结果上面

69
00:02:28,009 --> 00:02:31,349
再去设法处理那个符号的问题

70
00:02:31,349 --> 00:02:32,699
这是十进制

71
00:02:32,699 --> 00:02:34,439
那二进制怎么做呢

72
00:02:34,439 --> 00:02:35,909
我们来考虑说呃

73
00:02:35,909 --> 00:02:38,560
如果我的现在的数是一个字节那么大

74
00:02:38,560 --> 00:02:40,240
也就是说有八个比特

75
00:02:40,240 --> 00:02:41,560
那么这八个比特

76
00:02:41,560 --> 00:02:43,330
就意味着它可以表达的数呢

77
00:02:43,330 --> 00:02:46,469
是从0000~11112进制的

78
00:02:46,469 --> 00:02:47,729
每一位只能是零或者一

79
00:02:47,729 --> 00:02:50,610
所以全零是它能够表达的最小的数

80
00:02:50,610 --> 00:02:53,129
全一甚至还能够表达的最大的数

81
00:02:53,129 --> 00:02:57,020
0000对应的十进制就是01111

82
00:02:57,020 --> 00:02:59,900
八个一对应的十进制就是255

83
00:02:59,900 --> 00:03:03,500
那么怎么在这个当中去表达出负数来呢

84
00:03:04,379 --> 00:03:05,639
有三种方案

85
00:03:06,179 --> 00:03:09,058
第一种方案是说我们仿造时

86
00:03:09,058 --> 00:03:12,269
禁止我们有一个特殊的标志去表示复数

87
00:03:12,269 --> 00:03:14,520
这个标志是在这个数以外的

88
00:03:14,819 --> 00:03:16,439
在这个八个比特以外

89
00:03:16,439 --> 00:03:17,819
我们有另外一个东西

90
00:03:17,819 --> 00:03:18,840
比如说有一个比特

91
00:03:18,840 --> 00:03:21,189
那个比特如果是一表示是正数

92
00:03:21,189 --> 00:03:23,050
那个比特如果是零表示是负数

93
00:03:23,050 --> 00:03:24,189
或者反过来都可以

94
00:03:24,189 --> 00:03:25,750
反正我们有一个特殊的标志

95
00:03:25,750 --> 00:03:27,819
说这个数是正的还是负的

96
00:03:27,819 --> 00:03:29,530
这个标志是在这个数以外的

97
00:03:29,530 --> 00:03:30,669
这是一种方案

98
00:03:30,669 --> 00:03:31,930
还有一个方案是

99
00:03:31,930 --> 00:03:37,120
我们可以说我们取中间那个数为零

100
00:03:37,778 --> 00:03:40,139
对于0000~11来说

101
00:03:40,139 --> 00:03:43,049
它的中间那个数就是10万

102
00:03:43,049 --> 00:03:45,560
然后我们说它表示零

103
00:03:45,679 --> 00:03:47,899
所有比它小的都是负数

104
00:03:47,899 --> 00:03:49,879
比他大的都是正数

105
00:03:51,659 --> 00:03:53,740
但是这两种方案

106
00:03:54,860 --> 00:03:57,280
对于二进制来说都存在问题

107
00:03:57,280 --> 00:03:58,900
第一种方案就意味着

108
00:03:58,900 --> 00:04:01,998
我们需要在设计计算机

109
00:04:01,998 --> 00:04:04,399
来对二进制数据做加法

110
00:04:04,399 --> 00:04:05,539
减法的时候

111
00:04:06,199 --> 00:04:08,520
我们要像做十进制运算一样

112
00:04:08,520 --> 00:04:11,280
特别的去判断这个特殊的标志

113
00:04:11,280 --> 00:04:16,100
如果说现在呢我们的00000001

114
00:04:16,100 --> 00:04:17,240
这个本来是一

115
00:04:17,240 --> 00:04:20,750
我还有另外的一个比特表示说这是个-1

116
00:04:20,750 --> 00:04:24,040
然后他要和正的那个一去做相加

117
00:04:24,040 --> 00:04:29,100
和00000001要去做加法的时候

118
00:04:29,980 --> 00:04:32,579
你就不能直接拿它当二进制来做加法

119
00:04:32,579 --> 00:04:33,420
你得说啊

120
00:04:33,420 --> 00:04:34,500
因为这里有个一

121
00:04:34,500 --> 00:04:36,980
所以我要把这个加号变成减号

122
00:04:36,980 --> 00:04:38,269
然后他们去做减法

123
00:04:38,269 --> 00:04:39,839
结果呢就得到一个零

124
00:04:39,839 --> 00:04:41,220
那么这样子的话呢

125
00:04:41,220 --> 00:04:43,920
在计算机的内部的设计上面呢

126
00:04:43,920 --> 00:04:44,699
就会比较复杂

127
00:04:44,699 --> 00:04:47,579
因为我需要用这个东西去控制

128
00:04:47,579 --> 00:04:50,259
那个加号还是减号

129
00:04:50,259 --> 00:04:52,120
那么我们还有复杂的乘法

130
00:04:52,120 --> 00:04:52,540
除法呢

131
00:04:52,540 --> 00:04:53,250
对不对

132
00:04:53,250 --> 00:04:55,290
如果说采用中间数的话

133
00:04:55,290 --> 00:05:00,540
那意味着1000万表达的是个零

134
00:05:00,899 --> 00:05:03,240
那当我们把这个二进制的数

135
00:05:03,240 --> 00:05:04,800
要翻译成十进制的时候

136
00:05:04,800 --> 00:05:06,540
它本来是128的

137
00:05:06,540 --> 00:05:10,050
那我们在所有的程序的输入输出的地方

138
00:05:10,050 --> 00:05:12,930
都需要让他对这个128去做减法

139
00:05:12,930 --> 00:05:16,350
比如说你现在得到了10000001

140
00:05:16,350 --> 00:05:18,959
实际上呢这个东西是129了

141
00:05:18,959 --> 00:05:20,639
然后按照这种表示法哦

142
00:05:20,639 --> 00:05:23,009
那你原来的你要去减去128

143
00:05:23,009 --> 00:05:24,839
你实际上呢是一

144
00:05:25,139 --> 00:05:28,439
那也会使得我们程序在输入

145
00:05:28,439 --> 00:05:31,139
输出过程当中呢啊做的比较复杂

146
00:05:31,139 --> 00:05:32,639
所以实际上

147
00:05:32,639 --> 00:05:34,600
我们在计算机当中是怎么做的呢

148
00:05:34,959 --> 00:05:37,120
我们可以考虑刚才说的那个-1

149
00:05:37,120 --> 00:05:40,209
如果我们希望-1加一能够变成零

150
00:05:40,209 --> 00:05:41,600
怎么能够做到

151
00:05:41,740 --> 00:05:45,579
那么也就是说因为零是八个零一呢

152
00:05:45,579 --> 00:05:47,259
是00001

153
00:05:47,478 --> 00:05:50,418
也就是说我们希望说有什么东西加上零

154
00:05:50,418 --> 00:05:51,709
0001以后

155
00:05:51,709 --> 00:05:52,860
它会变成零

156
00:05:53,959 --> 00:05:56,120
什么东西加上它会变成零呢

157
00:05:59,220 --> 00:06:01,339
就是全一的那个数

158
00:06:01,339 --> 00:06:04,500
因为权一的那个数加上一以后

159
00:06:04,620 --> 00:06:06,300
我们现在就变成说零

160
00:06:06,300 --> 00:06:10,019
0000001要去和一

161
00:06:10,019 --> 00:06:13,480
1111111做相加

162
00:06:13,620 --> 00:06:17,089
那1+1=10

163
00:06:17,089 --> 00:06:19,850
要进位进位的一和一又变成零

164
00:06:19,850 --> 00:06:23,300
再进位进位进位进位进位进位

165
00:06:23,300 --> 00:06:25,120
最后多出了一个一

166
00:06:25,459 --> 00:06:27,019
但是在计算机内部

167
00:06:27,019 --> 00:06:28,910
如果这个数是八个比特的

168
00:06:28,910 --> 00:06:31,610
那么多出来的那一位就会被丢掉

169
00:06:31,610 --> 00:06:34,649
被丢掉以后这个东西没有了以后

170
00:06:34,649 --> 00:06:36,819
剩下的这个结果正好就是零

171
00:06:36,819 --> 00:06:39,339
所以如果我们让它等于-1等于一

172
00:06:39,339 --> 00:06:41,480
那么它们相加的结果就是零了

173
00:06:41,519 --> 00:06:43,470
或者我们换个角度说

174
00:06:43,470 --> 00:06:44,670
因为-1是什么

175
00:06:44,670 --> 00:06:46,139
-1就是0~1

176
00:06:46,139 --> 00:06:46,819
对不对

177
00:06:47,038 --> 00:06:49,139
因为0~1就是-1嘛

178
00:06:49,139 --> 00:06:51,119
所以-1呢就等于

179
00:06:51,119 --> 00:06:55,800
如果我们给全灵添上一个前面的一

180
00:06:55,800 --> 00:06:58,170
你数一下这里有123456788个零

181
00:06:58,170 --> 00:07:00,620
前面再添个一去减去那个一

182
00:07:00,620 --> 00:07:03,620
我们就得到了全一的那个结果

183
00:07:03,620 --> 00:07:08,019
所以这个权一就是-1啊

184
00:07:08,019 --> 00:07:08,798
就是-1

185
00:07:08,798 --> 00:07:09,668
实际上

186
00:07:09,668 --> 00:07:11,639
如果我们把这个权益

187
00:07:11,639 --> 00:07:13,439
当做纯二进制看待的时候

188
00:07:13,439 --> 00:07:14,910
他是255

189
00:07:14,910 --> 00:07:16,560
但是被当作补码

190
00:07:16,560 --> 00:07:17,879
所以我们把这个叫做补马

191
00:07:17,879 --> 00:07:19,699
被当作补马看待的时候呢

192
00:07:19,699 --> 00:07:20,720
它是-1

193
00:07:20,720 --> 00:07:22,620
而不是255

194
00:07:23,339 --> 00:07:25,339
所以对于一个负a来说

195
00:07:25,339 --> 00:07:26,480
它的补码是什么呢

196
00:07:26,480 --> 00:07:28,399
就是零减a 10进制

197
00:07:28,399 --> 00:07:29,810
其实就是零减a对不对

198
00:07:29,810 --> 00:07:32,259
但是呢实际上它是什么呢

199
00:07:32,259 --> 00:07:33,910
是二的n次方减a

200
00:07:33,910 --> 00:07:38,240
你看如果我们现在有这个数字的话

201
00:07:38,240 --> 00:07:40,430
这个数其实就是256

202
00:07:40,430 --> 00:07:41,660
这个二进制的一

203
00:07:41,660 --> 00:07:43,399
后面八个零是256

204
00:07:43,399 --> 00:07:45,560
256是二的八次方

205
00:07:45,560 --> 00:07:50,750
二的八次方减一就得到了-1的那个补码

206
00:07:50,750 --> 00:07:52,430
得到了-1的那个不满

207
00:07:52,430 --> 00:07:55,879
好在计算机内部补码的意义

208
00:07:55,879 --> 00:07:58,879
就是我们拿补码和源码

209
00:07:58,879 --> 00:08:02,339
可以加出一个带溢出的那么一个零

210
00:08:03,199 --> 00:08:08,639
-11的补码是255

211
00:08:08,899 --> 00:08:10,879
也就是我们认为的-1

212
00:08:10,879 --> 00:08:15,170
-1和一相加以后会得到溢出的全零

213
00:08:15,170 --> 00:08:18,220
但实际上它高位还多一个一

214
00:08:18,220 --> 00:08:19,879
但是我们把那个一丢掉了

215
00:08:20,379 --> 00:08:22,300
所以我们为什么要在计算机内部

216
00:08:22,300 --> 00:08:23,560
使用这种补码呢

217
00:08:23,560 --> 00:08:24,819
最大的好处就是

218
00:08:24,819 --> 00:08:27,420
如果你有了一个补码

219
00:08:27,439 --> 00:08:29,360
你用补码来表示这个-1

220
00:08:29,360 --> 00:08:31,279
那么当你在做加法的时候

221
00:08:31,279 --> 00:08:33,259
你不需要根据条件去变换

222
00:08:33,259 --> 00:08:34,190
把加变成减

223
00:08:34,190 --> 00:08:37,309
你直接拿它去做普通的二进制的加法

224
00:08:37,309 --> 00:08:40,000
你就会得到你想要的那个结果

