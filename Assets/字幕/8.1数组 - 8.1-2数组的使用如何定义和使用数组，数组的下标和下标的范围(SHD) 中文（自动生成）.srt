1
00:00:04,519 --> 00:00:05,960
呃我们刚才的那个例子啊

2
00:00:05,960 --> 00:00:07,639
给了我们一个非常感性的认识

3
00:00:07,639 --> 00:00:09,429
让我们看到数组是怎么样子的

4
00:00:09,429 --> 00:00:12,429
那我们来看一下数组的这个确切的定义

5
00:00:12,429 --> 00:00:13,509
是怎么写啊

6
00:00:13,509 --> 00:00:15,279
我们要去定义一个数组的时候

7
00:00:15,279 --> 00:00:16,719
我们需要像这样来写

8
00:00:16,719 --> 00:00:19,390
我们需要先先有这个数组的类型

9
00:00:19,390 --> 00:00:20,739
当然更加准确的说

10
00:00:20,739 --> 00:00:21,879
这不是数组的类型

11
00:00:21,879 --> 00:00:24,769
这是数组当中每一个单元的类型

12
00:00:24,769 --> 00:00:27,179
然后这个数组变量的名称

13
00:00:27,179 --> 00:00:29,449
每一个数组是一个变量

14
00:00:29,449 --> 00:00:31,820
我们有一个数组变量来表达这个数组

15
00:00:31,820 --> 00:00:33,890
所以我们需要有它的一个变量的名字

16
00:00:33,890 --> 00:00:35,420
这就是一个普通的变量和变量

17
00:00:35,420 --> 00:00:36,710
其他的变量是一样的

18
00:00:36,710 --> 00:00:40,679
然后不一样的是在于它后面有方括号

19
00:00:40,899 --> 00:00:43,420
这个方括号表明了这个数组

20
00:00:43,420 --> 00:00:44,770
这个变量是一个数组

21
00:00:44,770 --> 00:00:45,820
如果没有方括号

22
00:00:45,820 --> 00:00:47,429
那么他就是个普通的变量

23
00:00:47,429 --> 00:00:49,890
int a那么a就是一个int型的变量

24
00:00:49,890 --> 00:00:51,899
但如果a后面还有方括号

25
00:00:51,920 --> 00:00:53,390
a的性质就变了

26
00:00:53,390 --> 00:00:54,829
a就成为一个数组

27
00:00:54,829 --> 00:00:56,280
而不是一个普通的变量

28
00:00:56,280 --> 00:00:58,979
这个时候int的意思就不是说a是int

29
00:00:58,979 --> 00:01:02,299
而是说a里面的每一个单元都是一个int

30
00:01:02,479 --> 00:01:03,920
所以在方括号里头呢

31
00:01:03,920 --> 00:01:05,870
我们要给出一个数字

32
00:01:05,870 --> 00:01:08,950
比如说int grades 100

33
00:01:08,950 --> 00:01:12,280
那我们说这是叫做grades的一个数组

34
00:01:12,280 --> 00:01:13,989
它有100个单元

35
00:01:13,989 --> 00:01:14,980
double weight

36
00:01:14,980 --> 00:01:17,219
20叫做weight的数组

37
00:01:17,219 --> 00:01:18,629
每一个单元都是一个double

38
00:01:18,629 --> 00:01:20,239
它有20个这样的double

39
00:01:20,459 --> 00:01:24,060
这个元素的数量呢必须是整数

40
00:01:24,060 --> 00:01:25,899
因为这是个数嘛

41
00:01:25,900 --> 00:01:28,599
个数如果是带着小数是没有意义的

42
00:01:28,599 --> 00:01:31,250
另外呢在c99 以前

43
00:01:31,250 --> 00:01:34,849
元素元素的数量必须是编译时刻确定的

44
00:01:34,849 --> 00:01:35,480
常数

45
00:01:35,480 --> 00:01:37,879
字面量不能是变量

46
00:01:37,879 --> 00:01:39,200
不能是动态的

47
00:01:39,200 --> 00:01:41,399
程序运行过程当中产生的数字

48
00:01:41,480 --> 00:01:43,040
但从c9 开始呢

49
00:01:43,040 --> 00:01:44,450
是可以是变量的

50
00:01:44,450 --> 00:01:45,620
所以如果你在准备

51
00:01:45,620 --> 00:01:46,760
比如说二级考试

52
00:01:46,760 --> 00:01:47,750
那你一定要记住

53
00:01:47,750 --> 00:01:50,599
数组的大小必须是一个常数

54
00:01:50,599 --> 00:01:53,510
但是如果你只是为了自己呃

55
00:01:53,510 --> 00:01:54,409
补充知识

56
00:01:54,409 --> 00:01:55,519
为了实际的需要

57
00:01:55,519 --> 00:01:57,019
那么c99 开始

58
00:01:57,019 --> 00:02:00,859
我们已经可以用变量来定义数组的大小的

59
00:02:03,439 --> 00:02:04,668
数组是什么呢

60
00:02:04,668 --> 00:02:07,489
从更加宏观的层面来看

61
00:02:07,489 --> 00:02:10,038
数组是一种叫做容器的东西

62
00:02:10,038 --> 00:02:11,149
什么是容器

63
00:02:11,149 --> 00:02:12,759
放东西的东西

64
00:02:12,959 --> 00:02:15,479
比如说你有一个杯子

65
00:02:15,479 --> 00:02:17,520
这个杯子里面你可以装水

66
00:02:17,859 --> 00:02:19,989
你可以放茶

67
00:02:19,989 --> 00:02:21,399
你可以放咖啡

68
00:02:21,399 --> 00:02:22,680
你可以放果汁

69
00:02:22,919 --> 00:02:24,719
这就是一个放东西的东西

70
00:02:24,719 --> 00:02:26,069
放东西的东西

71
00:02:26,069 --> 00:02:27,699
它就是容器

72
00:02:28,139 --> 00:02:31,020
容器是现代程序设计当中

73
00:02:31,020 --> 00:02:32,939
非常重要的一个基本概念

74
00:02:32,939 --> 00:02:35,550
或者说现代的编程语言

75
00:02:35,550 --> 00:02:38,969
都应该提供某种形式的容器

76
00:02:40,590 --> 00:02:46,199
或者说语言所提供的容器的能力的大小

77
00:02:46,199 --> 00:02:49,199
可以看作是语言能力的大小

78
00:02:49,199 --> 00:02:51,460
的一个重要的评判标准

79
00:02:53,379 --> 00:02:56,520
数组这种容器它有非常鲜明的特点

80
00:02:56,520 --> 00:02:58,039
第一个特点是说

81
00:02:58,039 --> 00:03:01,659
它当中所有的元素具有相同的数据类型

82
00:03:01,659 --> 00:03:03,520
我定义了一个int型的数组

83
00:03:03,520 --> 00:03:05,620
那么这里头所有的单元都是int

84
00:03:05,620 --> 00:03:07,180
不可能说第一个是int

85
00:03:07,180 --> 00:03:08,050
第二个是double

86
00:03:08,050 --> 00:03:09,419
这件事情都做不到

87
00:03:09,859 --> 00:03:11,280
第二个特点呢

88
00:03:11,319 --> 00:03:13,750
一旦你创建了一个数组

89
00:03:13,750 --> 00:03:14,979
我们定义了一个数组变量

90
00:03:14,979 --> 00:03:16,240
我们就创建了一个数组

91
00:03:16,240 --> 00:03:18,139
那么它的大小是确定的

92
00:03:18,179 --> 00:03:20,818
你不可能在运行过程当中说啊

93
00:03:20,818 --> 00:03:21,658
我这个数字不够大了

94
00:03:21,658 --> 00:03:23,128
我再给它扩大一点不行

95
00:03:23,128 --> 00:03:23,729
做不到

96
00:03:23,729 --> 00:03:24,959
我说我这个数字太浪费了

97
00:03:24,959 --> 00:03:26,338
我给它缩小一点也不行

98
00:03:26,338 --> 00:03:27,069
也做不到

99
00:03:27,069 --> 00:03:28,180
数组的大小

100
00:03:28,180 --> 00:03:29,530
一旦确定下来

101
00:03:29,530 --> 00:03:31,479
就没有任何办法去改变它

102
00:03:32,579 --> 00:03:35,818
当然还有如果你想知道内部的事情的话

103
00:03:35,818 --> 00:03:36,899
我还可以告诉你

104
00:03:36,899 --> 00:03:42,449
在内存里头数组的单元是依次排列的

105
00:03:42,449 --> 00:03:44,740
而且是紧密依次排列的

106
00:03:44,740 --> 00:03:48,340
所以如果我们定义了说我们有int a 10

107
00:03:48,340 --> 00:03:49,659
这是做了一个数组

108
00:03:49,659 --> 00:03:51,240
这个数组有十个单元

109
00:03:51,618 --> 00:03:53,149
每个单元都是int

110
00:03:53,149 --> 00:03:56,838
那么它就是有了a0 到a9 

111
00:03:56,838 --> 00:03:59,000
这样的十个单元

112
00:03:59,618 --> 00:04:01,979
每个单元都是一个int类型的变量

113
00:04:02,039 --> 00:04:03,780
这个变量呢

114
00:04:03,780 --> 00:04:05,849
这个int类型的变量就是它的一个单元

115
00:04:05,849 --> 00:04:09,000
它可以出现在赋值号的左边

116
00:04:09,000 --> 00:04:11,819
也可以出现在复制号的右边

117
00:04:11,819 --> 00:04:13,919
当它出现在复制号的右边的时候

118
00:04:13,919 --> 00:04:15,998
我们知道我们是在做什么

119
00:04:15,998 --> 00:04:17,798
我们是在读取它的值

120
00:04:17,798 --> 00:04:18,399
对不对

121
00:04:18,399 --> 00:04:20,139
当它放在辅助号的左边的时候

122
00:04:20,139 --> 00:04:22,389
我们是在往那个里面写东西

123
00:04:22,389 --> 00:04:24,730
比如说a2 等于a一加六

124
00:04:24,730 --> 00:04:27,790
那就是我们要把a一的值读出来

125
00:04:27,790 --> 00:04:29,040
加上六以后呢

126
00:04:29,040 --> 00:04:30,839
写入到a2 里头去

127
00:04:32,279 --> 00:04:33,480
在福超右边是读的

128
00:04:33,480 --> 00:04:35,180
在福超左边是写的

129
00:04:35,819 --> 00:04:40,269
我们把复制号左边的值叫做左值

130
00:04:40,269 --> 00:04:43,000
那么当然它右边的指叫幼稚啊

131
00:04:43,000 --> 00:04:43,779
表面看起来

132
00:04:46,540 --> 00:04:49,180
我们也不在这个章节里面来展开讲

133
00:04:49,180 --> 00:04:51,100
左值和右值到底是什么样的意思

134
00:04:51,100 --> 00:04:52,180
我们到指针的时候

135
00:04:52,180 --> 00:04:53,319
我们再来展开解释

136
00:04:53,319 --> 00:04:55,980
左值和右值到底在c语言当中

137
00:04:55,980 --> 00:04:57,060
代表了什么样的含义

138
00:04:58,980 --> 00:05:00,379
数组的每一个单元

139
00:05:00,920 --> 00:05:03,379
就像前面的a1 a2 这样的单元

140
00:05:03,379 --> 00:05:05,180
它就是数组类型的一个变量

141
00:05:05,180 --> 00:05:07,350
所以int型的数组当中的每一个单元

142
00:05:07,350 --> 00:05:08,759
就是一个int类型的变量

143
00:05:08,759 --> 00:05:09,509
它可以做左直

144
00:05:09,509 --> 00:05:10,709
可以做左右直

145
00:05:10,709 --> 00:05:12,048
我们使用数组的时候

146
00:05:12,048 --> 00:05:13,639
我们在这个方括号后面

147
00:05:13,639 --> 00:05:15,408
数组变量零的后面跟上方括号

148
00:05:15,408 --> 00:05:17,149
方括号后面放上数字

149
00:05:17,149 --> 00:05:19,249
这个数字当然可以是变量

150
00:05:19,249 --> 00:05:20,149
可以是常数

151
00:05:20,149 --> 00:05:21,949
这个数字呢我们把它叫做下标

152
00:05:21,949 --> 00:05:24,079
也叫做索引啊

153
00:05:24,079 --> 00:05:25,069
叫做什么

154
00:05:25,069 --> 00:05:26,829
其实很大程度上

155
00:05:26,829 --> 00:05:30,009
和你当时在什么语境底下说话很有关系

156
00:05:30,009 --> 00:05:33,560
比如说因为对于数学做数学的东西来说

157
00:05:33,560 --> 00:05:34,699
那叫做下标

158
00:05:34,699 --> 00:05:37,660
似乎是呃很顺理成章的事情

159
00:05:38,000 --> 00:05:41,519
那么这个下标呢是从零开始计数的

160
00:05:43,540 --> 00:05:47,620
其实在计算机的编程的历史上

161
00:05:48,579 --> 00:05:50,699
数组不是c语言才有的

162
00:05:51,838 --> 00:05:53,459
for圈圆就是数组了

163
00:05:53,459 --> 00:05:56,399
但是数组的下标从零开始

164
00:05:56,399 --> 00:05:58,678
编号是从c语言开始的

165
00:05:58,678 --> 00:06:00,420
之所以要这么做

166
00:06:00,439 --> 00:06:02,810
非常重要的一个原因就是

167
00:06:02,810 --> 00:06:05,300
当年呢希望c语言的编译器

168
00:06:05,300 --> 00:06:06,319
可以做的很简单

169
00:06:06,319 --> 00:06:10,730
因为如果数组固定的都是从零开始编号

170
00:06:10,730 --> 00:06:13,839
那么它的编译器可以简化很多事情

171
00:06:14,579 --> 00:06:16,600
从那个以以后开始

172
00:06:16,759 --> 00:06:19,220
所有那些我们叫做c like的语言

173
00:06:19,220 --> 00:06:20,660
就是跟着c语言走的

174
00:06:20,660 --> 00:06:23,050
那些语言都是从零开始的了

175
00:06:23,050 --> 00:06:26,470
而因为c语言在程序员当中影响巨大

176
00:06:26,470 --> 00:06:27,790
是使用量最大的语言

177
00:06:27,790 --> 00:06:33,220
所以就变得会有人说程序员有一个坏毛病

178
00:06:33,220 --> 00:06:35,500
就是数数的时候喜欢从零开始数好

179
00:06:36,579 --> 00:06:37,970
但是对于大家来说

180
00:06:45,269 --> 00:06:47,610
你要接受说我们数数从零开始数

181
00:06:47,610 --> 00:06:49,879
我们的数组数数从零开始数

182
00:06:49,879 --> 00:06:51,769
01234567

183
00:06:51,769 --> 00:06:53,810
一直到最大的是什么呢

184
00:06:53,810 --> 00:06:56,269
最大的是数组的个数减一

185
00:06:56,269 --> 00:06:58,699
最大的下标是数组个数减一

186
00:06:58,699 --> 00:07:00,860
而不是数组的个数

187
00:07:02,180 --> 00:07:06,019
但是c语言的编译器也好

188
00:07:06,019 --> 00:07:07,639
运行环境也好

189
00:07:07,639 --> 00:07:11,420
是不会去检查数组下标是否越界的

190
00:07:11,500 --> 00:07:15,560
无论你这个时候是把它做左直还是做右直

191
00:07:15,560 --> 00:07:17,540
都不会有人去替你检查

192
00:07:17,540 --> 00:07:21,160
你对数组的使用那个下标是不是越界的

193
00:07:21,959 --> 00:07:24,439
但是一旦程序运行的时候

194
00:07:24,439 --> 00:07:27,079
越界的速度法呢可能会造成问题

195
00:07:27,079 --> 00:07:28,600
导致程序崩溃

196
00:07:29,158 --> 00:07:32,459
你有的时候会看到你的程序运行出来发生

197
00:07:32,459 --> 00:07:33,899
segmentation fault

198
00:07:33,899 --> 00:07:37,649
有可能就是因为数组下标越界了

199
00:07:37,649 --> 00:07:39,269
当然也可能运气好

200
00:07:39,269 --> 00:07:40,829
这一次虽然越界了

201
00:07:40,829 --> 00:07:43,079
我们都确切的知道他越界了

202
00:07:43,079 --> 00:07:44,860
但是没造成严重的后果

203
00:07:44,860 --> 00:07:45,939
所以这是为什么

204
00:07:45,939 --> 00:07:47,139
有的时候我们会遇到

205
00:07:47,139 --> 00:07:49,160
说程序这次运行是好的

206
00:07:49,160 --> 00:07:50,180
下次运行不行了

207
00:07:50,180 --> 00:07:52,639
或者说这个程序在我的电脑上是好的

208
00:07:52,639 --> 00:07:54,350
到了你的电脑上就不行了

209
00:07:54,350 --> 00:07:55,790
如果出现这种问题

210
00:07:55,790 --> 00:07:58,538
一般来说毛病都在这个地方

211
00:07:58,538 --> 00:07:59,228
数组越界

212
00:07:59,228 --> 00:08:01,238
或者是我们后面要学的指针

213
00:08:01,238 --> 00:08:02,540
指针出错了

214
00:08:02,680 --> 00:08:06,430
所以程序员有责任自己去保证

215
00:08:06,430 --> 00:08:07,329
在自己的代码里面

216
00:08:07,329 --> 00:08:08,889
通过代码的努力去保证

217
00:08:08,889 --> 00:08:10,720
你对下标的使用不会越界

218
00:08:10,720 --> 00:08:14,720
永远在零到数组的大小减一那个范围之内

219
00:08:14,720 --> 00:08:16,310
我们可以来试一下这件事

220
00:08:16,310 --> 00:08:17,658
如果越界了会怎么样

221
00:08:17,658 --> 00:08:19,819
现在我们写了一个非常小的测试程序

222
00:08:19,819 --> 00:08:23,298
啊啊我们呢在密函数里面会去掉f函数

223
00:08:23,298 --> 00:08:26,069
f函数里面呢有一个数组int a

224
00:08:26,069 --> 00:08:30,569
十个int的一个a然后呢我们这样好了

225
00:08:30,569 --> 00:08:33,339
我们让它在a 10那个地方写了一个零

226
00:08:33,519 --> 00:08:35,679
a 10是不是有效的下标呢

227
00:08:35,679 --> 00:08:36,879
不是有效的下标

228
00:08:36,879 --> 00:08:39,720
因为有效的下标是从0~9

229
00:08:39,720 --> 00:08:41,639
你从零数到九就已经有十个了

230
00:08:41,639 --> 00:08:41,940
对不对

231
00:08:41,940 --> 00:08:44,220
我们说a是十个int的一个数组嘛

232
00:08:44,220 --> 00:08:45,960
所以最大的下标其实只有九

233
00:08:45,960 --> 00:08:49,470
所以现在我们说我们要对a 10做一个写入

234
00:08:49,470 --> 00:08:54,480
然后然后我们来编译运行它

235
00:08:54,480 --> 00:08:55,700
好在呢

236
00:08:55,700 --> 00:08:58,759
我现在的编译器llvm检查的比较严格

237
00:08:58,759 --> 00:09:01,159
他发现说array index时

238
00:09:01,159 --> 00:09:03,529
已经越过了数组的末尾了

239
00:09:03,529 --> 00:09:05,519
但是他给我的是warning

240
00:09:05,799 --> 00:09:07,240
为什么他给我网瘾

241
00:09:07,240 --> 00:09:08,019
不给我error

242
00:09:08,019 --> 00:09:10,029
因为其他编译器连网瘾都没有

243
00:09:10,029 --> 00:09:11,740
所以他有的时候也吃不准

244
00:09:11,740 --> 00:09:12,279
说这不是

245
00:09:12,279 --> 00:09:14,710
这是不是你程序员故意要做的事情

246
00:09:14,710 --> 00:09:17,289
然后假如我们就跟普通程序员一样

247
00:09:17,289 --> 00:09:18,940
看到亡灵都置之不理

248
00:09:18,940 --> 00:09:20,649
我们强迫他要去运行

249
00:09:20,649 --> 00:09:22,899
这是我们程序运行的结果

250
00:09:26,330 --> 00:09:27,980
不是那个segmentation fault

251
00:09:27,980 --> 00:09:30,080
这只是因为我现在用的是macos

252
00:09:30,080 --> 00:09:31,220
如果我现在用的是windows

253
00:09:31,220 --> 00:09:33,200
也会看到那句segmentation fault

254
00:09:33,200 --> 00:09:36,799
因为我们对这个数组不存在的

255
00:09:36,799 --> 00:09:38,379
这个下标的访问

256
00:09:39,559 --> 00:09:41,799
其实最终还是成功了

257
00:09:41,799 --> 00:09:45,438
他把这个零写到了一个不该写的地方

258
00:09:45,600 --> 00:09:49,799
然后带来的后果是他没让我们的程序好

259
00:09:49,799 --> 00:09:51,210
如果我们在这儿加一句

260
00:09:51,210 --> 00:09:52,740
也许我们能够看得更明白

261
00:09:52,740 --> 00:09:55,519
here回来这了没有

262
00:09:55,519 --> 00:09:56,539
如果回来这了

263
00:09:56,539 --> 00:09:57,620
会说出这句here

264
00:09:57,620 --> 00:09:58,340
我们看一下

265
00:09:58,340 --> 00:10:02,240
我们运行的时候没有看到那句here

266
00:10:02,299 --> 00:10:04,279
这是我们往里编译的那个结果

267
00:10:04,279 --> 00:10:05,659
这就是那个输出的时候

268
00:10:05,659 --> 00:10:07,370
运行的时候已经得到的那个错误

269
00:10:07,370 --> 00:10:09,080
换句话说我们掉了f

270
00:10:09,080 --> 00:10:12,679
然后就根本没回到这程序就崩溃了

271
00:10:13,940 --> 00:10:16,899
当然这件事情作为一个入门课程

272
00:10:16,899 --> 00:10:18,379
我们不能讲太多哈

273
00:10:18,379 --> 00:10:21,289
呃大家有兴趣可以进一步的去琢磨说

274
00:10:21,289 --> 00:10:23,299
c语言的这个函数到底是怎么进去

275
00:10:23,299 --> 00:10:24,159
怎么出来的

276
00:10:24,159 --> 00:10:26,320
这个这个知识已经越过

277
00:10:26,320 --> 00:10:28,059
超过我们这门课的范围了

278
00:10:28,059 --> 00:10:30,679
因此我们前面的那个第一个

279
00:10:30,759 --> 00:10:33,700
给大家感性认识的那个程序是有bug的

280
00:10:33,700 --> 00:10:34,000
对不对

281
00:10:34,000 --> 00:10:35,710
我们当时来说是有有问题的

282
00:10:35,710 --> 00:10:36,639
有什么问题呢

283
00:10:36,639 --> 00:10:39,179
就这个数组我们就定了一个100的大小

284
00:10:39,620 --> 00:10:43,460
那么你是用户输入的数字超过100个

285
00:10:43,460 --> 00:10:44,219
怎么办

286
00:10:44,600 --> 00:10:45,409
对吧

287
00:10:45,409 --> 00:10:47,240
那解决方案呢有两个

288
00:10:47,240 --> 00:10:50,720
一个是说我用户我在读数字的过程当中

289
00:10:50,720 --> 00:10:51,779
我做个技术

290
00:10:51,779 --> 00:10:52,860
本来我们也有技术

291
00:10:52,860 --> 00:10:53,399
有cnt

292
00:10:53,399 --> 00:10:53,850
对不对

293
00:10:53,850 --> 00:10:56,850
那如果一旦我们发现说c nt已经达到九

294
00:10:56,850 --> 00:10:58,169
已经达到100了

295
00:10:58,169 --> 00:11:01,289
也就是说我们已经读满了100个数了

296
00:11:01,289 --> 00:11:03,120
我们就不能再读书了

297
00:11:03,299 --> 00:11:05,610
我们这个程序不能再接受更多的数了

298
00:11:05,610 --> 00:11:07,649
所以这是一个解决方案

299
00:11:07,649 --> 00:11:09,279
第二个解决方案是说

300
00:11:09,720 --> 00:11:12,809
我们可以利用c99 的那个特性

301
00:11:12,809 --> 00:11:16,360
既然c99 说我可以定义数组的时候

302
00:11:16,360 --> 00:11:18,409
采用的那个大小是动态的

303
00:11:18,409 --> 00:11:19,700
是个变量的值

304
00:11:19,700 --> 00:11:23,450
那么我们可以让用户呢先输入一个数字

305
00:11:23,450 --> 00:11:25,190
换句话说我们现在题目就得变一变

306
00:11:25,190 --> 00:11:27,659
题目不能说输入-1表示结束

307
00:11:27,659 --> 00:11:30,029
题目得说先让用户输入个数字

308
00:11:30,029 --> 00:11:31,379
这个数字用来表明

309
00:11:31,379 --> 00:11:34,259
我下面要输入多少个数字来求平均数

310
00:11:34,600 --> 00:11:36,159
然后我得到这个数字之后

311
00:11:36,159 --> 00:11:38,019
所以我得到了这个cnt之后

312
00:11:38,019 --> 00:11:42,559
我就可以用这个cnt去创建那个number数组了

313
00:11:42,659 --> 00:11:45,818
这个时候这个数组的大小呢是确定的

314
00:11:46,480 --> 00:11:49,440
但是每一次运行随着读到的c n t的不同

315
00:11:49,440 --> 00:11:50,340
它都是变化的

316
00:11:50,340 --> 00:11:52,350
但是一旦创建了这个数组之后

317
00:11:52,350 --> 00:11:54,690
你不能够再去改变它

318
00:11:54,690 --> 00:11:56,070
这是数组的特点

319
00:11:56,070 --> 00:11:57,039
根本特点

320
00:11:58,899 --> 00:11:59,850
顺便说

321
00:11:59,850 --> 00:12:02,370
你能不能创建一个长度为零的数组呢

322
00:12:02,370 --> 00:12:03,740
可以的

323
00:12:04,340 --> 00:12:06,850
但是这个数组没有任何用处对吧

324
00:12:06,850 --> 00:12:08,440
长度为零的数组

325
00:12:08,440 --> 00:12:11,580
意味着它的有效的下标是不存在的

326
00:12:11,580 --> 00:12:14,159
因为即使是零也是越界了

327
00:12:14,159 --> 00:12:18,419
我们知道最大的下标是它的大小减一

328
00:12:18,419 --> 00:12:19,559
现在它的大小是零

329
00:12:19,559 --> 00:12:20,940
0-1是-1

330
00:12:20,940 --> 00:12:22,559
而-1显然不可能是个有效的下标

331
00:12:22,559 --> 00:12:25,179
因为所有的下标都必须比零比零还要

332
00:12:25,179 --> 00:12:26,559
都都必须比-1要来的大

333
00:12:26,559 --> 00:12:27,639
是从零开始数的

334
00:12:27,639 --> 00:12:29,649
所以长度为零的数组可以存在

335
00:12:29,649 --> 00:12:30,340
你去试好了

336
00:12:30,340 --> 00:12:31,149
编译能通过的

337
00:12:31,149 --> 00:12:32,820
但是它没有任何用处

