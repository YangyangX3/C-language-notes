1
00:00:04,419 --> 00:00:06,759
我们还有一些其他细节要琢磨

2
00:00:06,759 --> 00:00:10,679
当你的函数没有参数的时候

3
00:00:10,739 --> 00:00:12,839
是写成这个样子呢

4
00:00:12,839 --> 00:00:14,099
还是写成这个样子

5
00:00:14,099 --> 00:00:17,620
也就是要不要在参数表里面放一个void

6
00:00:19,780 --> 00:00:23,070
当你在参数表里面放了void

7
00:00:23,070 --> 00:00:24,960
你是明确的告诉编译器说

8
00:00:24,960 --> 00:00:28,820
我的这个函数呢不接收任何的参数

9
00:00:28,919 --> 00:00:32,658
但是如果你在参数表里面不放任何东西

10
00:00:33,740 --> 00:00:35,530
在传统思维来说

11
00:00:35,530 --> 00:00:39,539
它表示呢这个f函数的参数不知道

12
00:00:40,299 --> 00:00:42,750
但是它并不表示没有参数

13
00:00:42,750 --> 00:00:44,939
那现在在c99 会怎么样呢

14
00:00:44,939 --> 00:00:46,170
我们来试一下我们的编译器

15
00:00:46,170 --> 00:00:51,119
如果这个swap现在呢我给他换个样子

16
00:00:51,119 --> 00:00:54,859
说我们写函数原型的时候

17
00:00:54,859 --> 00:00:58,000
说swap圆括号没有东西的

18
00:00:59,820 --> 00:01:02,878
编译的时候是通过了的

19
00:01:04,439 --> 00:01:06,049
编译的时候是通过了的

20
00:01:06,049 --> 00:01:07,640
之所以编译的时候是通过了的

21
00:01:07,640 --> 00:01:09,469
是因为你这样子写

22
00:01:09,469 --> 00:01:14,099
就告诉编译器说我只知道有个swap

23
00:01:14,099 --> 00:01:17,310
我不确定这个swap到底要什么参数

24
00:01:17,310 --> 00:01:19,920
于是编译器遇到这一行怎么办

25
00:01:19,920 --> 00:01:23,459
他猜测说你的sp要两个int

26
00:01:23,799 --> 00:01:27,099
所以如果现在我们把这儿改一改

27
00:01:27,099 --> 00:01:31,500
说这是double和double

28
00:01:31,500 --> 00:01:32,370
然后呢

29
00:01:32,370 --> 00:01:34,349
我们要在这个函数里头

30
00:01:34,349 --> 00:01:38,180
把这两个值a和b的值输出一下

31
00:01:38,180 --> 00:01:39,170
我们看看会怎么样

32
00:01:39,170 --> 00:01:40,609
现在我们的局面是什么呢

33
00:01:40,609 --> 00:01:42,590
我们在圆形声明的时候

34
00:01:42,590 --> 00:01:44,719
没说到底是什么类型

35
00:01:44,719 --> 00:01:49,239
调用的时候实际给的是两个整数函数

36
00:01:49,239 --> 00:01:51,489
实际的类型呢是要两个double

37
00:01:51,489 --> 00:01:52,780
然后我们在函数里面说

38
00:01:52,780 --> 00:01:55,359
在swap里面他拿到了两个什么样的double

39
00:01:55,359 --> 00:01:56,579
我们来运行一下

40
00:01:57,659 --> 00:02:00,620
你看我们给的是什么五和六

41
00:02:00,620 --> 00:02:02,150
他拿到了什么零

42
00:02:02,150 --> 00:02:06,099
还有一个非常非常巨大的恐怖的数字

43
00:02:07,280 --> 00:02:08,259
为什么会这样

44
00:02:10,060 --> 00:02:12,199
因为现在呢

45
00:02:12,199 --> 00:02:15,558
其实我们用这个东西去欺骗了编译器

46
00:02:15,558 --> 00:02:16,240
对不对

47
00:02:17,158 --> 00:02:19,500
我们告诉编译器说我也不知道

48
00:02:19,699 --> 00:02:21,979
然后呢编译器遇到这句话的时候呢

49
00:02:21,979 --> 00:02:25,219
认为swap要的是两个int

50
00:02:25,219 --> 00:02:26,060
于是呢

51
00:02:26,060 --> 00:02:30,020
他为swap调用安排了两个int的传递

52
00:02:31,080 --> 00:02:32,300
遇到这一行

53
00:02:32,300 --> 00:02:33,740
编译器在编译这一行的时候

54
00:02:33,740 --> 00:02:35,039
我们之前说过

55
00:02:35,139 --> 00:02:38,020
原型的作用不仅仅用于检查

56
00:02:38,020 --> 00:02:40,120
你对边函数的调用是不是对的

57
00:02:40,120 --> 00:02:43,210
也用于检查你对函数的定义是不是对的

58
00:02:43,210 --> 00:02:46,680
而现在在这一行25行去检查的时候

59
00:02:46,680 --> 00:02:49,889
你的原型说我不确定是什么类型

60
00:02:49,889 --> 00:02:54,710
那当然两个double也是可能的一种不确定了

61
00:02:54,710 --> 00:02:58,500
所以编译器没有从中发现任何问题

62
00:03:00,899 --> 00:03:04,188
但是实际上这个swap要两个double

63
00:03:04,188 --> 00:03:07,979
而这一行的编译的结果安排了两个整数

64
00:03:07,979 --> 00:03:11,159
这两个整数传递到那两个double那里去

65
00:03:11,159 --> 00:03:13,020
就错误了

66
00:03:15,539 --> 00:03:21,819
所以我们的建议是不要写出这样的原型来

67
00:03:22,199 --> 00:03:25,259
原型里面一定要把参数写全

68
00:03:25,259 --> 00:03:28,680
如果你确定你的函数是没有参数的

69
00:03:28,680 --> 00:03:30,620
你就把void放上去

70
00:03:30,620 --> 00:03:31,879
那这个命怎么回事

71
00:03:33,199 --> 00:03:36,649
这个病的事情我们一会儿来讲还挺复杂的

72
00:03:36,649 --> 00:03:38,359
还有一个小问题

73
00:03:38,359 --> 00:03:41,139
调用函数的时候不是也有逗号吗

74
00:03:41,179 --> 00:03:43,539
我们还说过逗号是运算符呢

75
00:03:43,539 --> 00:03:46,060
a逗号b如果是运算符的话

76
00:03:46,060 --> 00:03:47,139
它不就是一个结果

77
00:03:47,139 --> 00:03:48,400
就是那个b的值吗

78
00:03:48,400 --> 00:03:49,689
怎么会有两个呢

79
00:03:49,689 --> 00:03:50,509
好吧

80
00:03:50,509 --> 00:03:51,710
在调用函数的时候

81
00:03:51,710 --> 00:03:54,349
那个圆括号里面的逗号呢是标点符号

82
00:03:54,349 --> 00:03:55,769
而不是运算符

83
00:03:55,769 --> 00:03:58,960
但是如果你给它再加一层括号

84
00:03:58,960 --> 00:04:04,210
它就表明我们要先做括号里面的那个运算

85
00:04:04,210 --> 00:04:07,379
这个时候它就是逗号运算符了

86
00:04:07,419 --> 00:04:11,319
于是这一行第一行和第二行的区别

87
00:04:11,319 --> 00:04:13,569
就是到底传了两个

88
00:04:13,569 --> 00:04:15,879
还是一个参数进去的问题

89
00:04:18,339 --> 00:04:20,910
我能不能在函数里面定义另外一个函数

90
00:04:20,910 --> 00:04:21,899
不可以

91
00:04:21,899 --> 00:04:24,279
c语言不允许函数的嵌套定义

92
00:04:24,279 --> 00:04:25,779
我们可以在一个函数里面

93
00:04:25,779 --> 00:04:27,490
放另外一个函数的声明

94
00:04:27,490 --> 00:04:29,800
但是不能放另外一个函数的body

95
00:04:29,800 --> 00:04:31,240
不能放它的定义

96
00:04:33,079 --> 00:04:34,209
这是什么东西

97
00:04:34,209 --> 00:04:37,089
我们定义了int型的变量i和j

98
00:04:37,089 --> 00:04:41,680
我们声明说sum函数要两个int作为参数

99
00:04:41,680 --> 00:04:43,240
并且返回一个int

100
00:04:43,240 --> 00:04:44,319
这是可以的

101
00:04:44,319 --> 00:04:47,540
虽然我不建议大家这么写

102
00:04:47,620 --> 00:04:49,000
我们的建议是什么

103
00:04:49,000 --> 00:04:49,779
我们的建议是

104
00:04:49,779 --> 00:04:51,699
这东西应该拿出来放在函数外面

105
00:04:51,699 --> 00:04:52,180
对不对

106
00:04:52,180 --> 00:04:53,920
函数的原型声明应该拿出来

107
00:04:53,920 --> 00:04:55,908
不过c语言是接受这样的写法的

108
00:04:55,908 --> 00:04:56,778
这是什么

109
00:04:56,778 --> 00:04:57,709
我们前面说过

110
00:04:57,709 --> 00:04:59,088
return是一个语句的

111
00:04:59,088 --> 00:05:01,139
最后面要一个表达式

112
00:05:01,319 --> 00:05:05,550
所以这个圆括号其实没有任何意义对吧

113
00:05:05,550 --> 00:05:07,199
有原括号也不会错

114
00:05:07,199 --> 00:05:09,779
因为你拿一个变量外面加上圆括号

115
00:05:09,779 --> 00:05:10,949
它也是个表达式嘛

116
00:05:10,949 --> 00:05:12,240
括号是一种运算符嘛

117
00:05:12,240 --> 00:05:13,220
它没有错

118
00:05:13,240 --> 00:05:15,879
但是呢会让人误解误解什么

119
00:05:15,879 --> 00:05:18,000
以为return是个函数

120
00:05:18,000 --> 00:05:19,680
我们现在去调用return函数

121
00:05:19,680 --> 00:05:22,319
把i这个值传给return函的参数

122
00:05:22,319 --> 00:05:23,850
会会有人误解这个事情

123
00:05:23,850 --> 00:05:28,108
所以不要这么写没好处哈

124
00:05:28,108 --> 00:05:29,038
那关于main

125
00:05:29,038 --> 00:05:30,178
刚才说了命挺复杂的

126
00:05:30,178 --> 00:05:30,718
对不对

127
00:05:30,718 --> 00:05:32,999
当然现在我们应该知道int main

128
00:05:32,999 --> 00:05:34,439
它也是一个函数

129
00:05:35,579 --> 00:05:39,139
然后好像我们没有看到他有什么参数

130
00:05:39,139 --> 00:05:42,220
所以你要不要写成把void写进去呢

131
00:05:43,000 --> 00:05:46,470
当然编译不会有任何问题呃

132
00:05:46,470 --> 00:05:48,600
有的地方会强调说

133
00:05:48,600 --> 00:05:52,598
如果你觉得命你不要谈任何参数的

134
00:05:52,598 --> 00:05:53,899
你就写一个void

135
00:05:54,620 --> 00:05:56,569
我们在最开始的时候说

136
00:05:56,569 --> 00:05:59,160
may呢是我们c语言程序的入口

137
00:05:59,620 --> 00:06:01,779
但是我们没有告诉你说

138
00:06:01,779 --> 00:06:04,120
main其实也是一个函数

139
00:06:04,620 --> 00:06:09,079
main函数其实虽然是你写的代码当中

140
00:06:09,079 --> 00:06:11,120
第一个被执行的地方

141
00:06:11,120 --> 00:06:14,860
但其实呢它并不是你的这个程序运行起来

142
00:06:14,860 --> 00:06:16,389
第一条运行的代码

143
00:06:16,389 --> 00:06:19,120
在你的面函数之前还有其他的东西

144
00:06:20,439 --> 00:06:22,800
那些其他东西是为了你的程序运行

145
00:06:22,800 --> 00:06:24,000
去做准备的

146
00:06:24,000 --> 00:06:26,220
他们做完了一些准备工作之后

147
00:06:26,220 --> 00:06:28,339
他们会来调你的内函数

148
00:06:29,180 --> 00:06:31,339
所以main函数是一个函数

149
00:06:31,980 --> 00:06:33,620
同样的也是因为这个原因

150
00:06:33,620 --> 00:06:36,199
所以那个return 0是有意义的

151
00:06:36,199 --> 00:06:37,879
我们的main函数在结束的时候

152
00:06:37,879 --> 00:06:42,259
要把这个零返回给调用它的那个地方

153
00:06:42,259 --> 00:06:45,160
返回给一小段代码

154
00:06:45,160 --> 00:06:48,709
那一小段代码会来检查remain

155
00:06:48,709 --> 00:06:50,329
到底返回了一个什么样的东西

156
00:06:50,329 --> 00:06:53,339
然后他会报告给你的操作系统

157
00:06:53,339 --> 00:06:54,420
报告给你的windows

158
00:06:54,420 --> 00:06:55,649
报告给你的unix

159
00:06:55,649 --> 00:06:57,600
到底这个程序运行以后

160
00:06:57,600 --> 00:06:58,949
返回了一个什么样的值

161
00:06:58,949 --> 00:07:02,949
这个值对有些人来说是有意义的

162
00:07:02,949 --> 00:07:04,089
对于windows来说

163
00:07:04,089 --> 00:07:06,430
如果你知道什么叫做批处理文件

164
00:07:06,430 --> 00:07:08,240
什么叫做bat文件

165
00:07:08,240 --> 00:07:10,100
你可以在批处理文件里面

166
00:07:10,100 --> 00:07:13,399
在批处理文件里面去调用

167
00:07:13,399 --> 00:07:15,139
去执行你写的那个程序

168
00:07:15,139 --> 00:07:16,160
然后跟上一句说

169
00:07:16,160 --> 00:07:18,199
if err level 1

170
00:07:18,439 --> 00:07:21,139
如果你的程序返回的是一的话

171
00:07:21,139 --> 00:07:22,860
然后去做什么什么事情

172
00:07:24,639 --> 00:07:26,908
传统上一个应用程序

173
00:07:26,908 --> 00:07:29,009
一个程序如果返回零

174
00:07:29,009 --> 00:07:31,939
表示说他正常的运行结束了

175
00:07:31,939 --> 00:07:33,620
如果他返回非零的值

176
00:07:33,620 --> 00:07:34,759
任何非零的值

177
00:07:34,759 --> 00:07:38,279
表示在这个程序运行过程当中出现了错误

178
00:07:38,620 --> 00:07:40,600
所以return 0是正确的方

179
00:07:40,600 --> 00:07:43,269
return非零的值它是有错的

180
00:07:43,269 --> 00:07:44,529
对于unix

181
00:07:44,529 --> 00:07:45,910
如果你用的是ba show

182
00:07:45,910 --> 00:07:48,579
那么我们可以用doa问号

183
00:07:48,579 --> 00:07:51,250
来看到这个程序返回的结果

184
00:07:51,250 --> 00:07:52,649
我们来试一下这件事情

185
00:07:52,649 --> 00:07:55,230
我们写了一个非常小非常小的程序呃

186
00:07:55,230 --> 00:07:56,970
就一句话return 1

187
00:07:56,970 --> 00:08:00,040
然后我们来运行这个代码

188
00:08:00,040 --> 00:08:01,269
运行完以后

189
00:08:01,269 --> 00:08:05,149
我们echo dollar问号看到的是一

190
00:08:05,149 --> 00:08:07,100
如果我们把这个程序改一改

191
00:08:07,100 --> 00:08:08,819
我们让它return

192
00:08:11,019 --> 00:08:14,540
同样的编译运行

193
00:08:14,779 --> 00:08:18,699
然后echo那个dollar问号我们就看到了二

194
00:08:19,139 --> 00:08:22,500
如果我们把它变成-1

195
00:08:22,500 --> 00:08:24,560
我们看看我们会看到什么

196
00:08:25,379 --> 00:08:26,600
255

197
00:08:26,600 --> 00:08:28,220
为什么是255

198
00:08:28,220 --> 00:08:32,178
想一想我们讲过变量类型

199
00:08:32,860 --> 00:08:34,679
翻过来翻过去等等

200
00:08:34,679 --> 00:08:36,600
为什么-1是255

201
00:08:36,600 --> 00:08:39,759
所以return 0是有人看的

202
00:08:40,259 --> 00:08:41,789
是可以看的

203
00:08:41,789 --> 00:08:43,259
是可以起作用的

