1
00:00:04,240 --> 00:00:08,699
计算机习惯以什么样的方式来做计算呢

2
00:00:08,699 --> 00:00:11,580
比如说我们今天想要算这么一个方程

3
00:00:11,580 --> 00:00:13,919
2x加6=20

4
00:00:13,978 --> 00:00:15,239
我们怎么算

5
00:00:15,239 --> 00:00:21,359
2x加6=20

6
00:00:23,000 --> 00:00:25,179
我们学过方程啊

7
00:00:25,179 --> 00:00:26,739
我们知道这事很容易啊

8
00:00:26,739 --> 00:00:31,440
那就是2x等于20-6

9
00:00:31,440 --> 00:00:36,210
那就是x等于14÷2

10
00:00:36,210 --> 00:00:37,759
那就等于七咯

11
00:00:39,679 --> 00:00:42,880
是啊这事儿对于人来说很容易算

12
00:00:42,880 --> 00:00:45,219
但是呢对于计算机来说

13
00:00:45,219 --> 00:00:46,840
你要让他去学会

14
00:00:46,840 --> 00:00:50,018
怎么样列这样的方程式不容易

15
00:00:50,460 --> 00:00:52,049
所以计算机怎么算

16
00:00:52,049 --> 00:00:54,060
计算机会有另外的算法

17
00:00:54,060 --> 00:00:55,979
另外的办法来做这样的事情

18
00:00:55,979 --> 00:01:01,880
比如说假设呢呃你现在什么都不会

19
00:01:01,880 --> 00:01:02,840
没有学过方程式

20
00:01:02,840 --> 00:01:03,859
你看到这样的式子

21
00:01:03,859 --> 00:01:04,959
你会怎么去想

22
00:01:06,939 --> 00:01:08,549
有一个想法是这样

23
00:01:08,549 --> 00:01:10,920
我们能不能凑这个数

24
00:01:10,920 --> 00:01:12,000
我先试试看

25
00:01:12,000 --> 00:01:13,439
如果x是一

26
00:01:13,439 --> 00:01:15,179
那么2x1

27
00:01:16,420 --> 00:01:19,719
2x1=2

28
00:01:19,719 --> 00:01:21,879
加6=8

29
00:01:21,879 --> 00:01:22,659
好吧

30
00:01:22,659 --> 00:01:24,359
它不等于20

31
00:01:25,340 --> 00:01:26,620
嗯不行

32
00:01:26,620 --> 00:01:27,640
那我们再来

33
00:01:27,640 --> 00:01:29,019
如果这个不是一

34
00:01:29,019 --> 00:01:29,799
这个是二

35
00:01:29,799 --> 00:01:31,900
那么这里就有4+6

36
00:01:31,900 --> 00:01:34,760
就有14啊好吧

37
00:01:34,760 --> 00:01:35,569
只有十

38
00:01:35,569 --> 00:01:37,259
然后呢还不够

39
00:01:38,019 --> 00:01:40,439
于是再试一下三够不够

40
00:01:40,439 --> 00:01:42,359
最后我们一直往上凑

41
00:01:42,359 --> 00:01:44,819
凑到说a正好是七的时候

42
00:01:44,819 --> 00:01:46,539
这个式子是可以的

43
00:01:46,640 --> 00:01:49,010
所以咱们计算机在算东西的时候啊

44
00:01:49,010 --> 00:01:51,079
其实他也经常是这么

45
00:01:51,079 --> 00:01:52,609
这么傻傻的来算的东西

46
00:01:52,609 --> 00:01:54,230
因为对计算机来说呢

47
00:01:54,230 --> 00:01:56,799
去凑一个数出来

48
00:01:56,799 --> 00:02:00,519
比找一个方法来算东西会更容易啊

49
00:02:00,519 --> 00:02:02,560
所以计算机经常真的就是这么干的

50
00:02:02,560 --> 00:02:06,920
我一个一个的把所有的可能都列出来

51
00:02:06,920 --> 00:02:08,509
然后一个个的去试

52
00:02:08,509 --> 00:02:09,699
哪一个是对的

53
00:02:09,699 --> 00:02:11,468
一直到找到是对的为止

54
00:02:11,468 --> 00:02:14,599
这种方法呢我们把它叫做枚举

55
00:02:14,659 --> 00:02:17,120
一枚一枚的举出来啊

56
00:02:17,120 --> 00:02:18,319
就叫做枚举

57
00:02:18,319 --> 00:02:20,658
那除了这个方法

58
00:02:20,658 --> 00:02:22,128
但是枚举我们会看到说

59
00:02:22,128 --> 00:02:24,438
有一个很可能会有很大的缺点

60
00:02:24,438 --> 00:02:26,088
就是你得一个个试啊

61
00:02:26,088 --> 00:02:27,939
那咱们现在这个是七

62
00:02:27,939 --> 00:02:29,729
从一数到七呃

63
00:02:29,729 --> 00:02:31,080
找七个就可以了

64
00:02:31,080 --> 00:02:32,310
如果这是7万呢

65
00:02:32,310 --> 00:02:34,469
以礼从一数到7万就比较慢

66
00:02:34,469 --> 00:02:35,009
对不对

67
00:02:35,009 --> 00:02:37,629
所以为了让计算机能算得快

68
00:02:37,629 --> 00:02:40,500
我们就会有各种各样的算法

69
00:02:40,500 --> 00:02:42,360
比方说我们举个例子

70
00:02:42,360 --> 00:02:43,710
对于这个方程来说

71
00:02:43,710 --> 00:02:46,939
我们有一个比较简单的方案

72
00:02:46,939 --> 00:02:48,139
我不要再算方程

73
00:02:48,139 --> 00:02:50,509
我也不要他一个个去枚举出来

74
00:02:50,509 --> 00:02:52,219
我们可以有一个别的方法

75
00:02:52,219 --> 00:02:53,930
这个方法呢我们可以试试看

76
00:02:53,930 --> 00:02:54,409
是不是这样

77
00:02:54,409 --> 00:02:58,270
假如说我们已经知道这个x的范围

78
00:02:58,270 --> 00:03:02,900
大概是从一到时之间啊

79
00:03:02,900 --> 00:03:04,639
比如说我我们已经有这么一个条件

80
00:03:04,639 --> 00:03:06,620
是知道的呃

81
00:03:06,620 --> 00:03:08,060
所以我们解决问题经常是这样

82
00:03:08,060 --> 00:03:09,680
如果你知道的条件越多

83
00:03:09,680 --> 00:03:12,020
那么你解决问题的手段肯定就会越好

84
00:03:12,020 --> 00:03:14,740
假如我们已经知道它是一到十之间

85
00:03:14,780 --> 00:03:16,099
那我们就可以先试试看

86
00:03:16,099 --> 00:03:17,479
如果我们先上个五

87
00:03:17,479 --> 00:03:18,379
我们不是一直来

88
00:03:18,379 --> 00:03:19,639
就是一我们先上个五

89
00:03:19,639 --> 00:03:21,580
所以呢我们情况就会变成说

90
00:03:21,618 --> 00:03:24,438
今天呢我们不是一上来就来一

91
00:03:24,438 --> 00:03:25,699
我们先上个五

92
00:03:26,019 --> 00:03:27,609
2x5是十

93
00:03:27,609 --> 00:03:30,199
所以呢这么加回来呢就是16

94
00:03:30,860 --> 00:03:32,439
我发现这个16怎么样

95
00:03:32,439 --> 00:03:33,159
小于20

96
00:03:33,159 --> 00:03:33,819
对不对

97
00:03:35,558 --> 00:03:36,598
16是小于20

98
00:03:36,598 --> 00:03:37,258
说明什么

99
00:03:37,258 --> 00:03:39,718
说明我们要寻求的那个答案

100
00:03:39,718 --> 00:03:41,300
应该比五要来得大

101
00:03:41,639 --> 00:03:44,819
在五和那个十中间

102
00:03:44,819 --> 00:03:47,099
所以我们就接下来去试什么呢

103
00:03:47,099 --> 00:03:48,590
五和十中间那个数

104
00:03:48,590 --> 00:03:51,780
于是我们发现说我们可以是七或者是八

105
00:03:51,919 --> 00:03:54,680
假如我们一下子正好我们就试了七

106
00:03:54,680 --> 00:03:56,479
于是我们就发现说2x7

107
00:03:56,479 --> 00:03:58,129
这边刚好就是20

108
00:03:58,129 --> 00:04:00,199
于是呢我们就得到答案了

109
00:04:01,099 --> 00:04:04,919
两步我们就可以得到答案啊

110
00:04:04,919 --> 00:04:07,860
这种方案这种方法我们叫做二分法以后

111
00:04:07,860 --> 00:04:08,639
我们会看到很多

112
00:04:08,639 --> 00:04:11,180
在用计算机解决问题的过程当中

113
00:04:11,379 --> 00:04:17,050
人们毕竟这已经是一个六七十年的东西了

114
00:04:17,050 --> 00:04:18,879
人民已经想出了很多很多的方法

115
00:04:18,879 --> 00:04:20,560
对于各种的问题

116
00:04:20,560 --> 00:04:23,379
我们有各种更好的办法去计算它

117
00:04:23,379 --> 00:04:24,269
去解决它

118
00:04:24,269 --> 00:04:27,750
那一旦我们有了一个程序

119
00:04:27,750 --> 00:04:30,160
这个程序写出来之后

120
00:04:30,240 --> 00:04:33,060
计算机怎么能够去执行你的这个程序呢

121
00:04:33,060 --> 00:04:35,910
我们前面已经看到你的程序写出来

122
00:04:35,910 --> 00:04:39,250
是用一种类似于英文啊

123
00:04:39,250 --> 00:04:40,990
里面都是字母数字这样的东西

124
00:04:40,990 --> 00:04:43,029
但是呢计算机实际懂的语言呢

125
00:04:43,029 --> 00:04:44,110
是那种16进制

126
00:04:44,110 --> 00:04:46,829
都是数字的那种那那种方式他才懂

127
00:04:46,829 --> 00:04:49,980
那么在这两个之间是有差异的对吧

128
00:04:49,980 --> 00:04:53,769
那么计算机去呃执行你写的那个程序

129
00:04:53,769 --> 00:04:55,060
它就有两种方案

130
00:04:55,060 --> 00:04:57,300
一种方案呢我们叫做解释

131
00:04:57,420 --> 00:05:00,569
就是说我需要有一个计算机上的程序

132
00:05:00,569 --> 00:05:04,600
这个程序呢它能够读懂你写的那个程序

133
00:05:04,860 --> 00:05:06,240
这有点绕口是吧

134
00:05:06,240 --> 00:05:08,639
有一个程序读懂你写的程序啊

135
00:05:08,639 --> 00:05:10,129
他把你写的程序读进去

136
00:05:10,129 --> 00:05:11,149
读进去以后呢

137
00:05:11,149 --> 00:05:13,069
他看你第一行要做什么啊

138
00:05:13,069 --> 00:05:13,939
去厨房

139
00:05:13,939 --> 00:05:16,910
ok他就让计算机做这个去厨房的事是吧

140
00:05:16,910 --> 00:05:18,410
你第一件事让他做什么

141
00:05:18,410 --> 00:05:20,810
t等于2k他让计算机做t等于二的事

142
00:05:20,810 --> 00:05:23,269
所以他会看懂你的程序

143
00:05:23,269 --> 00:05:25,439
它会转身让计算机去做

144
00:05:25,439 --> 00:05:27,000
你要他做的事情

145
00:05:27,000 --> 00:05:29,310
如果是这么执行你的程序呢

146
00:05:29,310 --> 00:05:30,839
这种方式叫做解释

147
00:05:31,079 --> 00:05:34,110
那还有一种方式呢叫做编译啊

148
00:05:34,110 --> 00:05:36,459
就是先有一个程序

149
00:05:36,459 --> 00:05:38,110
所以咱们还得有一个程序是吧

150
00:05:38,110 --> 00:05:40,389
那个程序呢拿着你的程序

151
00:05:40,389 --> 00:05:41,800
他能读懂你的程序

152
00:05:41,800 --> 00:05:42,459
完了以后呢

153
00:05:42,459 --> 00:05:44,680
他把你的程序翻译一下

154
00:05:44,779 --> 00:05:47,569
变成计算机能懂的程序

155
00:05:47,569 --> 00:05:50,120
于是呢你的程序被翻译过以后呢

156
00:05:50,120 --> 00:05:50,839
你读不懂了

157
00:05:50,839 --> 00:05:52,500
但是计算机能读懂了

158
00:05:52,680 --> 00:05:55,290
然后他把这个计算机能读懂的程序呢

159
00:05:55,290 --> 00:05:56,009
留下来

160
00:05:56,009 --> 00:05:57,480
也就是保存下来

161
00:05:57,480 --> 00:05:59,879
那以后你的程序想要执行的时候

162
00:05:59,879 --> 00:06:02,339
就不是拿你写的那个程序去执行

163
00:06:02,339 --> 00:06:05,779
而是拿它翻译过以后的那个程序去执行

164
00:06:05,839 --> 00:06:07,819
那么这个过程啊

165
00:06:07,819 --> 00:06:11,670
这个翻译的过程我们把它叫做编译啊编译

166
00:06:11,670 --> 00:06:12,779
那么编译完以后

167
00:06:12,779 --> 00:06:14,579
就是计算机之间能够懂的东西

168
00:06:14,579 --> 00:06:16,740
所以程序的执行是有这样

169
00:06:16,740 --> 00:06:18,660
两种可能的方式的

170
00:06:19,699 --> 00:06:22,689
也就是说呢这个解释是怎么回事呢

171
00:06:22,689 --> 00:06:24,579
咱们写了一个程序是吧

172
00:06:24,579 --> 00:06:28,000
这程序呢写在一个文件里头啊

173
00:06:28,000 --> 00:06:29,079
存在一个文件里头

174
00:06:29,079 --> 00:06:32,180
完了以后呢交给一个程序

175
00:06:33,560 --> 00:06:36,370
那程序呢他能读懂你的程序

176
00:06:36,370 --> 00:06:38,259
可是呢它不产生任何东西

177
00:06:38,259 --> 00:06:39,740
他只是去做动作

178
00:06:39,839 --> 00:06:41,639
他拿着你的程序去开始

179
00:06:41,639 --> 00:06:43,949
一条一条一条一条的走

180
00:06:43,949 --> 00:06:45,870
走完以后呢就做完了

181
00:06:45,870 --> 00:06:46,589
这事儿就做完了

182
00:06:46,589 --> 00:06:48,839
那下一回你要再运行你的程序的时候

183
00:06:48,839 --> 00:06:51,389
你还得把这个能够解释你的程序的

184
00:06:51,389 --> 00:06:52,529
这个东西呢可以召唤出来

185
00:06:52,529 --> 00:06:54,360
由他来执行你的程序

186
00:06:54,360 --> 00:06:56,819
而编译呢是说你还是拿着这个源代码

187
00:06:56,819 --> 00:07:00,980
是不是你交给了一个翻译官啊

188
00:07:00,980 --> 00:07:03,379
这个翻译的人呢翻译的这个程序呢

189
00:07:03,379 --> 00:07:07,529
负责呢把你的程序呢变成了另外一个程序

190
00:07:07,529 --> 00:07:10,769
那里头呢都是各种计算机能读懂的东西啊

191
00:07:10,769 --> 00:07:11,980
人就读不懂了

192
00:07:12,560 --> 00:07:15,439
完了以后你的程序一点也没执行

193
00:07:15,439 --> 00:07:16,879
那该你让他做什么

194
00:07:16,879 --> 00:07:17,750
什么都不去做

195
00:07:17,750 --> 00:07:20,959
然后你得让这个程序去运行

196
00:07:20,959 --> 00:07:23,759
去这个程序在计算机上运行起来以后呢

197
00:07:23,759 --> 00:07:26,839
他才能够给你得到你要的那个结果啊

198
00:07:26,839 --> 00:07:28,279
所以上头那一个啊

199
00:07:28,279 --> 00:07:29,689
这叫做解释

200
00:07:29,689 --> 00:07:31,639
而这个呢叫做编译

201
00:07:31,639 --> 00:07:33,959
这是程序执行的两种不同的方式

202
00:07:33,959 --> 00:07:36,870
那因为有这样两种方式去执行程序

203
00:07:36,870 --> 00:07:38,279
就会有人有一个误解

204
00:07:38,279 --> 00:07:41,579
说这个语言是解释执行的

205
00:07:41,579 --> 00:07:43,980
那个语言是编译执行的

206
00:07:43,980 --> 00:07:46,889
其实呢对于计算机的编程语言来说

207
00:07:46,889 --> 00:07:50,879
语言本身是没有解释和编译的区分的啊

208
00:07:50,879 --> 00:07:53,069
任何一种语言既可以解释执行

209
00:07:53,069 --> 00:07:54,439
也可以编译执行

210
00:07:54,439 --> 00:07:57,300
这只是传统和习惯的问题

211
00:07:57,300 --> 00:08:00,918
只是这种语言常用的它的程序的执行方式

212
00:08:00,918 --> 00:08:02,418
比如说我们经常听到说

213
00:08:02,418 --> 00:08:03,858
c语言是编译型的语言

214
00:08:03,858 --> 00:08:04,338
没错

215
00:08:04,338 --> 00:08:05,838
因为一般我们写c语言的

216
00:08:05,838 --> 00:08:07,218
c语言的程序写出来以后呢

217
00:08:07,218 --> 00:08:08,538
你是需要编译

218
00:08:08,538 --> 00:08:10,459
然后再来运行

219
00:08:10,459 --> 00:08:14,060
但是也有人去做了c语言的解释器

220
00:08:14,279 --> 00:08:16,259
然后一般我们都知道说python语言

221
00:08:16,259 --> 00:08:17,920
它是一个解释性的语言

222
00:08:17,920 --> 00:08:18,939
因为你不需要编译

223
00:08:18,939 --> 00:08:20,769
直接就可以拿源代码去执行了

224
00:08:20,769 --> 00:08:22,420
但是呢也有人愿意的话

225
00:08:22,420 --> 00:08:24,759
也可以去做他的这个编译器去啊

226
00:08:24,759 --> 00:08:29,009
所以语言本身没有解释和编译的这个区分

227
00:08:29,009 --> 00:08:31,000
只是它的具体的执行方式而已

228
00:08:31,019 --> 00:08:34,529
那这两种方式有没有好坏呢

229
00:08:34,529 --> 00:08:37,259
解释性的语言能够有一些特殊的计算能力

230
00:08:37,259 --> 00:08:40,980
因为源代码在执行的过程当中

231
00:08:40,980 --> 00:08:42,830
不断的去背解读

232
00:08:42,830 --> 00:08:44,360
那么有可以有可能

233
00:08:44,360 --> 00:08:46,159
我们可以做一些特殊的事情啊

234
00:08:46,159 --> 00:08:47,659
比方说运行过程当中

235
00:08:47,659 --> 00:08:49,620
源代码是不是可以被修改啊等等

236
00:08:49,860 --> 00:08:50,610
呃

237
00:08:50,610 --> 00:08:52,320
过去呢我们一般会觉得说

238
00:08:52,320 --> 00:08:53,879
解释性的语言会运行的比较慢

239
00:08:53,879 --> 00:08:56,820
因为你不是直接在计算机上运行的对吧

240
00:08:56,820 --> 00:08:59,519
你需要有一个程序帮助你去运行它

241
00:08:59,519 --> 00:09:03,110
但是呢现在呢我们发现了这个我们看到啊

242
00:09:03,110 --> 00:09:04,029
解释性的语言

243
00:09:04,029 --> 00:09:05,950
它的运行效率和

244
00:09:05,950 --> 00:09:07,509
编译型的语言的运行效率呢

245
00:09:07,509 --> 00:09:08,919
已经不是重要的问题

246
00:09:08,919 --> 00:09:11,409
因为计算机的速度已经到了一个

247
00:09:11,409 --> 00:09:12,740
比较高的层次上面

248
00:09:12,740 --> 00:09:13,700
那么在那个速度底下

249
00:09:13,700 --> 00:09:16,820
解释编译它的运行的性能不是太大的

250
00:09:16,820 --> 00:09:19,259
这个啊这个这个差异

251
00:09:19,259 --> 00:09:21,480
那编译型的语言有编译型语言的好处

252
00:09:21,480 --> 00:09:23,879
比如说它能够有确定的运算性能

253
00:09:23,879 --> 00:09:24,659
这个意思是说

254
00:09:24,659 --> 00:09:26,250
我同样的程序

255
00:09:26,250 --> 00:09:27,870
在运行的过程当中是这么快的

256
00:09:27,870 --> 00:09:28,830
它就是这么快的是吧

257
00:09:28,830 --> 00:09:30,779
它能够有一个明确的运算性能

258
00:09:30,779 --> 00:09:32,399
所以在今天来说

259
00:09:32,399 --> 00:09:35,940
这两种方式执行方式已经没有非常大的

260
00:09:35,940 --> 00:09:37,259
本质上的区别啊

261
00:09:37,259 --> 00:09:39,120
这只是传统和喜好的问题

