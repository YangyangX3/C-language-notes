1
00:00:04,639 --> 00:00:07,080
我们前面讲到过吉连的if else if

2
00:00:07,480 --> 00:00:10,539
那么e f l c呢一般当然是用来呃

3
00:00:10,539 --> 00:00:11,500
像我们举的那个例子

4
00:00:11,500 --> 00:00:12,789
一个分段函数对吧

5
00:00:12,789 --> 00:00:17,359
那么是用来比较在一定范围内我要怎么做

6
00:00:17,359 --> 00:00:18,969
一定范围内我要怎么做

7
00:00:18,969 --> 00:00:19,809
但有的时候呢

8
00:00:19,809 --> 00:00:22,690
我们也可能会遇到有这样的几点的f l cf

9
00:00:22,690 --> 00:00:24,690
我们需要去判断在一些点上

10
00:00:24,690 --> 00:00:26,399
当这个值等于

11
00:00:26,399 --> 00:00:28,109
当这个变量等于这个值的时候

12
00:00:28,109 --> 00:00:28,469
做什么

13
00:00:28,469 --> 00:00:30,660
什么等于另外一个指头又做什么什么什么

14
00:00:30,660 --> 00:00:32,799
比如说现在我们这里的这个代码

15
00:00:33,039 --> 00:00:35,829
他根据你给的那个type的值

16
00:00:35,829 --> 00:00:37,979
来决定输出一句什么样的话

17
00:00:38,399 --> 00:00:40,200
我们来看看这样的一个代码

18
00:00:40,200 --> 00:00:42,299
它在执行的时候会是怎么样的过程

19
00:00:43,920 --> 00:00:46,960
我们现在啊有了这样一段代码

20
00:00:46,960 --> 00:00:48,100
我们来试一下

21
00:00:48,100 --> 00:00:50,259
现在我们如果在这儿设一个断点

22
00:00:50,520 --> 00:00:53,039
然后我们来看看这个e f l c f的判断

23
00:00:53,039 --> 00:00:54,210
它是怎么走的

24
00:00:54,210 --> 00:00:56,429
我们想输入一个tab等于三

25
00:00:56,429 --> 00:00:59,338
然后看看它是怎么来做这个运行的

26
00:01:02,439 --> 00:01:03,779
我们输入三

27
00:01:05,319 --> 00:01:06,540
现在呢他在这儿

28
00:01:06,540 --> 00:01:07,560
这个时候tab等于三

29
00:01:08,579 --> 00:01:12,879
下一步他先做了type是否等于一的判断

30
00:01:12,879 --> 00:01:13,810
发觉不对

31
00:01:13,810 --> 00:01:14,650
然后呢

32
00:01:14,650 --> 00:01:18,759
到了elsa再来做type是否等于二的判断

33
00:01:19,140 --> 00:01:20,310
发句还不对

34
00:01:20,310 --> 00:01:22,799
然后再来做tap是否等于三的判断

35
00:01:22,799 --> 00:01:24,629
这时候发现它不等于三了

36
00:01:24,629 --> 00:01:26,219
做这个print

37
00:01:26,219 --> 00:01:26,939
晚上好

38
00:01:26,939 --> 00:01:30,239
完了以后离开整个fl cg

39
00:01:31,540 --> 00:01:34,920
所以我们看到这样的一段几点的fils

40
00:01:34,920 --> 00:01:36,090
如果你运气好

41
00:01:36,090 --> 00:01:38,310
刚好它不等于一在第一个

42
00:01:38,310 --> 00:01:39,879
那么马上就运行了

43
00:01:39,879 --> 00:01:41,439
如果你运气不好

44
00:01:41,439 --> 00:01:43,459
比如说他本也不等于一

45
00:01:43,459 --> 00:01:46,069
234中的任何一个是要到最后这个else的

46
00:01:46,069 --> 00:01:49,879
那么它要逐11234每个都判断过

47
00:01:49,879 --> 00:01:53,010
每个都比较过以后才会到最后那里去

48
00:01:54,569 --> 00:01:57,379
于是呢我们就可以去写出这样的代码来

49
00:01:58,480 --> 00:01:59,879
这种叫做switch case

50
00:02:01,079 --> 00:02:02,040
我们看在这儿呢

51
00:02:02,040 --> 00:02:04,379
我们是有一个叫做switch的关键字

52
00:02:04,379 --> 00:02:06,840
在这个switch后面呢有一对圆括号

53
00:02:06,840 --> 00:02:08,340
后面还有一对大括号

54
00:02:08,340 --> 00:02:10,460
表面上看上去就很像什么

55
00:02:10,479 --> 00:02:11,829
很像一对吧

56
00:02:11,829 --> 00:02:13,718
好像如果把switch换成衣服的话

57
00:02:13,718 --> 00:02:15,038
就像是一句if语句

58
00:02:15,038 --> 00:02:16,959
说我要一个什么表达式

59
00:02:16,959 --> 00:02:18,780
然后后面有一对大括要执行的语句

60
00:02:18,780 --> 00:02:20,009
不过现在是switch

61
00:02:20,009 --> 00:02:21,240
所以呢情况是不一样的

62
00:02:21,240 --> 00:02:23,250
他是说我要根据这个变量

63
00:02:23,250 --> 00:02:24,449
所以这里只是一个变量

64
00:02:24,449 --> 00:02:25,650
当然也可以是个表达式

65
00:02:25,650 --> 00:02:28,020
我要根据这个表达式的结果

66
00:02:28,500 --> 00:02:30,120
然后来决定说

67
00:02:30,120 --> 00:02:33,280
下面我有哪一个case是跟他匹配的

68
00:02:33,539 --> 00:02:35,939
如果tab是等于一的

69
00:02:35,939 --> 00:02:37,889
ok那我们就做k 11

70
00:02:37,889 --> 00:02:40,240
这里注意这是一个冒号

71
00:02:40,519 --> 00:02:42,889
这是说如果tab等于一

72
00:02:42,889 --> 00:02:44,359
ok我们做这个冒号

73
00:02:44,359 --> 00:02:48,009
后面的句子一直到遇到break为止

74
00:02:48,009 --> 00:02:49,719
如果type等于三

75
00:02:49,719 --> 00:02:53,139
ok那我就做k3 后面的冒号

76
00:02:53,139 --> 00:02:55,379
后面的句子一直遇到break位置

77
00:02:55,379 --> 00:02:58,289
我们这儿一共有12344个case

78
00:02:58,289 --> 00:02:59,879
如果我现在type的值

79
00:02:59,879 --> 00:03:01,800
不等于1234中的任何一个

80
00:03:01,800 --> 00:03:04,719
那么我们最后还有一个扫尾的

81
00:03:04,719 --> 00:03:06,139
我们有一个default

82
00:03:06,280 --> 00:03:07,840
如果不等于1234

83
00:03:07,840 --> 00:03:10,120
那么我们做default后面的句子

84
00:03:10,120 --> 00:03:11,979
我们先来看一下这个switch case

85
00:03:11,979 --> 00:03:14,000
在运行的时候会是什么样子的

86
00:03:14,319 --> 00:03:16,840
这是我们的这个switch case的程序

87
00:03:16,840 --> 00:03:20,379
我们一样呢在这设个断点啊

88
00:03:20,379 --> 00:03:21,939
然后我们来调试运行

89
00:03:22,379 --> 00:03:23,900
我们还是输入三

90
00:03:26,919 --> 00:03:30,629
现在在这type的值呢是三

91
00:03:30,629 --> 00:03:35,318
接下来下一步他就直接跳到了k3 

92
00:03:35,318 --> 00:03:36,579
这个地方去做

93
00:03:36,579 --> 00:03:37,959
晚上好这件事情了

94
00:03:37,959 --> 00:03:40,389
再下一步就要去做break

95
00:03:40,389 --> 00:03:44,120
而这个break就带他离开了整个switch kiss

96
00:03:44,120 --> 00:03:45,830
到了switch case的下一句

97
00:03:45,830 --> 00:03:47,419
所以他就很干净利落

98
00:03:47,419 --> 00:03:49,219
他没有去判断一二

99
00:03:49,219 --> 00:03:51,020
然后再判断到三

100
00:03:51,118 --> 00:03:54,718
他直接就跳到三那个地方去去做

101
00:03:54,718 --> 00:03:57,058
我们希望它在type等于三的时候

102
00:03:57,058 --> 00:03:58,378
该做的那件事情

103
00:03:58,378 --> 00:03:59,939
这就是switch case

104
00:04:00,938 --> 00:04:03,419
所以一个switch case语句就长相这个样子啊

105
00:04:03,419 --> 00:04:04,558
有一个switch关键字

106
00:04:04,558 --> 00:04:05,338
有一个圆括号

107
00:04:05,338 --> 00:04:07,079
圆括号里面是一个控制表达式

108
00:04:07,079 --> 00:04:09,099
然后呢后面是一对大括号

109
00:04:09,099 --> 00:04:10,419
在大括号里面

110
00:04:10,419 --> 00:04:16,158
我们用kiss kiss kiss隔开了一堆一堆的语句啊

111
00:04:16,158 --> 00:04:18,750
那么每个case后面要跟一个常量

112
00:04:18,750 --> 00:04:19,769
然后是冒号

113
00:04:19,769 --> 00:04:21,480
冒号后面有一些语句要去执行

114
00:04:21,480 --> 00:04:23,370
每个case后面有一个常量啊

115
00:04:23,370 --> 00:04:24,060
没有冒号

116
00:04:24,060 --> 00:04:25,680
最后呢我们可以放一个default

117
00:04:25,680 --> 00:04:28,379
当所有的case都不pay的时候到default那里去

118
00:04:28,379 --> 00:04:29,519
那么在这个地方呢

119
00:04:29,519 --> 00:04:33,019
这个控制表达式它只能是整数型的

120
00:04:33,019 --> 00:04:33,529
结果

121
00:04:33,529 --> 00:04:35,079
不相信我们来试一下

122
00:04:35,279 --> 00:04:38,279
现在呢在这个呃switch case里头呢

123
00:04:38,279 --> 00:04:39,180
这个tt是整数的

124
00:04:39,180 --> 00:04:40,680
刚才我们已经试过这个东西了

125
00:04:40,680 --> 00:04:42,740
现在呢我们把这个int改成double

126
00:04:44,680 --> 00:04:48,120
那么当然同样的scaf这边要变成lf好

127
00:04:48,120 --> 00:04:49,500
然后我们来编译它一下

128
00:04:50,899 --> 00:04:54,879
他说这个语句啊需要一个int类型的表达式

129
00:04:54,879 --> 00:04:56,350
double呢是无效的

130
00:04:56,350 --> 00:04:57,459
就这个switch语句

131
00:04:57,459 --> 00:05:00,120
他要一个这个type呢必须是int

132
00:05:00,420 --> 00:05:03,300
所以这个表达式它必须是int类型的

133
00:05:03,300 --> 00:05:04,420
这是第一件事情

134
00:05:04,658 --> 00:05:05,918
第二件事情呢

135
00:05:05,918 --> 00:05:07,329
这里的这个常数啊

136
00:05:07,329 --> 00:05:08,540
它可以是常数

137
00:05:08,540 --> 00:05:10,670
也可以是常数计算的表达式

138
00:05:10,670 --> 00:05:12,139
什么常数计算表达式呢

139
00:05:12,139 --> 00:05:13,459
就是你可以有个表达式

140
00:05:13,459 --> 00:05:14,360
但是这个表达式里面

141
00:05:14,360 --> 00:05:16,189
所有的数都应该是常数

142
00:05:16,189 --> 00:05:18,750
也就是说变异的时候是知道结果的

143
00:05:18,750 --> 00:05:19,860
我们来试一下

144
00:05:20,098 --> 00:05:21,509
比如这个case 2

145
00:05:21,509 --> 00:05:24,119
如果我们把二写成1+1

146
00:05:24,119 --> 00:05:25,399
我们来编译一下

147
00:05:25,718 --> 00:05:27,158
没有任何问题

148
00:05:27,158 --> 00:05:30,098
如果我们定义了一个const

149
00:05:30,098 --> 00:05:32,970
int morning等于二

150
00:05:32,970 --> 00:05:37,459
然后我们在这说case morning

151
00:05:37,459 --> 00:05:38,779
我们来试一下

152
00:05:38,779 --> 00:05:40,610
也是可以的啊

153
00:05:40,610 --> 00:05:41,389
也是可以的

154
00:05:41,389 --> 00:05:44,149
但这是c99 才能用的

155
00:05:44,149 --> 00:05:45,529
我们用了const

156
00:05:45,529 --> 00:05:47,930
而且用const的一个变量来做

157
00:05:47,930 --> 00:05:49,069
这里case后面的常量

158
00:05:49,069 --> 00:05:50,269
这是c99 才能用的

159
00:05:50,269 --> 00:05:51,410
如果你用sc

160
00:05:51,410 --> 00:05:53,019
那是不可以用这件事情的

161
00:05:53,158 --> 00:05:55,978
那么我们在前面的这个switch case的句子当中啊

162
00:05:55,978 --> 00:06:00,350
我们看到说switch会根据这个表达式的结果

163
00:06:00,350 --> 00:06:02,100
来选择一个对应的case

164
00:06:02,139 --> 00:06:05,019
那么跳到那个case后面那句话去执行

165
00:06:05,019 --> 00:06:06,699
执行的过程当中

166
00:06:06,699 --> 00:06:07,540
一句一句的执行

167
00:06:07,540 --> 00:06:08,680
一直坐到那个break位置

168
00:06:08,680 --> 00:06:11,519
break就会让他离开整个switch case

169
00:06:11,899 --> 00:06:15,500
实际上在switch case的这个句子当中啊

170
00:06:15,500 --> 00:06:16,459
对于初学者来说

171
00:06:16,459 --> 00:06:18,100
最困惑的事情就是这个break

172
00:06:18,620 --> 00:06:20,750
很多初学者会误以为说

173
00:06:20,750 --> 00:06:26,180
case和case分割了switch case当中的那些语句

174
00:06:26,279 --> 00:06:27,899
实际上并不是这样子的

175
00:06:27,899 --> 00:06:29,250
对于switch case来说

176
00:06:29,250 --> 00:06:30,660
在switch case里面

177
00:06:30,660 --> 00:06:35,408
所有的句子他们处在一个相同的空间里头

178
00:06:35,408 --> 00:06:37,629
你可以无视所有的case

179
00:06:37,629 --> 00:06:41,259
认为这些句子是一个要连续执行的语

180
00:06:41,259 --> 00:06:42,040
句的序列

181
00:06:42,040 --> 00:06:44,230
只是在当中出现了break

182
00:06:44,230 --> 00:06:45,490
那case是什么呢

183
00:06:45,490 --> 00:06:48,978
case是从哪里开始做事情

184
00:06:48,978 --> 00:06:51,500
从哪里开始执行的那么一个位置

185
00:06:51,819 --> 00:06:55,110
所以switch type是说如果type等于某个值

186
00:06:55,110 --> 00:06:58,050
我就跳到那个case所代表的那个位置

187
00:06:58,050 --> 00:06:59,920
去做那个后面的句子

188
00:06:59,920 --> 00:07:00,970
然后一直往下做

189
00:07:00,970 --> 00:07:01,810
一直往下做

190
00:07:01,810 --> 00:07:04,209
直到遇到了break位置

191
00:07:04,209 --> 00:07:05,560
如果没有遇到break

192
00:07:05,560 --> 00:07:08,470
但是已经进入了下一个case的领地

193
00:07:08,470 --> 00:07:09,040
怎么办

194
00:07:09,040 --> 00:07:11,490
那就进去啊

195
00:07:11,490 --> 00:07:14,220
所以你看我们现在这边的这个代码

196
00:07:14,220 --> 00:07:17,060
如果我派不等于一

197
00:07:17,399 --> 00:07:19,019
那他type等于一

198
00:07:19,019 --> 00:07:21,000
这个case后面没有任何的东西

199
00:07:21,000 --> 00:07:21,720
对不对

200
00:07:21,740 --> 00:07:22,939
他就不做了吗

201
00:07:22,939 --> 00:07:23,930
显然不可能

202
00:07:23,930 --> 00:07:25,759
所以实际上当他后面没有任何东西的时候

203
00:07:25,759 --> 00:07:27,319
他就会直接往下走

204
00:07:27,319 --> 00:07:30,540
走到下一条可以执行的句子

205
00:07:30,540 --> 00:07:31,620
那是一个print f

206
00:07:31,620 --> 00:07:32,100
你好

207
00:07:32,100 --> 00:07:34,430
也就是它已经进入了k2 的地方

208
00:07:34,430 --> 00:07:36,620
然后遇到break才会离开switch case

209
00:07:36,620 --> 00:07:38,329
所以对于这个switch case来说

210
00:07:38,329 --> 00:07:39,170
事实上就意味着

211
00:07:39,170 --> 00:07:41,500
无论你的type是一还是二

212
00:07:42,360 --> 00:07:45,639
他的做的事情是一样的啊

213
00:07:45,639 --> 00:07:47,559
你看如果做了看等于三

214
00:07:47,559 --> 00:07:49,119
那我会到三的这个地方来

215
00:07:49,119 --> 00:07:50,139
我会说出晚上好

216
00:07:50,139 --> 00:07:51,098
可是晚上好

217
00:07:51,098 --> 00:07:52,990
这句print后面没有break

218
00:07:52,990 --> 00:07:53,769
没有break

219
00:07:53,769 --> 00:07:55,149
于是他会继续往下走

220
00:07:55,149 --> 00:07:57,129
虽然这里有k4 和k4 

221
00:07:57,129 --> 00:07:58,259
只是一个站牌

222
00:07:58,420 --> 00:07:59,800
他只是一个站牌

223
00:07:59,800 --> 00:08:01,439
他并不会让你停下来

224
00:08:01,439 --> 00:08:02,819
所以你会继续继续走

225
00:08:02,819 --> 00:08:04,019
走到his 4里面去

226
00:08:04,019 --> 00:08:05,189
做了那句再见

227
00:08:05,189 --> 00:08:06,240
然后才会遇到break

228
00:08:06,240 --> 00:08:08,060
这个break才会让你跳出来

229
00:08:08,439 --> 00:08:10,089
我们来试一下这个代码

230
00:08:10,089 --> 00:08:12,819
现在呢我们一样是在这一行做一个断点啊

231
00:08:12,819 --> 00:08:14,079
我们先来试一下它的

232
00:08:14,079 --> 00:08:15,220
等于一的情况

233
00:08:16,500 --> 00:08:17,720
我们输入的是一

234
00:08:19,939 --> 00:08:20,720
tb等于一

235
00:08:20,720 --> 00:08:21,829
我们现在在这儿

236
00:08:21,829 --> 00:08:25,339
下一步他直接跳到了这句print

237
00:08:25,339 --> 00:08:27,170
因为你看一后面没有句子嘛

238
00:08:27,170 --> 00:08:28,279
二后面才有句子嘛

239
00:08:28,279 --> 00:08:29,420
所以对于一来说

240
00:08:29,420 --> 00:08:31,918
他下面接下来就遇到了第一句能做的事情

241
00:08:31,918 --> 00:08:32,879
就是这个print

242
00:08:32,879 --> 00:08:33,418
你好

243
00:08:33,418 --> 00:08:35,509
然后break

244
00:08:35,509 --> 00:08:36,620
那当然就出来了

245
00:08:36,620 --> 00:08:37,639
这就结束了

246
00:08:37,639 --> 00:08:39,139
我们再来试下一个数

247
00:08:39,139 --> 00:08:41,139
如果现在我们是二

248
00:08:42,759 --> 00:08:46,980
那么下一步当然它还是到了二后面

249
00:08:46,980 --> 00:08:48,659
然后break就出来了

250
00:08:50,960 --> 00:08:53,179
现在如果我们是三

251
00:08:57,779 --> 00:09:00,919
他会到k3 后面输出一句晚上好

252
00:09:00,919 --> 00:09:04,480
然后在下一步的时候会进入k 14的令d

253
00:09:04,480 --> 00:09:05,529
这只是个路牌

254
00:09:05,529 --> 00:09:06,820
没有没有挡住他

255
00:09:06,820 --> 00:09:07,299
对不对

256
00:09:07,299 --> 00:09:09,490
所以会去做那个再见

257
00:09:09,490 --> 00:09:11,139
然后break出来了

258
00:09:11,179 --> 00:09:16,620
所以case并不是划分一段和一段的标志

259
00:09:16,620 --> 00:09:18,899
case只是一个入口

260
00:09:18,899 --> 00:09:20,318
只是一个路牌

261
00:09:20,460 --> 00:09:23,879
case不能阻止句子继续往下执行

262
00:09:23,879 --> 00:09:25,399
只有break可以

263
00:09:25,580 --> 00:09:28,859
这是初学者要特别特别小心的地方

264
00:09:28,960 --> 00:09:31,090
当然一般来说呃

265
00:09:31,090 --> 00:09:32,440
我们一正常的写代码

266
00:09:32,440 --> 00:09:34,990
我们会为每一个case配一个break

267
00:09:34,990 --> 00:09:36,789
只有在一些特殊的情况下

268
00:09:36,789 --> 00:09:38,080
我们后面会看到例子

269
00:09:38,080 --> 00:09:40,909
我们才会利用这个特性

270
00:09:40,909 --> 00:09:43,279
我们想利用这种特性

271
00:09:43,279 --> 00:09:45,860
让两个甚至更多的case

272
00:09:45,860 --> 00:09:47,629
能够做一个相同的事情

273
00:09:47,629 --> 00:09:49,610
这个时候我们才会去这样子做

274
00:09:49,610 --> 00:09:50,480
正常情况下

275
00:09:50,480 --> 00:09:53,299
我们当然应该为每一个case pea break

276
00:09:53,740 --> 00:09:55,779
我们在p a t上有这样的题目

277
00:09:55,779 --> 00:09:57,159
要写一个程序呢

278
00:09:57,159 --> 00:09:59,950
把百分制的成绩转换为五分制的成绩

279
00:09:59,950 --> 00:10:01,269
给了一个转换规则

280
00:10:01,269 --> 00:10:02,490
大于等于90

281
00:10:02,490 --> 00:10:04,019
那么当然也包括100分

282
00:10:04,019 --> 00:10:09,320
它是a90 不到80以上

283
00:10:09,320 --> 00:10:11,419
那么是b小于80

284
00:10:11,419 --> 00:10:12,379
大于等于70

285
00:10:12,379 --> 00:10:16,139
为c那么这样的题目当然这是一个范围

286
00:10:16,139 --> 00:10:19,019
我们首先会想到是做吉连的e f l c

287
00:10:19,700 --> 00:10:24,740
我们可以说如果这个score大于等于90

288
00:10:24,840 --> 00:10:28,230
那我们输出什么什么else呢

289
00:10:28,230 --> 00:10:32,279
如果这个score大于等于80

290
00:10:32,279 --> 00:10:33,899
那我们怎么怎么做

291
00:10:33,899 --> 00:10:37,220
再else等等等等啊

292
00:10:37,220 --> 00:10:38,740
我们可以写出这样的代码来

293
00:10:39,500 --> 00:10:40,629
这是一个办法

294
00:10:40,629 --> 00:10:41,799
但是呢针对这道题目

295
00:10:41,799 --> 00:10:43,210
其实我们还有特殊的办法

296
00:10:43,210 --> 00:10:45,519
我们看到在这个这个题目当中啊

297
00:10:45,700 --> 00:10:47,049
很有意思的就是

298
00:10:47,049 --> 00:10:51,580
其实我们可以用分数的十位数来判断

299
00:10:51,580 --> 00:10:52,839
我该说出什么

300
00:10:54,000 --> 00:10:55,039
所有的80分

301
00:10:55,039 --> 00:10:58,519
从80~89都应该输出的是b

302
00:10:58,639 --> 00:10:59,779
所有的70分

303
00:10:59,779 --> 00:11:02,000
从70~79都应该输出的c

304
00:11:02,000 --> 00:11:05,059
所以我们只要能够得到那个数字的十位数

305
00:11:05,059 --> 00:11:07,019
我们就可以继续做下去了

306
00:11:07,039 --> 00:11:09,259
如果我有个整数82

307
00:11:10,480 --> 00:11:12,690
我们拿它对十做整除

308
00:11:12,690 --> 00:11:14,190
我们不就得到八了吗

309
00:11:14,190 --> 00:11:15,690
这不就是它的十位数了吗

310
00:11:15,690 --> 00:11:18,120
如果有个93对十做整数

311
00:11:18,120 --> 00:11:19,359
我们就可以得到九

312
00:11:19,460 --> 00:11:20,960
这就是它的十位数了

313
00:11:20,960 --> 00:11:22,279
如果有个100

314
00:11:22,279 --> 00:11:25,438
我们对十座省数得到的是十

315
00:11:26,139 --> 00:11:29,080
当然我们得到的不是一个数字

316
00:11:29,080 --> 00:11:30,039
我们得到了十

317
00:11:30,039 --> 00:11:32,259
这需要我们在switch switch case里面想办法

318
00:11:32,259 --> 00:11:32,799
对不对

319
00:11:32,799 --> 00:11:33,580
但是不管怎么说

320
00:11:33,580 --> 00:11:35,080
我们可以得到那个十位数

321
00:11:35,080 --> 00:11:38,639
然后根据十位数做switch case来判断该输出什么

322
00:11:38,639 --> 00:11:41,370
所以呢我们可以得到这样的一个代码

323
00:11:41,370 --> 00:11:43,070
输入那个grade

324
00:11:43,070 --> 00:11:44,809
当然按照kt的要求

325
00:11:44,809 --> 00:11:45,830
这句话不应该有

326
00:11:45,830 --> 00:11:46,370
对不对

327
00:11:46,370 --> 00:11:48,529
然后我们把grade呢去除等于十

328
00:11:48,529 --> 00:11:52,110
就是对十作证除完了以后去switch这个grade

329
00:11:52,110 --> 00:11:53,610
如果是十

330
00:11:53,610 --> 00:11:55,289
也就是100分的时候会得到十

331
00:11:55,289 --> 00:11:55,649
对不对

332
00:11:55,649 --> 00:11:58,230
十或者九这两个case我们把它放在一起

333
00:11:58,230 --> 00:11:59,750
因为它都是a嘛

334
00:11:59,750 --> 00:12:02,460
那么这个时候我们就输出a8 的时候是b

335
00:12:02,460 --> 00:12:03,240
七的时候是c

336
00:12:03,240 --> 00:12:04,080
六的时候是d

337
00:12:04,080 --> 00:12:06,059
其他所有的那都是f了

338
00:12:06,059 --> 00:12:06,990
12345

339
00:12:06,990 --> 00:12:07,830
那都是f

340
00:12:07,830 --> 00:12:09,250
当然也包括零对吧

341
00:12:09,250 --> 00:12:09,730
好

342
00:12:09,730 --> 00:12:13,480
所以我们可以用switch case来做一些吉连的事情

343
00:12:13,480 --> 00:12:15,120
只要我们有办法做转换

344
00:12:15,159 --> 00:12:18,349
当然这个代码呢

345
00:12:18,349 --> 00:12:20,509
和我们之前讲的那个单一出口的原则

346
00:12:20,509 --> 00:12:21,589
是不相符的

347
00:12:21,589 --> 00:12:23,089
这些我目前还没办法是吧

348
00:12:23,089 --> 00:12:24,889
我们没有学过字符或者字符串的

349
00:12:24,889 --> 00:12:25,990
这个数据的处理

350
00:12:25,990 --> 00:12:26,889
如果你会做

351
00:12:26,889 --> 00:12:29,679
你就可以把它也改造成单一出口的代码

352
00:12:29,679 --> 00:12:30,970
我们当然不喜欢这样

353
00:12:30,970 --> 00:12:33,070
到处有一个个的print的这种情况

354
00:12:33,070 --> 00:12:33,740
对不对

355
00:12:33,919 --> 00:12:37,850
还有呢switch case经常可以用在做这样的事情

356
00:12:37,850 --> 00:12:40,818
我根据输入的这个月份的这个数字

357
00:12:40,818 --> 00:12:45,109
然后呢说出英文的代表月份的那个单词啊

358
00:12:45,109 --> 00:12:47,239
很多朋友会抱怨说这个英文的单词

359
00:12:47,239 --> 00:12:49,349
那个呃月份很难记是吧

360
00:12:49,349 --> 00:12:52,048
特别比如说john和july到底哪个6月哪个7月

361
00:12:52,048 --> 00:12:53,308
经常念叨的时候

362
00:12:53,308 --> 00:12:54,568
要自己在心里面过一遍

363
00:12:54,568 --> 00:12:56,159
jn july or 6月7月

364
00:12:56,159 --> 00:12:58,649
那如果写个程序来帮你输出一下

365
00:12:58,649 --> 00:12:59,250
会比较方便

366
00:12:59,250 --> 00:12:59,730
对不对

367
00:12:59,730 --> 00:13:01,590
我们根据month来判断

368
00:13:01,590 --> 00:13:03,929
然后我们这时候呢就把那break break break

369
00:13:03,929 --> 00:13:04,830
直接写在后面是吧

370
00:13:04,830 --> 00:13:05,789
print def january

371
00:13:05,789 --> 00:13:07,120
然后这就break了

372
00:13:07,379 --> 00:13:11,519
当然这样的代码今后可以用数组来做

373
00:13:11,519 --> 00:13:12,840
今后我们学了数组的话

374
00:13:12,840 --> 00:13:13,740
我们可以用数组

375
00:13:13,740 --> 00:13:15,519
把这个事情做的更加漂亮一点

376
00:13:15,519 --> 00:13:17,139
所以我们来看看试试看

377
00:13:17,139 --> 00:13:18,759
我们像这样的一个分段函数

378
00:13:18,759 --> 00:13:20,169
我们前面讲过分段函数

379
00:13:20,169 --> 00:13:22,958
也许比如说像我们这个成绩啊

380
00:13:23,159 --> 00:13:26,519
百分之a b c d我们可以用switch case来做

381
00:13:26,519 --> 00:13:27,360
像这样的一个分段函数

382
00:13:27,360 --> 00:13:29,070
有没有可能用switch case来做呢

383
00:13:29,070 --> 00:13:30,659
我们在讨论去讨论一下吧

