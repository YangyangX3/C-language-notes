1
00:00:04,200 --> 00:00:06,419
我们前面讲的都是一维数组啊

2
00:00:06,419 --> 00:00:09,580
也就是说这个数组呢只有一个下标的

3
00:00:09,580 --> 00:00:10,900
所以叫做一维数组

4
00:00:10,900 --> 00:00:13,720
这个数组呢可以看作是一个线性的东西

5
00:00:13,720 --> 00:00:15,160
从a0 到a 10

6
00:00:15,160 --> 00:00:16,390
从a0 到a9 

7
00:00:16,390 --> 00:00:17,759
那都是一个线性的

8
00:00:17,759 --> 00:00:20,570
那么除了线性的一维的数字之外

9
00:00:20,570 --> 00:00:22,399
当然c语言还可以做二维的

10
00:00:22,399 --> 00:00:23,030
除了二维的

11
00:00:23,030 --> 00:00:24,620
还可以做三维的思维能力

12
00:00:24,620 --> 00:00:27,460
你无法想象的为数它都可以做出来

13
00:00:27,980 --> 00:00:30,019
我们我们来看看二维数组怎么做啊

14
00:00:30,019 --> 00:00:31,370
做二维数组的时候呢

15
00:00:31,370 --> 00:00:33,109
我们是这样来定义的

16
00:00:33,109 --> 00:00:35,299
我们说有个int a35 

17
00:00:36,340 --> 00:00:39,789
也就是说我在那个数组变量后面

18
00:00:39,789 --> 00:00:41,590
不止不是只有一个方括号

19
00:00:41,590 --> 00:00:42,670
我还有另外一对方

20
00:00:42,670 --> 00:00:44,109
括号两对方块

21
00:00:44,109 --> 00:00:45,130
它就是一个二维数组

22
00:00:45,130 --> 00:00:47,289
那当然你想到了三对四对

23
00:00:47,289 --> 00:00:49,070
那它就是三维四维的数组

24
00:00:49,070 --> 00:00:51,799
那么当我们写出说int a35 的时候呢

25
00:00:51,799 --> 00:00:56,279
我们通常的理解a是一个三行五列的矩阵

26
00:00:59,759 --> 00:01:03,439
如果你一定要想说我要把它转过来

27
00:01:03,439 --> 00:01:07,579
我我说的是一个呃五行三列也可以

28
00:01:07,579 --> 00:01:09,840
因为如果你不去考虑

29
00:01:09,840 --> 00:01:12,200
这个数组在计算机内部

30
00:01:12,200 --> 00:01:14,030
在内存里面到底是怎么排列的

31
00:01:14,030 --> 00:01:16,129
那么从逻辑上来说

32
00:01:16,129 --> 00:01:17,900
他反正就是那么一个矩阵

33
00:01:17,900 --> 00:01:19,909
你拿着拿第一个数字单行

34
00:01:19,909 --> 00:01:21,789
拿第二个数字单行都是一样的

35
00:01:21,789 --> 00:01:24,608
但是如果你考虑到它在内存里头

36
00:01:24,608 --> 00:01:25,328
是怎么排列的

37
00:01:25,328 --> 00:01:28,390
那么我们倾向于把第一个数字当做行号

38
00:01:28,390 --> 00:01:30,189
把第二个数字当做列号

39
00:01:30,189 --> 00:01:32,230
所以如果我们有三行五列

40
00:01:32,230 --> 00:01:33,370
这个a35 的话

41
00:01:33,370 --> 00:01:35,170
在内存里面它是这样放的

42
00:01:35,170 --> 00:01:38,439
它是左上角这个叫a00 

43
00:01:38,579 --> 00:01:40,859
然后呢下一个叫a01 a02 

44
00:01:40,859 --> 00:01:41,340
a03 

45
00:01:41,340 --> 00:01:41,909
a04 

46
00:01:41,909 --> 00:01:44,069
然后下面a0 a10 a1 

47
00:01:44,069 --> 00:01:46,390
下一行是a0 a20 a221 

48
00:01:46,390 --> 00:01:47,469
这样子放呢

49
00:01:47,469 --> 00:01:48,010
还有一个好处

50
00:01:48,010 --> 00:01:51,180
就是正好和我们在线性代数当中

51
00:01:51,180 --> 00:01:53,760
对这些东西的这个理解是一样的啊

52
00:01:53,760 --> 00:01:55,620
我我们在数学当中也这样理解

53
00:01:55,620 --> 00:01:57,359
我们在c语言当中也这样理解

54
00:01:57,359 --> 00:01:58,420
大家能够统一起来

55
00:01:58,420 --> 00:02:01,950
那么对于很多事情呢做起来可以呃顺很多

56
00:02:01,950 --> 00:02:03,750
那么对于一个二维数组来说呢

57
00:02:03,750 --> 00:02:06,899
我们最重要要做的事情就是要对它做便利

58
00:02:06,939 --> 00:02:07,840
也就是说

59
00:02:07,840 --> 00:02:09,879
跟我们在一维数组里面做的事一样

60
00:02:09,879 --> 00:02:10,719
我们要做便利

61
00:02:10,719 --> 00:02:12,099
但是对于一维数组来说

62
00:02:12,099 --> 00:02:13,439
因为我们只有一个维度

63
00:02:13,439 --> 00:02:14,879
也就是说我们只有一个索引

64
00:02:14,879 --> 00:02:15,599
只有一个下标

65
00:02:15,599 --> 00:02:16,560
所以我们便利的时候呢

66
00:02:16,560 --> 00:02:18,629
用一重循环就可以了

67
00:02:18,629 --> 00:02:19,919
那么对于二维数组来说呢

68
00:02:19,919 --> 00:02:21,960
我们便利就需要两重循环

69
00:02:22,219 --> 00:02:25,039
外面那一层遍历行号

70
00:02:25,039 --> 00:02:27,650
然后里面那一层呢来便利那个列号

71
00:02:27,650 --> 00:02:29,870
这样才能完成对一个矩阵的便利

72
00:02:29,870 --> 00:02:31,250
对于一个二维数组的便利

73
00:02:31,250 --> 00:02:32,810
比如说我们那个3x5

74
00:02:32,810 --> 00:02:34,598
那么对于行号来说

75
00:02:34,598 --> 00:02:35,498
i从0~3

76
00:02:35,498 --> 00:02:36,338
对于列号来说

77
00:02:36,338 --> 00:02:37,620
ga从0~5

78
00:02:37,620 --> 00:02:38,520
这样的话呢

79
00:02:38,520 --> 00:02:42,219
我们里面就可以对ai j来做操作

80
00:02:42,338 --> 00:02:43,658
和一维数组一样

81
00:02:43,658 --> 00:02:47,819
二维数组当中的每一个元素是一个整数

82
00:02:47,819 --> 00:02:49,319
或者如果你double阿伟

83
00:02:49,319 --> 00:02:50,280
那么是一个double

84
00:02:50,280 --> 00:02:54,259
因此呢a的i j它表示的是一个int

85
00:02:54,259 --> 00:02:58,399
它表示的是在第i行第j列上的单元

86
00:02:58,399 --> 00:03:00,498
当然同样的和一维数组一样

87
00:03:00,498 --> 00:03:02,239
我们是从零开始编号的啊

88
00:03:02,239 --> 00:03:03,270
从零开始编号的

89
00:03:03,270 --> 00:03:06,300
但是你如果把它写成ai逗号结

90
00:03:06,300 --> 00:03:08,849
因为我们知道在数学当中我们会这样写

91
00:03:08,849 --> 00:03:09,430
对不对

92
00:03:09,430 --> 00:03:13,569
a然后下标i逗号j表示说第i行第j列

93
00:03:13,569 --> 00:03:16,210
你如果在c语言里面把它写成a方

94
00:03:16,210 --> 00:03:18,259
括号i逗号j是什么意思呢

95
00:03:19,080 --> 00:03:22,159
你想想我们在表达式那里

96
00:03:22,159 --> 00:03:25,289
我们曾经提到过说逗号是一种运算符

97
00:03:25,289 --> 00:03:25,900
对不对

98
00:03:25,900 --> 00:03:29,020
因此i逗号j就是一个表达式

99
00:03:29,020 --> 00:03:31,539
这个表达式去计算的结果是j

100
00:03:31,539 --> 00:03:34,879
因此它就等于a方括号减

101
00:03:35,800 --> 00:03:38,460
这不是正确的表达二维数组的方式

102
00:03:38,460 --> 00:03:41,860
在一维数组我们可以用集合定义初始化

103
00:03:41,860 --> 00:03:42,819
直接给它值

104
00:03:42,819 --> 00:03:44,139
二维数组也可以啊

105
00:03:44,139 --> 00:03:44,860
二位速度也可以

106
00:03:44,860 --> 00:03:46,530
二维数组我们可以这样子来写

107
00:03:46,530 --> 00:03:47,370
但是呢

108
00:03:47,370 --> 00:03:49,829
当我们去对二维数组做初始化的时候

109
00:03:49,829 --> 00:03:51,718
我们必须要给出它的列数

110
00:03:51,718 --> 00:03:53,068
列数不可以省略

111
00:03:53,068 --> 00:03:56,038
不能让编译器帮你去数它有多少列

112
00:03:56,038 --> 00:03:57,269
列数不可以省略

113
00:03:57,269 --> 00:03:58,689
但是函数可以省略

114
00:03:58,689 --> 00:04:01,449
然后因为这里面是二维的东西

115
00:04:01,449 --> 00:04:04,969
所以呢你在大括号里头还得有大括号

116
00:04:04,969 --> 00:04:06,650
事实上你可以把它想象成

117
00:04:06,650 --> 00:04:07,969
说我们现在在定义什么呢

118
00:04:07,969 --> 00:04:09,939
说我们现在有那么一个数组

119
00:04:09,939 --> 00:04:12,219
这个数组里面的每一个呢

120
00:04:12,219 --> 00:04:13,769
是一个五个的数组

121
00:04:13,769 --> 00:04:15,269
所以这就顺理成章了

122
00:04:15,269 --> 00:04:17,009
这个大括号表达的就是

123
00:04:17,009 --> 00:04:19,019
有五个int的那么一个数组

124
00:04:19,019 --> 00:04:20,939
它作为a0 

125
00:04:20,939 --> 00:04:24,420
然后这个是五个int的一个数组

126
00:04:24,420 --> 00:04:25,589
它作为a1 

127
00:04:25,589 --> 00:04:26,819
这是这是a0 

128
00:04:26,819 --> 00:04:27,680
这是a1 

129
00:04:28,660 --> 00:04:31,139
那同样的跟一维数组一样

130
00:04:31,139 --> 00:04:33,750
如果你在这个当中有省略的

131
00:04:33,750 --> 00:04:35,420
那它补零

132
00:04:36,600 --> 00:04:38,839
然后也可以在c9 里面

133
00:04:38,839 --> 00:04:40,009
我们也可以用定位

134
00:04:40,009 --> 00:04:40,579
定位的时候

135
00:04:40,579 --> 00:04:44,360
你也得要用两个方括号来做它的定位的啊

136
00:04:44,360 --> 00:04:44,990
初始化

137
00:04:44,990 --> 00:04:46,129
还有事实上

138
00:04:46,129 --> 00:04:48,290
有的时候你会在别人的代码当中看到

139
00:04:48,290 --> 00:04:52,660
我们会用不带大括号的一连串的数字

140
00:04:52,740 --> 00:04:54,480
没有这个里面的大括号

141
00:04:54,480 --> 00:04:57,420
但是我可能也把它写成这样的样子哈

142
00:04:57,420 --> 00:04:58,769
这也是可以的

143
00:04:58,769 --> 00:05:02,160
因为如果你去看二维数组

144
00:05:02,160 --> 00:05:03,480
在内存当中的排列

145
00:05:03,480 --> 00:05:05,129
它跟一维数组是一样的

146
00:05:05,129 --> 00:05:06,800
所以你可以想象说

147
00:05:06,839 --> 00:05:10,319
他会把这个矩阵从左上角到右下角

148
00:05:10,319 --> 00:05:13,079
用你这些数字逐行的去填满

149
00:05:13,860 --> 00:05:15,199
所以是一样的效果

150
00:05:15,199 --> 00:05:16,879
你也可以不带大括号

151
00:05:16,879 --> 00:05:19,579
把它就当作一个一维的数组那样来初始化

152
00:05:19,579 --> 00:05:22,459
然后它会把里面的数字逐行的去填满

153
00:05:22,459 --> 00:05:24,079
当然你在书写的时候

154
00:05:24,079 --> 00:05:27,420
为了让程序看上去让人类读者更容易看懂

155
00:05:27,420 --> 00:05:29,879
那么你可以让它每一行分一行

156
00:05:29,879 --> 00:05:30,750
每一行分一行

157
00:05:30,750 --> 00:05:32,879
但看上去就跟一个矩阵是一样的了

158
00:05:32,879 --> 00:05:34,680
我们来看一个二维数组的例子哈

159
00:05:34,680 --> 00:05:36,509
大家都玩过这个啊

160
00:05:36,509 --> 00:05:37,680
这太to的游戏

161
00:05:37,680 --> 00:05:40,230
但这个游戏呢我们中文会把它叫做井字棋

162
00:05:40,230 --> 00:05:40,709
对不对

163
00:05:40,709 --> 00:05:42,668
就是我们会有一个3x3的矩阵

164
00:05:42,668 --> 00:05:44,949
然后呢这个矩阵上面呢你可以去画圈圈

165
00:05:44,949 --> 00:05:45,728
画叉叉

166
00:05:45,728 --> 00:05:49,420
那如果有一方把它连成一条线了

167
00:05:49,420 --> 00:05:51,129
它可能是横的

168
00:05:51,129 --> 00:05:52,720
也可能是竖的

169
00:05:52,720 --> 00:05:53,920
也可能是对角线

170
00:05:53,920 --> 00:05:56,538
那就表明他赢了

171
00:05:56,538 --> 00:05:58,459
所以呢我们要做的事情很简单

172
00:05:58,459 --> 00:06:00,199
我们并不是要去实现这个游戏

173
00:06:00,199 --> 00:06:04,930
我们只是说如果程序读到了这么一个矩阵

174
00:06:04,930 --> 00:06:05,439
程序

175
00:06:05,439 --> 00:06:06,339
通过输入

176
00:06:06,339 --> 00:06:08,230
从用户那边得到了这个举证

177
00:06:08,230 --> 00:06:11,170
那能不能判断出来现在的这个举证

178
00:06:11,170 --> 00:06:12,399
上面的那个情况

179
00:06:12,399 --> 00:06:15,540
他的叉叉和圈圈的那个分布

180
00:06:15,540 --> 00:06:17,850
是不是没有一方赢了

181
00:06:17,850 --> 00:06:18,930
如果打一方赢了

182
00:06:18,930 --> 00:06:21,329
把那一方的这个是圈圈还是叉叉

183
00:06:21,329 --> 00:06:22,170
给它输出出来

184
00:06:22,170 --> 00:06:23,910
说圈圈赢了或者叉叉赢了啊

185
00:06:23,910 --> 00:06:25,579
或者说谁也没赢

186
00:06:25,579 --> 00:06:27,339
怎么来做这样一个东西

187
00:06:27,360 --> 00:06:30,420
这个程序呢其实非常非常简单

188
00:06:30,420 --> 00:06:32,610
但是他刚好给我们演示了

189
00:06:32,610 --> 00:06:34,490
在矩阵运算当中

190
00:06:34,490 --> 00:06:35,839
在这个二维数组运算当中

191
00:06:35,839 --> 00:06:37,100
我们经常要做的一些事情

192
00:06:37,100 --> 00:06:40,259
比如说怎么样对一行去做便利

193
00:06:40,259 --> 00:06:42,418
怎么样对一列去做便利

194
00:06:42,418 --> 00:06:44,288
以及怎么样去判断一个对角线

195
00:06:44,288 --> 00:06:45,879
我们来看这个代码是怎么样的

196
00:06:45,879 --> 00:06:48,189
首先呢我们要去定义这样一个board

197
00:06:48,189 --> 00:06:48,428
对不对

198
00:06:48,428 --> 00:06:50,379
我们要定义说我们有这样一个棋盘

199
00:06:50,379 --> 00:06:52,850
上一层si 3乘三的那么一个棋盘

200
00:06:52,850 --> 00:06:55,189
然后呢我们要去读入那个矩阵

201
00:06:55,189 --> 00:06:57,079
读入的时候我们做了一个便利

202
00:06:57,079 --> 00:07:03,250
然后用skin f去读入数组当中的每一个元素

203
00:07:03,250 --> 00:07:07,399
我们讲过数组的名字

204
00:07:07,399 --> 00:07:10,269
加上它的下标就是一个变量

205
00:07:10,269 --> 00:07:12,370
因此变量前面加上and

206
00:07:12,370 --> 00:07:15,069
就跟我们之前做普通变量的这种sf的

207
00:07:15,069 --> 00:07:16,240
都是没有区别的

208
00:07:16,240 --> 00:07:17,339
好这是一样的

209
00:07:18,040 --> 00:07:19,649
通过这样一个两重循环

210
00:07:19,649 --> 00:07:21,629
我们把整个矩阵读进来了

211
00:07:21,629 --> 00:07:24,410
然后去检查行的时候

212
00:07:24,410 --> 00:07:25,819
我们做的事情是说

213
00:07:25,819 --> 00:07:28,459
我们去有两个初始化的变量啊

214
00:07:28,459 --> 00:07:30,899
number of o圈圈的数量

215
00:07:31,540 --> 00:07:33,120
number of o圈圈的数量

216
00:07:33,120 --> 00:07:34,769
number of x叉叉的数量

217
00:07:34,769 --> 00:07:35,850
一开始是零

218
00:07:35,850 --> 00:07:38,699
然后呢对应于i这一行

219
00:07:38,699 --> 00:07:43,939
我们去判断所有的每一这一行上的每一

220
00:07:43,939 --> 00:07:44,540
每一列

221
00:07:44,540 --> 00:07:45,920
也就是这一行上的每一个

222
00:07:45,920 --> 00:07:46,579
对不对

223
00:07:46,579 --> 00:07:48,949
所以呢保持这个行号是不变的

224
00:07:48,949 --> 00:07:50,970
但是列号呢从零到size

225
00:07:50,970 --> 00:07:53,009
所以如果它是叉叉的

226
00:07:53,009 --> 00:07:54,449
那么叉叉的数量加一

227
00:07:54,449 --> 00:07:56,310
否则的话圈圈的数量加一啊

228
00:07:56,310 --> 00:07:57,689
我们假设是一个白马的棋盘

229
00:07:57,689 --> 00:07:58,389
对不对

230
00:07:58,389 --> 00:08:01,420
然后这一个for循环

231
00:08:01,420 --> 00:08:03,399
其实看上去很大的一个for循环

232
00:08:03,399 --> 00:08:03,850
对不对

233
00:08:03,850 --> 00:08:05,120
他就走了三步

234
00:08:05,120 --> 00:08:06,350
是不是就走了三步

235
00:08:06,350 --> 00:08:07,310
走了三步

236
00:08:07,310 --> 00:08:11,149
去看这一行上的每一个哪个是叉叉

237
00:08:11,149 --> 00:08:12,620
有几个圈圈有几个

238
00:08:12,620 --> 00:08:14,149
那算完以后看一下

239
00:08:14,149 --> 00:08:16,519
如果圈圈的数量已经等于三了

240
00:08:16,519 --> 00:08:17,810
ok那圈圈就赢了

241
00:08:17,810 --> 00:08:19,639
否则的话如果叉叉的数量等于三了

242
00:08:19,639 --> 00:08:20,420
叉叉就赢了

243
00:08:20,420 --> 00:08:22,160
要不然那就谁也没赢

244
00:08:22,199 --> 00:08:23,399
谁也没赢怎么办

245
00:08:23,399 --> 00:08:24,480
我们再检查列对不对

246
00:08:24,480 --> 00:08:27,040
所以列的算法基本上是一样的

247
00:08:29,319 --> 00:08:31,889
先检查行再检查列

248
00:08:31,889 --> 00:08:35,938
列的算法和行的算法基本上又是一样的

249
00:08:37,279 --> 00:08:39,429
你看这是行的算法

250
00:08:39,429 --> 00:08:40,710
这是列的算法

251
00:08:40,710 --> 00:08:41,970
几乎是一模一样的

252
00:08:41,970 --> 00:08:42,960
变化在哪儿

253
00:08:42,960 --> 00:08:46,980
变化在于循环的外层和内层

254
00:08:46,980 --> 00:08:47,940
谁在外面

255
00:08:47,940 --> 00:08:50,220
谁在里面先走列

256
00:08:50,220 --> 00:08:52,230
还是先走行走行

257
00:08:52,230 --> 00:08:54,269
那这一行里面的每一列做检查

258
00:08:54,269 --> 00:08:55,950
所以这是对行做检查走列

259
00:08:55,950 --> 00:08:58,298
那么i是在变化的

260
00:08:58,298 --> 00:08:58,989
j不变

261
00:08:58,989 --> 00:09:03,019
因此是一列当中的每一行在做检查

262
00:09:03,019 --> 00:09:08,059
这样的两段代码有没有可能合并起来呢

263
00:09:09,259 --> 00:09:11,000
这个问题留给你

264
00:09:12,659 --> 00:09:14,299
检查对角线怎么检查

265
00:09:14,299 --> 00:09:20,230
那就是i i就是001122

266
00:09:20,230 --> 00:09:23,440
这是正对角线啊

267
00:09:23,440 --> 00:09:27,240
反对角线呢就是零和

268
00:09:28,460 --> 00:09:29,080
对不对

269
00:09:29,080 --> 00:09:31,029
size是33-0是三三

270
00:09:31,029 --> 00:09:32,559
还得再减一才是二

271
00:09:32,559 --> 00:09:34,419
所以零和零二

272
00:09:34,419 --> 00:09:37,809
然后下一个呢下一个是一一

273
00:09:37,809 --> 00:09:40,450
再下一个是二零

274
00:09:40,450 --> 00:09:42,309
这三个做个检查

275
00:09:42,309 --> 00:09:45,320
这样子呢做完这四遍检查

276
00:09:45,320 --> 00:09:47,720
那我们可以确定这张棋盘

277
00:09:47,720 --> 00:09:49,200
上面有没有谁赢了

