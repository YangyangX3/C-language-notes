1
00:00:04,419 --> 00:00:07,000
我们刚才啊确实实现了一个

2
00:00:07,000 --> 00:00:11,279
在运行过程当中会自己长大的数组

3
00:00:11,718 --> 00:00:13,249
这事儿很有意思

4
00:00:13,249 --> 00:00:14,148
对不对

5
00:00:14,148 --> 00:00:16,179
我们可以用它做很多事情

6
00:00:16,820 --> 00:00:20,019
可是呢刚才实现的这种数组

7
00:00:20,019 --> 00:00:22,000
有一个很大的弱点

8
00:00:22,000 --> 00:00:25,559
就是每一次他长大的时候

9
00:00:25,778 --> 00:00:29,719
我们都要去申请一块新的内存空间

10
00:00:30,339 --> 00:00:34,679
可以容纳下新的东西的全部的东西的

11
00:00:34,679 --> 00:00:36,518
然后要拷贝

12
00:00:37,439 --> 00:00:40,219
那就会有两个问题

13
00:00:40,219 --> 00:00:43,179
首先呢拷贝要花时间

14
00:00:43,439 --> 00:00:45,479
随着你数组的长大

15
00:00:45,479 --> 00:00:49,020
一开始可能100个变成1万个

16
00:00:49,020 --> 00:00:50,700
变成100万个

17
00:00:50,700 --> 00:00:54,320
那个时候卡贝一次要花很多时间

18
00:00:55,939 --> 00:00:59,058
还有有可能存在一种情况

19
00:00:59,259 --> 00:01:02,170
你明明有足够的内存

20
00:01:02,170 --> 00:01:05,620
可是却再也不能申请空间了

21
00:01:05,620 --> 00:01:07,019
什么情况呢

22
00:01:07,200 --> 00:01:10,560
我们一开始的时候申请了这么大块内存

23
00:01:11,819 --> 00:01:14,000
当我们这块内存不够

24
00:01:14,000 --> 00:01:15,079
我们要长大的时候

25
00:01:15,079 --> 00:01:18,980
我们是在它的后面又申请了一块内存

26
00:01:18,980 --> 00:01:20,219
更大一点的

27
00:01:21,120 --> 00:01:23,629
然后我们把这块给free掉了

28
00:01:23,629 --> 00:01:24,319
回收了

29
00:01:25,519 --> 00:01:27,599
如果这是内存的起点

30
00:01:28,299 --> 00:01:30,219
假如说啊起点是零

31
00:01:30,540 --> 00:01:33,180
接下去我们要再申请一块内存的时候

32
00:01:33,180 --> 00:01:35,310
是要比这块内存还要来得大

33
00:01:35,310 --> 00:01:37,920
那么显然当然比这块内存要来得大

34
00:01:37,920 --> 00:01:38,579
对不对

35
00:01:38,780 --> 00:01:43,319
于是我们肯定是在他的后面又申请了一块

36
00:01:44,420 --> 00:01:47,799
然后我们把它给free掉了

37
00:01:50,019 --> 00:01:53,420
再往下我们还想要一款内存的时候

38
00:01:53,500 --> 00:01:57,189
但很可能这个时候这里头是够的

39
00:01:57,189 --> 00:02:00,189
所以也许我们在这儿有了一块新的内存

40
00:02:00,189 --> 00:02:01,170
放在这

41
00:02:01,170 --> 00:02:03,640
然后把这些东西都free掉

42
00:02:04,500 --> 00:02:06,200
看上去没什么问题是吧

43
00:02:06,200 --> 00:02:07,939
但是总有一个时刻

44
00:02:07,939 --> 00:02:10,039
你会发现自己处于这样一个境地

45
00:02:10,659 --> 00:02:13,099
你有了这么大一块内存

46
00:02:14,039 --> 00:02:19,788
这叫做an在你的身后是你从零开始

47
00:02:19,788 --> 00:02:21,229
你放弃掉的

48
00:02:21,229 --> 00:02:25,180
n减那个broadsize的那么一块内存

49
00:02:25,539 --> 00:02:27,219
在你的前面

50
00:02:27,679 --> 00:02:29,359
你有一块内存

51
00:02:29,359 --> 00:02:31,729
它的大小是broadsize

52
00:02:31,729 --> 00:02:33,740
然后你到头了

53
00:02:34,618 --> 00:02:36,558
整个的内存空间就这么大

54
00:02:36,558 --> 00:02:37,439
没有了

55
00:02:38,118 --> 00:02:42,539
如果你去看看整个的剩下的内存空间里头

56
00:02:42,599 --> 00:02:43,259
好吧

57
00:02:43,259 --> 00:02:44,639
也许这块还要再大一点啊

58
00:02:44,639 --> 00:02:46,080
比如说有两个broadsize

59
00:02:46,080 --> 00:02:47,159
whatever broadside

60
00:02:47,159 --> 00:02:48,699
总比你的n小很多吧

61
00:02:49,919 --> 00:02:51,800
整个的剩余空间

62
00:02:51,800 --> 00:02:54,800
前面的前面的加后面的

63
00:02:54,800 --> 00:02:56,180
或者说前面的加后面的

64
00:02:56,180 --> 00:02:57,840
看你怎么定义前面后面啊

65
00:02:58,239 --> 00:03:01,239
比你想要的来来的大

66
00:03:01,239 --> 00:03:02,558
或者说足够

67
00:03:02,558 --> 00:03:06,610
可是呢你没有办法再申请那么大的空间了

68
00:03:09,460 --> 00:03:12,240
n减b s或者两个b s

69
00:03:12,560 --> 00:03:15,020
你要的是n加bs对吧

70
00:03:16,539 --> 00:03:17,669
但是你得不到了

71
00:03:17,669 --> 00:03:19,479
实际上剩余空间是有那么大的

72
00:03:21,239 --> 00:03:24,179
当然你现在在你的pc上面

73
00:03:24,179 --> 00:03:25,739
你有两个g

74
00:03:25,739 --> 00:03:26,218
三个g

75
00:03:26,218 --> 00:03:27,299
四个g的空间

76
00:03:27,299 --> 00:03:28,199
你不办

77
00:03:28,199 --> 00:03:29,599
你不担心这个事情

78
00:03:29,618 --> 00:03:32,199
可是如果你在一个内存受限的场合

79
00:03:32,199 --> 00:03:33,699
比如说在一个单片机里头

80
00:03:33,699 --> 00:03:37,729
那总共只有16k字节

81
00:03:37,729 --> 00:03:39,900
你很快就会遇到这样的东西

82
00:03:40,919 --> 00:03:42,319
所以这个方法可以用

83
00:03:42,319 --> 00:03:44,419
但是呢不够高效

84
00:03:44,419 --> 00:03:46,379
假如我们有一个办法

85
00:03:47,419 --> 00:03:50,639
我们原来的那块内存放哪儿不动

86
00:03:51,000 --> 00:03:54,629
我们不是去申请一块更大的内存

87
00:03:54,629 --> 00:03:57,569
而是就申请一块一个broken那么大的内存

88
00:03:57,569 --> 00:03:59,819
然后把它们连起来

89
00:04:00,778 --> 00:04:02,269
我不需要拷贝了

90
00:04:02,269 --> 00:04:05,419
我只要说你的这一个broken走完以后

91
00:04:05,419 --> 00:04:07,788
我告诉你说下一个brock在哪里

92
00:04:07,788 --> 00:04:09,620
然后你到那里去访问他

93
00:04:09,879 --> 00:04:12,310
那我们就可以避免了拷贝

94
00:04:12,310 --> 00:04:13,539
节约了时间

95
00:04:13,539 --> 00:04:16,060
我们又可以充分利用这块内存的

96
00:04:16,060 --> 00:04:17,180
每一个角角落落

