1
00:00:04,379 --> 00:00:05,230
素素呢

2
00:00:05,230 --> 00:00:06,580
就是指的

3
00:00:06,580 --> 00:00:10,390
能只能够被一和自己整除的那些数啊

4
00:00:10,390 --> 00:00:13,029
比如说235 70 10 30 79

5
00:00:13,029 --> 00:00:14,259
这些都是素素

6
00:00:15,759 --> 00:00:18,120
这个12就不是啊

7
00:00:18,120 --> 00:00:20,579
12可以背二四等等

8
00:00:20,579 --> 00:00:22,140
三这个数都可以整除

9
00:00:22,140 --> 00:00:23,129
所以它就不是数数

10
00:00:23,129 --> 00:00:25,809
只能被一和自己整除的数是数数

11
00:00:25,809 --> 00:00:27,250
现在如果我们要写一个程序

12
00:00:27,250 --> 00:00:30,149
这个程序读入一个用户输入的这个数x

13
00:00:30,149 --> 00:00:32,670
然后我们要来判断这个数是不是素数

14
00:00:33,689 --> 00:00:34,729
这个怎么做呢

15
00:00:34,729 --> 00:00:38,570
那基本的思路就是我们要去拿很多数据

16
00:00:38,570 --> 00:00:39,679
试着除他了

17
00:00:39,679 --> 00:00:42,200
如果他能够被那些数整除

18
00:00:42,200 --> 00:00:43,729
它就不是素数

19
00:00:43,729 --> 00:00:47,299
如果我们拿了除一和它自己以外的那些数

20
00:00:47,420 --> 00:00:48,920
去试过了

21
00:00:48,920 --> 00:00:51,079
它都不是都不能够被整除

22
00:00:51,079 --> 00:00:53,250
那么就认定他是一个素数

23
00:00:53,250 --> 00:00:55,049
所以呢我们来试试写写程序

24
00:00:55,049 --> 00:00:57,329
看我们已经有了这一点东西

25
00:00:59,539 --> 00:01:01,579
接下来我们要来判断它

26
00:01:01,579 --> 00:01:03,320
能不能被什么数整除

27
00:01:03,320 --> 00:01:07,000
我们要判断它能不能被23456

28
00:01:07,000 --> 00:01:10,868
一直到x减一这么多的数整除

29
00:01:10,868 --> 00:01:13,629
这时候显然我们需要有个循环

30
00:01:13,629 --> 00:01:18,760
这个循环呢当然我们就要选择用哪种循环

31
00:01:18,760 --> 00:01:19,319
对不对

32
00:01:19,319 --> 00:01:21,239
那么通常像这样的情况呢

33
00:01:21,239 --> 00:01:22,730
我们会选择用for循环

34
00:01:22,730 --> 00:01:24,530
因为我们有一个递增嘛

35
00:01:24,530 --> 00:01:26,150
有个非常明显的递增在那里

36
00:01:26,150 --> 00:01:28,909
而且呃两头的这个范围是很明确的

37
00:01:28,909 --> 00:01:32,200
所以呢我们可以说我们有个变量int叫做i

38
00:01:32,200 --> 00:01:33,879
然后我们可以要four

39
00:01:33,879 --> 00:01:35,140
这个i呢等于二

40
00:01:35,140 --> 00:01:35,920
我们从二开始

41
00:01:35,920 --> 00:01:36,760
不是从一开始

42
00:01:36,760 --> 00:01:37,310
对不对

43
00:01:37,310 --> 00:01:41,579
i呢小于i小于x

44
00:01:41,579 --> 00:01:44,780
就相当于i小于等于x减一

45
00:01:44,780 --> 00:01:47,359
在i小于x的这个条件里头呢

46
00:01:47,359 --> 00:01:50,640
在这个循环里面最大的i是x减一

47
00:01:50,640 --> 00:01:51,870
而不会是x

48
00:01:51,870 --> 00:01:54,399
然后循环的每一轮我们让i加加

49
00:01:55,819 --> 00:01:57,939
那循环的每一轮我们得到了一个i

50
00:01:57,939 --> 00:01:59,980
我们要做的事情就是我们要去判断说

51
00:01:59,980 --> 00:02:03,879
如果呢这个x百分号了

52
00:02:03,879 --> 00:02:09,000
这个i对h于它的结果是零

53
00:02:11,860 --> 00:02:13,620
如果它的结果是零

54
00:02:13,620 --> 00:02:14,699
这表明什么

55
00:02:14,699 --> 00:02:21,098
表明这个x它不是一个数数对吧

56
00:02:21,098 --> 00:02:23,560
那我们怎么办呢

57
00:02:26,618 --> 00:02:29,199
我们如果说我们在这个地方

58
00:02:29,199 --> 00:02:31,179
就用一个print f说啊

59
00:02:31,179 --> 00:02:33,800
这个东西不是素素素

60
00:02:35,179 --> 00:02:37,120
如果是这样子的话

61
00:02:37,519 --> 00:02:38,778
那么我们想象一下

62
00:02:38,778 --> 00:02:42,319
比如说我们现在这个数呢是六

63
00:02:43,860 --> 00:02:45,590
当i等于二的时候

64
00:02:45,590 --> 00:02:47,520
我们发现六

65
00:02:49,080 --> 00:02:52,400
我们发现600分号二是零

66
00:02:52,400 --> 00:02:54,319
于是我们输出不是输出

67
00:02:54,319 --> 00:02:58,460
然后i加加i变成了三循环回来

68
00:02:58,460 --> 00:03:03,338
600分号三又是能整出的

69
00:03:03,338 --> 00:03:04,538
然后我们又输出一遍

70
00:03:04,538 --> 00:03:05,520
不是输出

71
00:03:07,020 --> 00:03:09,620
这好像也不合理对吧

72
00:03:09,620 --> 00:03:13,340
第一第二呢我们什么时候去说它是数数呢

73
00:03:14,240 --> 00:03:15,759
因为是输出的条件

74
00:03:15,759 --> 00:03:18,460
是所有整个循环都走完了

75
00:03:18,859 --> 00:03:20,868
没有任何一个数能够整出它

76
00:03:20,868 --> 00:03:22,278
于是我们说它是苏苏了

77
00:03:22,278 --> 00:03:26,280
可是现在在这个地方怎么走完了走完了

78
00:03:26,280 --> 00:03:27,360
咱就到了这了

79
00:03:27,360 --> 00:03:28,020
到了这儿

80
00:03:28,020 --> 00:03:29,159
如果我们在这儿来说啊

81
00:03:29,159 --> 00:03:34,620
普林特f一直说这个说说是素数

82
00:03:36,899 --> 00:03:39,649
那我们知道这个for循环怎么都要走完的嘛

83
00:03:39,649 --> 00:03:41,359
你里头有没有得到四数数

84
00:03:41,359 --> 00:03:42,498
他这早上走完了嘛

85
00:03:42,498 --> 00:03:43,199
对不对

86
00:03:43,560 --> 00:03:44,900
所以看来不行

87
00:03:46,759 --> 00:03:49,389
所以像这样的情况呢

88
00:03:49,389 --> 00:03:51,699
我们需要做这样一件事情

89
00:03:52,520 --> 00:03:56,710
我们在这儿再来一个变量叫做is prime

90
00:03:56,710 --> 00:03:58,360
我们一开始让它等于一

91
00:03:58,360 --> 00:03:59,560
开始让它等于一

92
00:04:00,240 --> 00:04:01,639
一开始等于零还是等于一

93
00:04:01,639 --> 00:04:02,120
是有讲究

94
00:04:02,120 --> 00:04:03,979
我们来看我们为什么要拿到等于一啊

95
00:04:03,979 --> 00:04:06,409
我们想要用这个变量表达的是说

96
00:04:06,409 --> 00:04:10,248
这个x是素数

97
00:04:10,248 --> 00:04:12,558
也就是说如果is prime是一的话

98
00:04:12,558 --> 00:04:14,590
表明x是数数

99
00:04:14,590 --> 00:04:17,769
所以呢如果我们能够做出这个判断

100
00:04:17,769 --> 00:04:19,540
那么好在这里我们就可以说

101
00:04:19,540 --> 00:04:22,720
如果is prime是一的话

102
00:04:22,920 --> 00:04:26,660
我们就苏苏说他是苏苏

103
00:04:27,180 --> 00:04:31,920
那else呢呃我们就苏苏说他不是苏苏

104
00:04:35,540 --> 00:04:38,620
啊如果我们能够通过这里这里的计算

105
00:04:38,620 --> 00:04:40,180
现在我们当然这个技术还没写好

106
00:04:40,180 --> 00:04:43,060
如果能够知道is prime

107
00:04:43,060 --> 00:04:46,209
那我们就可以写出这样的这个句子来啊

108
00:04:46,209 --> 00:04:47,800
然后让他输出是不是输出

109
00:04:47,800 --> 00:04:49,300
那接下来问题就是说

110
00:04:49,339 --> 00:04:51,980
如果当我们在循环里头

111
00:04:51,980 --> 00:04:54,139
发现x能够被i整除

112
00:04:54,139 --> 00:04:55,579
就证明它不是数数

113
00:04:55,579 --> 00:04:56,660
那我们只要做一件事情

114
00:04:56,660 --> 00:04:58,899
说is prime等于零

115
00:05:00,360 --> 00:05:01,579
它就不是素数了

116
00:05:02,779 --> 00:05:03,379
对不对

117
00:05:03,379 --> 00:05:04,790
那么然后呢

118
00:05:04,790 --> 00:05:07,009
我们就在后面的这个循环结束以后呢

119
00:05:07,009 --> 00:05:09,410
我们就知道了这个塔是他不是零了

120
00:05:09,410 --> 00:05:11,329
我们为什么要设他一开始为一

121
00:05:11,329 --> 00:05:13,269
是因为我们发现的那个条件

122
00:05:13,269 --> 00:05:16,029
是要使得它为零的条件对吧

123
00:05:16,029 --> 00:05:17,959
所以我们设它的促使者为一

124
00:05:17,959 --> 00:05:19,879
虽然我们之前看过的很多例子

125
00:05:19,879 --> 00:05:21,379
我们都会设初始值为零

126
00:05:21,379 --> 00:05:23,149
但是这个地方正好不一样

127
00:05:23,149 --> 00:05:25,610
是因为我们需要去证伪

128
00:05:25,610 --> 00:05:27,050
而不是证实

129
00:05:27,050 --> 00:05:28,699
不是去正真对吧

130
00:05:28,699 --> 00:05:32,279
我们是通过它无法被证伪来证明它是真的

131
00:05:32,279 --> 00:05:34,500
所以如果它被证明是伪的

132
00:05:34,500 --> 00:05:37,139
那么我们就把这个变量变成是零

133
00:05:37,319 --> 00:05:39,699
这个程序当然是可以可以运行的

134
00:05:39,699 --> 00:05:41,019
我们可以不妨来试一下哈

135
00:05:41,019 --> 00:05:42,459
为了在这里试的方便呢

136
00:05:42,459 --> 00:05:44,499
同样呢我们会把这个skin f给注释掉

137
00:05:44,499 --> 00:05:46,598
然后说那个x就是一个特定的值

138
00:05:46,598 --> 00:05:48,019
比如说如果说13

139
00:05:50,939 --> 00:05:52,819
他会说这个东西是素数

140
00:05:52,819 --> 00:05:57,329
如果说这12他会说这个东西不是素素

141
00:05:57,329 --> 00:05:59,459
这代码运行是对的哈

142
00:05:59,459 --> 00:06:03,589
但是你有没有觉得这里头

143
00:06:03,589 --> 00:06:06,060
比如说我们现在x 16的时候

144
00:06:07,279 --> 00:06:08,110
x是六

145
00:06:08,110 --> 00:06:09,970
它的执行会是怎么样子的

146
00:06:09,970 --> 00:06:11,399
我们来debug一下

147
00:06:11,939 --> 00:06:15,540
我们呢还是用这个六来做这个实验啊

148
00:06:15,540 --> 00:06:17,829
我们在for循环前面呢设置一个断点

149
00:06:17,829 --> 00:06:19,629
这样呢我们可以跟踪看for循环里面

150
00:06:19,629 --> 00:06:20,500
它是怎么走的

151
00:06:20,500 --> 00:06:21,670
我们来调试运行

152
00:06:21,670 --> 00:06:22,990
现在呢我们在这儿啊

153
00:06:22,990 --> 00:06:25,149
在这儿我们来看一下我们的i是多少呢

154
00:06:25,149 --> 00:06:28,720
i 12 x大概就是六了是吧

155
00:06:28,720 --> 00:06:31,480
然后is prime这时候是一啊

156
00:06:31,480 --> 00:06:33,970
我们默认觉得它是ok的是吧

157
00:06:33,970 --> 00:06:35,420
然后呢我们来下一步

158
00:06:35,579 --> 00:06:37,980
下一步当然二小于六

159
00:06:37,980 --> 00:06:38,990
我们进了循环

160
00:06:38,990 --> 00:06:40,189
进入循环以后呢

161
00:06:40,189 --> 00:06:43,069
我们来看x百分号i也就百分号

162
00:06:43,069 --> 00:06:44,329
这个二是不是等于零的

163
00:06:44,329 --> 00:06:45,350
显然它应该等于零的

164
00:06:45,350 --> 00:06:46,158
所以我们进去了

165
00:06:46,158 --> 00:06:48,668
进去以后我们使得is prime为零

166
00:06:48,668 --> 00:06:49,988
所以这就破了

167
00:06:49,988 --> 00:06:50,978
对吧啊

168
00:06:50,978 --> 00:06:53,588
呃六已经我们已经通过这一轮的循环

169
00:06:53,588 --> 00:06:57,220
我们已经证明了这个x也就是这个六

170
00:06:57,220 --> 00:06:58,269
它不是一个素数

171
00:06:58,269 --> 00:07:00,040
可是呢我们回到了for

172
00:07:00,040 --> 00:07:03,160
那因为我们循环结束条件是i小于x

173
00:07:03,160 --> 00:07:03,750
对不对

174
00:07:03,750 --> 00:07:05,879
所以呢循环还要继续下去的

175
00:07:05,879 --> 00:07:07,709
i加加i等于三

176
00:07:07,709 --> 00:07:08,899
我们再来判断

177
00:07:08,899 --> 00:07:11,959
然后又发现说3/600能够整除的

178
00:07:11,959 --> 00:07:13,360
于是is prime是零

179
00:07:13,360 --> 00:07:15,519
但再多做了好几轮的循环

180
00:07:15,519 --> 00:07:17,709
一直要走到那个i小于五为止

181
00:07:17,709 --> 00:07:19,579
我们才出来

182
00:07:20,180 --> 00:07:21,680
那i等于五小于六为止

183
00:07:21,680 --> 00:07:22,550
我们才出来

184
00:07:22,550 --> 00:07:25,220
然后这个时候根据is prime是不是零

185
00:07:25,220 --> 00:07:28,620
还是一来决定输出是速度还是不是素数

186
00:07:29,339 --> 00:07:31,519
所以在这个代码当中

187
00:07:31,519 --> 00:07:32,480
我们就发现说

188
00:07:32,480 --> 00:07:34,790
其实当我们第一次发现

189
00:07:34,790 --> 00:07:37,379
x能够被i整除的时候

190
00:07:37,379 --> 00:07:41,300
我们就不需要他继续做这个for循环了啊

191
00:07:41,300 --> 00:07:42,680
不需要再继续做for循环了

192
00:07:42,680 --> 00:07:44,720
所以我们能不能有一种办法

193
00:07:44,720 --> 00:07:48,059
当我们设了is primary 0以后

194
00:07:48,059 --> 00:07:50,399
就能够让他离开循环呢

195
00:07:50,879 --> 00:07:52,500
c语言提供了一种办法

196
00:07:52,500 --> 00:07:55,100
有一个语句叫做break

197
00:07:56,939 --> 00:07:59,420
你可以在这里设一个break诶等等

198
00:07:59,420 --> 00:08:00,920
这个break我们见过的对吧

199
00:08:00,920 --> 00:08:02,730
然后在哪见过这个break

200
00:08:02,730 --> 00:08:04,829
我们在switch case里见过break

201
00:08:04,829 --> 00:08:05,430
对不对

202
00:08:05,430 --> 00:08:07,300
switch case里面break做什么事情

203
00:08:07,639 --> 00:08:10,579
case后面的语句逐条的执行

204
00:08:10,579 --> 00:08:12,759
遇到break就离开switch

205
00:08:12,759 --> 00:08:15,639
现在我们的break在这里起的作用也是一样

206
00:08:15,639 --> 00:08:18,120
在循环里面如果有break

207
00:08:18,158 --> 00:08:21,759
这个break就会跳出循环循环

208
00:08:21,759 --> 00:08:22,988
不再继续做下去了

209
00:08:22,988 --> 00:08:25,119
你看我们重新来运行一下这个程序

210
00:08:25,119 --> 00:08:28,139
看我们来调试运行

211
00:08:28,379 --> 00:08:30,240
现在在第11行

212
00:08:30,240 --> 00:08:34,099
然后我们颁布下一步进入循环了

213
00:08:35,419 --> 00:08:38,538
2/600是等于零的

214
00:08:38,538 --> 00:08:39,619
进了衣服了

215
00:08:39,619 --> 00:08:40,849
is prime等于零了

216
00:08:40,849 --> 00:08:43,999
接下去我们在break t举了我们做break

217
00:08:43,999 --> 00:08:45,499
我们的下一步就到哪儿呢

218
00:08:45,499 --> 00:08:48,980
到了17行就离开了整个for循环

219
00:08:48,980 --> 00:08:52,340
一旦遇到break就会离开整个循环

220
00:08:52,340 --> 00:08:54,049
不管是for还是while还是do while

221
00:08:54,049 --> 00:08:55,100
任何循环都一样

222
00:08:55,100 --> 00:08:57,289
就会离开这个循环到循环下面去

223
00:08:57,289 --> 00:09:00,879
所以break可以让我们跳出循环

224
00:09:01,139 --> 00:09:02,340
除了break

225
00:09:02,340 --> 00:09:04,590
我们还有另外一个语句叫做continue

226
00:09:04,590 --> 00:09:07,899
continue做的事情是跳过循环

227
00:09:08,279 --> 00:09:11,509
break说我这个循环还有多少轮要跑

228
00:09:11,509 --> 00:09:12,889
都不跑了就出去了

229
00:09:12,889 --> 00:09:15,169
而continue说循环的这一轮

230
00:09:15,169 --> 00:09:17,539
下头还有多少语句要做不做了

231
00:09:17,539 --> 00:09:18,879
进入下一轮

232
00:09:19,419 --> 00:09:22,059
我们来试一个continue的一例子

233
00:09:22,120 --> 00:09:25,059
假如我们现在在循环的for

234
00:09:25,059 --> 00:09:26,500
循环的每一轮里头呢

235
00:09:26,500 --> 00:09:27,940
我们要做一件事情

236
00:09:27,940 --> 00:09:32,938
我们要输出当前正在测试的那个i的值

237
00:09:35,440 --> 00:09:37,299
啊每一轮都要测试这个了

238
00:09:37,299 --> 00:09:41,099
那么我们把这个break呢改成了continue

239
00:09:44,940 --> 00:09:48,799
所以呢呃如果我的条件满足进去了

240
00:09:48,799 --> 00:09:51,179
那么我就会做continue

241
00:09:51,179 --> 00:09:53,039
那么按照我们刚才的理解

242
00:09:53,039 --> 00:09:55,379
他应该还会继续做循环

243
00:09:55,379 --> 00:09:58,649
但是循环里面剩下的句子是不会做的了

244
00:09:58,649 --> 00:10:01,409
我们来试一个另外的x

245
00:10:01,409 --> 00:10:03,360
我们来试一个九啊

246
00:10:03,360 --> 00:10:04,019
我们来试一个九

247
00:10:04,019 --> 00:10:06,000
然后看看它的运行会是怎么样子的

248
00:10:10,200 --> 00:10:11,899
现在呢我们的i等于二

249
00:10:11,899 --> 00:10:12,559
x等于九

250
00:10:13,820 --> 00:10:14,899
那么在这一步

251
00:10:14,899 --> 00:10:19,120
在这一轮我们进去i和x之间的关系

252
00:10:19,120 --> 00:10:20,649
它是不能整除的对吧

253
00:10:20,649 --> 00:10:21,490
九不能被二整除

254
00:10:21,490 --> 00:10:22,539
所以我们没进去

255
00:10:22,539 --> 00:10:23,169
没进去

256
00:10:23,169 --> 00:10:26,720
我们就会输出这个这个x啊

257
00:10:26,720 --> 00:10:27,679
i的这个值啊

258
00:10:27,679 --> 00:10:29,149
在这一轮会做这个print f

259
00:10:29,149 --> 00:10:31,830
然后在下一轮i变成三了

260
00:10:31,830 --> 00:10:35,720
这个时候呢x和i的整除关系是满足的

261
00:10:35,720 --> 00:10:36,019
满足的

262
00:10:36,019 --> 00:10:37,909
我们就进了这个f语句了

263
00:10:37,909 --> 00:10:39,679
然后我们到了continue

264
00:10:39,679 --> 00:10:41,450
当我们执行这句continue的时候

265
00:10:41,450 --> 00:10:45,710
下一步就直接回到for循环的头上去了

266
00:10:45,710 --> 00:10:50,019
这里的16行的这个pnf就被跳过了啊

267
00:10:50,019 --> 00:10:52,539
所以就是continue和break在这个事情上面

268
00:10:52,539 --> 00:10:53,320
他们是不一样的

269
00:10:53,320 --> 00:10:56,059
break是要打破这个打破嘛

270
00:10:56,059 --> 00:10:56,720
不是叫打破

271
00:10:56,720 --> 00:10:56,960
对不对

272
00:10:56,960 --> 00:10:58,279
打破这个循环要出去

273
00:10:58,279 --> 00:11:01,940
而continue呢是把这一轮没做的东西放弃了

274
00:11:01,940 --> 00:11:03,179
去做下一轮

275
00:11:03,179 --> 00:11:05,159
所以它们之间还是有差异的

276
00:11:05,340 --> 00:11:07,860
当然你具体情况你要具体选择

277
00:11:07,860 --> 00:11:10,219
你到底应该用break还是用continue

278
00:11:10,679 --> 00:11:12,990
也就是说从这张流程图上来看呢

279
00:11:12,990 --> 00:11:14,759
如果我们有这样一个for循环对吧

280
00:11:14,759 --> 00:11:16,019
这是初始化判断条件

281
00:11:16,019 --> 00:11:16,679
循环体不进

282
00:11:16,679 --> 00:11:17,799
所以这是个for循环

283
00:11:17,799 --> 00:11:20,620
如果在for在这个循环体内出现了一个break

284
00:11:20,620 --> 00:11:23,578
那么这个break就会导致这个循环

285
00:11:23,578 --> 00:11:26,129
结束到循环下面的那个句子去

286
00:11:26,129 --> 00:11:28,318
而如果在循环体里面有个continue

287
00:11:28,318 --> 00:11:32,370
那么这continue呢是使得它不再做循环体内

288
00:11:32,370 --> 00:11:33,269
接下去的语句

289
00:11:33,269 --> 00:11:35,190
但是他还要去做步进

290
00:11:35,190 --> 00:11:37,049
还要去继续判断条件

291
00:11:37,049 --> 00:11:39,500
还要继续进入下一轮的循环

292
00:11:40,879 --> 00:11:44,049
好像说我们现在面前呢

293
00:11:44,049 --> 00:11:47,320
这个我们请呃同学们依次站起来唱歌

294
00:11:47,320 --> 00:11:49,379
第一排的同学依次站起来唱歌

295
00:11:49,460 --> 00:11:51,860
第一位同学站起来唱的很好听

296
00:11:51,860 --> 00:11:53,179
唱完了坐下了

297
00:11:53,179 --> 00:11:54,980
第二位同学站起来唱了一半

298
00:11:54,980 --> 00:11:57,899
我们觉得这个有点听不下去了

299
00:11:57,899 --> 00:12:00,450
于是呢我们发了一个指令说continue

300
00:12:00,450 --> 00:12:05,980
所以呢他不再把他的那首歌唱完坐下

301
00:12:05,980 --> 00:12:08,710
但是呢会让第三位同学站起来

302
00:12:08,710 --> 00:12:11,000
也就是下一轮循环还要继续

303
00:12:11,000 --> 00:12:12,620
可是第三位同学唱了一半

304
00:12:12,620 --> 00:12:15,019
我觉得实在是无法忍受了

305
00:12:15,019 --> 00:12:16,818
这个时候我们说了break

306
00:12:17,460 --> 00:12:19,379
于是第三位同学没唱完

307
00:12:19,379 --> 00:12:19,980
要坐下

308
00:12:19,980 --> 00:12:21,419
并且后面的第四位

309
00:12:21,419 --> 00:12:21,720
第五位

310
00:12:21,720 --> 00:12:24,099
第六位同学都不用再唱下去了

311
00:12:24,840 --> 00:12:27,159
这就是break和continue的区别

312
00:12:27,759 --> 00:12:28,559
顺便说啊

313
00:12:28,559 --> 00:12:29,399
在这个程序上面啊

314
00:12:29,399 --> 00:12:31,019
我们经常在一些教科书里面

315
00:12:31,019 --> 00:12:31,799
看到这样的例子

316
00:12:31,799 --> 00:12:32,700
他是这么干的

317
00:12:32,700 --> 00:12:35,129
他没有这样的一个is prime的东西啊

318
00:12:35,129 --> 00:12:36,389
然后呢到这里呢

319
00:12:36,389 --> 00:12:38,789
它也不是判断这个is prime是不是等于一

320
00:12:38,789 --> 00:12:39,990
它判断的是什么呢

321
00:12:39,990 --> 00:12:44,120
它判断说i是不是等于x

322
00:12:45,919 --> 00:12:46,820
为什么可以这么做呢

323
00:12:46,820 --> 00:12:49,730
因为如果循环结束了

324
00:12:49,730 --> 00:12:52,279
完全走完了所有的i

325
00:12:52,279 --> 00:12:54,019
那么当循环结束的时候

326
00:12:54,019 --> 00:12:56,360
这个i应该是等于x的

327
00:12:56,360 --> 00:12:59,059
如果从中间break出来过了

328
00:12:59,059 --> 00:13:00,860
那么这个i呢一定是小于x的

329
00:13:00,860 --> 00:13:02,299
所以如果他说

330
00:13:02,299 --> 00:13:04,580
如果这个i呢是小于x的话呢

331
00:13:04,580 --> 00:13:07,070
那么它就不是数数

332
00:13:07,070 --> 00:13:09,049
而如果它等于x

333
00:13:09,049 --> 00:13:10,730
那么它就是数数

334
00:13:10,730 --> 00:13:12,919
这个方法看上去很聪明是吧

335
00:13:12,919 --> 00:13:15,620
利用了这个i和x之间的关系

336
00:13:15,620 --> 00:13:17,600
不再需要那个is preme变量

337
00:13:17,600 --> 00:13:20,120
就可以来判断它是不是素数了

338
00:13:21,200 --> 00:13:25,679
但是我个人觉得这个做法是不合适的

339
00:13:25,679 --> 00:13:27,019
是有害的

340
00:13:27,639 --> 00:13:28,960
你的观点如何

341
00:13:28,960 --> 00:13:30,279
我们到讨论区来讨论

