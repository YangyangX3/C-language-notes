1
00:00:04,080 --> 00:00:07,919
我们之前建的所有的文件都是文本文件

2
00:00:09,039 --> 00:00:11,279
虽然我们也没见很多文件呃

3
00:00:11,279 --> 00:00:13,250
我们的输出都是文本方式的

4
00:00:13,250 --> 00:00:14,330
你想呃

5
00:00:14,330 --> 00:00:16,280
当我们print df一个整数的时候

6
00:00:16,280 --> 00:00:19,160
实际上是把这个整数格式化了

7
00:00:19,160 --> 00:00:21,300
变成人可以见的形式

8
00:00:21,519 --> 00:00:23,320
12345这样的一个整数

9
00:00:23,320 --> 00:00:24,219
在计算机内部

10
00:00:24,219 --> 00:00:26,929
它不是以12345这样的面目出现的

11
00:00:26,929 --> 00:00:28,519
它变成二进制

12
00:00:28,519 --> 00:00:31,129
用四个字节来表达这个12345

13
00:00:31,129 --> 00:00:32,560
而不是用五个字节

14
00:00:32,560 --> 00:00:34,000
12345

15
00:00:34,000 --> 00:00:36,598
五个字符来表达这个12345的

16
00:00:36,960 --> 00:00:38,729
当我们输入的时候也是这样

17
00:00:38,729 --> 00:00:40,079
你输入的是12345

18
00:00:40,079 --> 00:00:41,119
实际上是什么

19
00:00:42,479 --> 00:00:45,200
你说的是个字符串对吧

20
00:00:45,200 --> 00:00:47,000
这个字符串里面有12345

21
00:00:47,000 --> 00:00:47,990
这样五个字符

22
00:00:47,990 --> 00:00:49,759
然后呢scaf做的是什么

23
00:00:49,759 --> 00:00:50,659
为什么它叫scaf

24
00:00:50,659 --> 00:00:53,119
不叫read scaf

25
00:00:53,119 --> 00:00:55,340
是要去识别他

26
00:00:55,340 --> 00:00:57,619
要去扫描你的这个字符串

27
00:00:57,619 --> 00:01:00,200
从当中呢去识别出那个整数

28
00:01:00,200 --> 00:01:03,140
然后给你填到一个整数的变量里头去

29
00:01:04,019 --> 00:01:05,900
所以这些都是文本的输入

30
00:01:05,900 --> 00:01:07,159
输出都是文本的

31
00:01:07,400 --> 00:01:09,739
当然我们还有另外一种东西

32
00:01:09,739 --> 00:01:10,920
就是二进制的

33
00:01:11,840 --> 00:01:14,409
其实二进制文件呢并不神秘啊

34
00:01:14,409 --> 00:01:15,700
从某种意义上说

35
00:01:15,700 --> 00:01:18,039
所有的文件最终都是二进制的

36
00:01:18,120 --> 00:01:19,920
文本文件最多也是二进制的

37
00:01:19,920 --> 00:01:22,799
只不过文本文件表现为一个人

38
00:01:22,799 --> 00:01:24,379
可以读的形式而已

39
00:01:24,680 --> 00:01:25,909
文本文件

40
00:01:25,909 --> 00:01:28,700
无非就是用简单的方式可以去读写

41
00:01:28,700 --> 00:01:29,959
比如说对于unix来说

42
00:01:29,959 --> 00:01:32,329
我们有more可以打开一个文件

43
00:01:32,329 --> 00:01:34,310
有tale可以去打开一个文件

44
00:01:34,310 --> 00:01:35,510
这些我们都试过了

45
00:01:35,510 --> 00:01:37,909
我们可以用c a t去打开一个文件

46
00:01:37,909 --> 00:01:40,730
我们可以用c a t从定向到一个文件里面

47
00:01:40,730 --> 00:01:42,560
从而往文件里面写东西

48
00:01:42,560 --> 00:01:44,209
当然你要做完整的编辑

49
00:01:44,209 --> 00:01:45,319
你可以用vi

50
00:01:46,140 --> 00:01:48,200
你有你有很多很简单的工具

51
00:01:48,200 --> 00:01:51,409
在linux里头可以去对文本文件进行操作

52
00:01:51,409 --> 00:01:53,299
但是对二进制文件就没那么简单

53
00:01:53,299 --> 00:01:55,118
比如说你有一个可进文件

54
00:01:55,118 --> 00:01:55,838
那是二进制的

55
00:01:55,838 --> 00:01:57,379
你想看它里头有什么

56
00:01:57,379 --> 00:01:58,700
你要用专用工具

57
00:01:58,700 --> 00:01:59,840
你有一张图片

58
00:01:59,840 --> 00:02:00,620
一个jpg

59
00:02:00,620 --> 00:02:01,819
那是二进制文件

60
00:02:01,819 --> 00:02:04,489
你想看这张图片也需要专门的工具

61
00:02:04,489 --> 00:02:06,280
你有一个mp 3

62
00:02:06,280 --> 00:02:07,000
你想听他

63
00:02:07,000 --> 00:02:08,560
你需要有专门的播放软件

64
00:02:08,560 --> 00:02:09,460
否则你听不了他

65
00:02:09,460 --> 00:02:11,080
你用more去打开一个mp 3

66
00:02:11,080 --> 00:02:12,340
你看不到任何有价值

67
00:02:12,340 --> 00:02:13,569
对你有价值的东西

68
00:02:13,569 --> 00:02:15,490
那么文本文件和二进制文件

69
00:02:15,490 --> 00:02:16,870
我们该怎么选择呢

70
00:02:16,870 --> 00:02:19,800
这件事情涉及江湖恩怨情仇

71
00:02:21,020 --> 00:02:23,680
最早的时候我们就unix操作系统对吧

72
00:02:23,680 --> 00:02:24,460
unix呢

73
00:02:24,460 --> 00:02:27,939
他喜欢用文本文件来做数据的存储

74
00:02:27,939 --> 00:02:29,069
和程序的配置

75
00:02:29,069 --> 00:02:31,259
也就是说比如说程序员有配置文件是吧

76
00:02:31,259 --> 00:02:32,310
那么这个配置文件呢

77
00:02:32,310 --> 00:02:34,780
可能他是文本文件做的啊

78
00:02:34,780 --> 00:02:36,280
我只要有vi

79
00:02:36,280 --> 00:02:37,210
我只要有more

80
00:02:37,210 --> 00:02:38,770
我有c t我就可以去查看

81
00:02:38,770 --> 00:02:40,620
我可以去修改那个配置文件

82
00:02:40,739 --> 00:02:43,739
因为在linux之前

83
00:02:43,739 --> 00:02:44,818
最开始的时候

84
00:02:44,818 --> 00:02:46,919
那计算机纯粹就是二进制的输入输出

85
00:02:46,919 --> 00:02:48,520
对不对呃

86
00:02:48,520 --> 00:02:50,379
等等到有交互式终端了

87
00:02:50,379 --> 00:02:51,969
这出现在unix之前啊

88
00:02:51,969 --> 00:02:53,319
交互式终端出现了

89
00:02:53,319 --> 00:02:56,199
人们就喜欢用文本的方式去和计算机做talk

90
00:02:56,199 --> 00:02:57,060
去交谈

91
00:02:57,060 --> 00:02:58,680
我输个命令ls s

92
00:02:58,680 --> 00:03:01,259
你列给我看这个目录底下有什么样的文件

93
00:03:01,259 --> 00:03:02,520
这是一种交谈

94
00:03:02,520 --> 00:03:03,860
对不对呃

95
00:03:03,860 --> 00:03:06,229
这个交谈显然它是文本形式的啊

96
00:03:06,229 --> 00:03:07,610
我们输进去的是文本

97
00:03:07,610 --> 00:03:09,500
他给我们看到的也是文本

98
00:03:09,618 --> 00:03:10,938
那unix shell呢

99
00:03:10,938 --> 00:03:11,598
因为这个缘故

100
00:03:11,598 --> 00:03:15,258
unix shell就会提供一些简单的用来读写文本的

101
00:03:15,258 --> 00:03:16,429
小的小程序

102
00:03:16,429 --> 00:03:18,899
这些小程序呢随着linux一起出来

103
00:03:18,899 --> 00:03:20,599
大家用起来就觉得很方便

104
00:03:20,599 --> 00:03:21,139
所以呢

105
00:03:21,139 --> 00:03:24,139
很多unique上面软件也接受这种方式

106
00:03:24,139 --> 00:03:25,639
用文本来做数据存储

107
00:03:25,639 --> 00:03:27,159
用文本来做配置

108
00:03:29,139 --> 00:03:32,879
windows是一个完全不同的文化背景

109
00:03:33,259 --> 00:03:36,199
呃当然我们更准确的要说dos啊

110
00:03:36,199 --> 00:03:39,000
在微软刚开始出来做dos的那个年代

111
00:03:40,539 --> 00:03:43,020
大家去回顾一下那个时候的历史啊

112
00:03:43,020 --> 00:03:44,639
计算机的历史在70年代末

113
00:03:44,639 --> 00:03:46,819
80年代初的时候

114
00:03:47,000 --> 00:03:51,680
个人计算机它是一种突破围墙的东西

115
00:03:53,819 --> 00:03:56,099
做个人计算机的很多人

116
00:03:56,099 --> 00:03:57,300
他们是hobby

117
00:03:57,300 --> 00:03:58,180
是amateur

118
00:03:58,180 --> 00:03:59,800
他们不是professional

119
00:03:59,800 --> 00:04:02,979
他们并不知道在围墙里面的那些计算机

120
00:04:02,979 --> 00:04:04,590
那些unix是怎么工作的

121
00:04:04,590 --> 00:04:07,740
他们以自己对这个计算机硬件的理解

122
00:04:07,740 --> 00:04:10,479
来决定这个计算机的软件该怎么做

123
00:04:10,659 --> 00:04:14,240
所以这完全是草根文化和unix是不同的

124
00:04:15,778 --> 00:04:17,358
做这个这些事情的人

125
00:04:17,358 --> 00:04:18,560
他不熟悉unix

126
00:04:18,579 --> 00:04:20,858
那pc刚开始的时候能力很有限

127
00:04:20,858 --> 00:04:23,348
dos这种操作系统它的能力更加有限

128
00:04:23,348 --> 00:04:26,839
而用二进制的方式来做这些输入输出

129
00:04:26,839 --> 00:04:28,189
它更接近底层

130
00:04:28,189 --> 00:04:30,620
文本和二进制孰优孰劣呢

131
00:04:30,978 --> 00:04:32,658
各有千秋

132
00:04:32,658 --> 00:04:35,689
文本的优势是方便人类读写

133
00:04:35,689 --> 00:04:37,319
而且呢它跨平台

134
00:04:37,420 --> 00:04:40,000
因为不管什么样的平台呃

135
00:04:40,000 --> 00:04:42,610
文本文字拿出来人都能看懂

136
00:04:42,610 --> 00:04:45,259
那么和平台就会没有关系

137
00:04:45,620 --> 00:04:48,199
二呃文本的缺点呢是

138
00:04:48,199 --> 00:04:50,990
我的程序的输入输出要经过格式化

139
00:04:50,990 --> 00:04:54,519
这个skin f和pinf其实是有一定的开销的

140
00:04:54,519 --> 00:04:56,439
他原本在计算机内部

141
00:04:56,439 --> 00:04:57,100
12345

142
00:04:57,100 --> 00:04:58,449
它是四个字节的整数

143
00:04:58,449 --> 00:05:00,939
要把它变成人可以读懂的

144
00:05:00,939 --> 00:05:02,779
12345这样一个字符串

145
00:05:02,779 --> 00:05:05,420
这个运算需要花时间的

146
00:05:05,680 --> 00:05:07,029
同样输入的时候

147
00:05:07,029 --> 00:05:08,379
12345的字符串

148
00:05:08,379 --> 00:05:10,779
要变成计算机能够懂的12345

149
00:05:10,779 --> 00:05:12,310
那么一个二进制的数

150
00:05:12,310 --> 00:05:13,600
这个计算也是要花时间的

151
00:05:13,600 --> 00:05:14,740
所以开销比较大

152
00:05:15,920 --> 00:05:18,759
二进制的特点杠跟他相反啊

153
00:05:18,759 --> 00:05:21,220
它的缺点是人类阅读困难对吧

154
00:05:21,220 --> 00:05:22,980
你不可能直接去呃

155
00:05:22,980 --> 00:05:23,339
键盘上

156
00:05:23,339 --> 00:05:26,040
悄悄就把一个二进制的文件给他做出来了

157
00:05:28,180 --> 00:05:30,790
我们之前让大家做过这样的事情

158
00:05:30,790 --> 00:05:33,720
我们知道int long这样的类型

159
00:05:33,720 --> 00:05:35,579
在不同的平台上面都不一样

160
00:05:35,579 --> 00:05:36,600
有的地方四个字节

161
00:05:36,600 --> 00:05:37,829
有的地方八个字节

162
00:05:37,829 --> 00:05:39,779
还有呢大小端的问题

163
00:05:39,800 --> 00:05:43,009
所以你在一个计算机上

164
00:05:43,009 --> 00:05:45,379
用二进制方式写下来的数据文件

165
00:05:45,379 --> 00:05:46,699
到另外一台计算机上

166
00:05:46,699 --> 00:05:47,779
你不一定能读出来

167
00:05:47,779 --> 00:05:49,000
不一定能读正确

168
00:05:50,160 --> 00:05:51,920
但是二进制的好处是什么呢

169
00:05:51,920 --> 00:05:53,600
输入输出是直接的

170
00:05:53,600 --> 00:05:55,699
我在内存里面是四个字节的

171
00:05:55,699 --> 00:05:56,709
那么一个整数

172
00:05:56,709 --> 00:05:58,569
我写到二进制的文件里头去

173
00:05:58,569 --> 00:06:01,269
就是把这四个字节原封不动地写进去

174
00:06:01,269 --> 00:06:03,009
那么当然在这个写的过程当中

175
00:06:03,009 --> 00:06:05,470
不需要做任何的复杂的计算

176
00:06:05,470 --> 00:06:06,670
读的时候也是一样

177
00:06:06,670 --> 00:06:08,610
这四个字节我原封不动的读出来

178
00:06:08,610 --> 00:06:11,139
也不需要做很复杂的运算

179
00:06:11,860 --> 00:06:13,649
所以他们各有优缺点

180
00:06:13,649 --> 00:06:14,279
讲到这儿

181
00:06:14,279 --> 00:06:15,839
我们必须要来回顾一下

182
00:06:16,459 --> 00:06:18,079
我们写一个程序

183
00:06:18,079 --> 00:06:21,529
为什么那个程序要操作文件呢

184
00:06:21,529 --> 00:06:24,079
一般来说只有三种

185
00:06:24,259 --> 00:06:26,810
第一种呢这程序有个配置

186
00:06:26,810 --> 00:06:30,240
比如说呃窗口应该多大啊

187
00:06:30,500 --> 00:06:33,079
字体什么颜色啊等等

188
00:06:33,079 --> 00:06:34,839
那么它有些配置信息

189
00:06:34,978 --> 00:06:36,629
那这个配置数据

190
00:06:36,629 --> 00:06:39,178
unix的传统就是一个文本文件

191
00:06:39,178 --> 00:06:42,529
你直接用一个vi你就可以去编辑它了

192
00:06:42,529 --> 00:06:47,240
而windows的传统这些配置数据写在注册表里

193
00:06:47,399 --> 00:06:49,889
注册表是一个非常大的二进制文件

194
00:06:49,889 --> 00:06:53,730
整个windows里头所有软件的配置信息

195
00:06:53,730 --> 00:06:55,839
全部写在了一个大文件里头

196
00:06:56,079 --> 00:06:59,079
你需要有一个专门的这个工具

197
00:06:59,079 --> 00:07:01,779
比如说呃以前有那个i e g e d i t是吧

198
00:07:01,779 --> 00:07:04,990
range这个注册表编辑器才能够去编辑它

199
00:07:04,990 --> 00:07:05,800
没有那个东西

200
00:07:05,800 --> 00:07:07,480
你就你就处理不了它

201
00:07:07,779 --> 00:07:09,399
这是一种配置

202
00:07:09,399 --> 00:07:14,319
第二种呢数据我的程序要有些数据保存

203
00:07:14,319 --> 00:07:18,459
比如说呃我读了这个学生的成绩进来

204
00:07:18,459 --> 00:07:19,759
我要把它保存下来

205
00:07:20,098 --> 00:07:22,738
但是呢数据这件事情现在是这样的

206
00:07:22,738 --> 00:07:24,478
稍微大一点的数据

207
00:07:24,478 --> 00:07:26,249
比如我刚才说的多的学生成绩

208
00:07:26,249 --> 00:07:28,040
那我现在就用数据库了

209
00:07:28,319 --> 00:07:31,560
数据库用起来很方便啊

210
00:07:31,560 --> 00:07:33,538
你有数据库的接口库

211
00:07:33,538 --> 00:07:35,249
你写几个函数调用

212
00:07:35,249 --> 00:07:38,098
你就可以把数据从这个多进来的地方

213
00:07:38,098 --> 00:07:38,999
写到数据库里去了

214
00:07:38,999 --> 00:07:40,829
或者从数据库里面把数据给读出来

215
00:07:40,829 --> 00:07:42,339
这件事情现在很容易了

216
00:07:42,598 --> 00:07:44,098
还有呢就是媒体

217
00:07:44,098 --> 00:07:45,238
比如说图片啊

218
00:07:45,238 --> 00:07:45,988
声音啊

219
00:07:45,988 --> 00:07:47,038
视频啊

220
00:07:47,038 --> 00:07:49,060
那这些肯定是二进制的

221
00:07:50,360 --> 00:07:53,439
你不可能指望说我一个图片是文本的啊

222
00:07:53,439 --> 00:07:55,660
然后这个文本里面根据文本的描述

223
00:07:55,660 --> 00:07:57,009
再去把那个图片给画出来

224
00:07:57,009 --> 00:07:58,180
没人这么做

225
00:07:58,598 --> 00:08:01,059
但是这种二进制的媒体文件

226
00:08:01,059 --> 00:08:03,899
你怎么去打开它来读呢

227
00:08:05,319 --> 00:08:07,620
其实现在没人在

228
00:08:07,620 --> 00:08:09,779
直接用最底层的那种方式说

229
00:08:09,779 --> 00:08:11,410
我打开一个二进制文件

230
00:08:11,410 --> 00:08:13,750
我取出里面的一个个字节啊

231
00:08:13,750 --> 00:08:15,279
然后怎么去给他呃

232
00:08:15,279 --> 00:08:16,209
去做计算

233
00:08:16,209 --> 00:08:17,290
然后把这个图片给画成

234
00:08:17,290 --> 00:08:18,379
没人做这个事情了

235
00:08:18,500 --> 00:08:19,970
都是用第三方库

236
00:08:19,970 --> 00:08:21,350
有现成写好的

237
00:08:21,350 --> 00:08:22,610
你调一个函数

238
00:08:22,610 --> 00:08:24,300
它帮你把那个图片

239
00:08:24,379 --> 00:08:27,019
所有的数据装载到内存里头来

240
00:08:27,019 --> 00:08:28,160
接下去你要做的事情

241
00:08:28,160 --> 00:08:29,660
无非是把那个图片拿去

242
00:08:29,660 --> 00:08:31,339
放在某个地方显示出来而已

243
00:08:31,759 --> 00:08:35,328
你不会再要有机会去做那么底层的事情

244
00:08:35,328 --> 00:08:37,999
那么如果你一定要去做

245
00:08:37,999 --> 00:08:40,339
那么底层的事情啊要怎么做呢

246
00:08:40,620 --> 00:08:42,298
其他事情都不用动

247
00:08:43,000 --> 00:08:46,320
唯一要做的就是原来我们用caf和print f

248
00:08:46,320 --> 00:08:49,610
用f k f和f print f来做文件的多核写的

249
00:08:49,610 --> 00:08:51,950
因为那是对文本文件的输入输出

250
00:08:51,950 --> 00:08:53,509
格式化输入输出

251
00:08:53,509 --> 00:08:55,549
那现在呢对二进制的数据

252
00:08:55,549 --> 00:08:56,990
我们用另外一对函数

253
00:08:56,990 --> 00:09:02,799
就是f和f right f的函数用来读入一些东西

254
00:09:02,799 --> 00:09:04,539
fy的函数用来写一些东西

255
00:09:04,539 --> 00:09:06,970
他们都是直接的裸数据

256
00:09:06,970 --> 00:09:08,389
也就是二进制的方式

257
00:09:08,389 --> 00:09:11,230
这两个函数的参数表基本上是一样的

258
00:09:11,230 --> 00:09:13,059
第一个参数呢是那个指针

259
00:09:13,059 --> 00:09:15,740
就是你要读或者写的那块内存

260
00:09:15,740 --> 00:09:18,049
第二个参数呢是这块内存有多大

261
00:09:18,049 --> 00:09:21,559
第三个参数呢是有几个这样的内存

262
00:09:21,559 --> 00:09:24,698
然后最后那个参数才是文件指针

263
00:09:24,980 --> 00:09:26,600
所以最后是中间

264
00:09:26,600 --> 00:09:29,750
然后它返回的是成功读写了多少个字节

265
00:09:29,750 --> 00:09:32,360
那么为什么这里会有有一个size

266
00:09:32,360 --> 00:09:34,360
还有一个n items呢

267
00:09:34,360 --> 00:09:36,159
因为一般来说呢

268
00:09:36,159 --> 00:09:38,220
我们对二进制文件的读写啊

269
00:09:38,220 --> 00:09:41,460
是通过对一个结构变量的操作来进行的

270
00:09:41,460 --> 00:09:43,919
我要写的数据在一个结构里头

271
00:09:43,919 --> 00:09:47,200
然后呢我一次写一个或者多个结构进去

272
00:09:47,200 --> 00:09:48,958
所以那个size

273
00:09:49,039 --> 00:09:51,559
这个size其实指的是一个结构的大小

274
00:09:51,559 --> 00:09:51,980
然后呢

275
00:09:51,980 --> 00:09:53,059
这个n items呢

276
00:09:53,059 --> 00:09:55,669
指的是说我这一次要读写多少个

277
00:09:55,669 --> 00:09:56,600
这样的结构

278
00:09:56,600 --> 00:09:58,240
我们来看一个这样的例子

279
00:09:58,240 --> 00:10:01,109
我们在student的点h里面的啊

280
00:10:01,109 --> 00:10:04,198
是这个声明了一个结构类型啊

281
00:10:04,198 --> 00:10:05,099
叫student

282
00:10:05,099 --> 00:10:08,000
它里面呢有一个字符数组

283
00:10:08,000 --> 00:10:09,379
它的大小呢是20

284
00:10:09,379 --> 00:10:11,750
这个s t r l e n呢是20

285
00:10:11,750 --> 00:10:12,919
然后有一个gender

286
00:10:12,919 --> 00:10:13,759
有个age啊

287
00:10:13,759 --> 00:10:14,840
有性别和年龄

288
00:10:14,840 --> 00:10:15,889
这是两个int

289
00:10:15,889 --> 00:10:18,139
这样我们定义了这样一个结构

290
00:10:18,139 --> 00:10:21,809
那么在这个may里面呢

291
00:10:21,809 --> 00:10:24,419
我们先让用户输入有多少个学生啊

292
00:10:24,419 --> 00:10:25,259
他输入个number

293
00:10:25,259 --> 00:10:25,799
然后呢

294
00:10:25,799 --> 00:10:28,419
我们就建了一个这个结构的一个数组

295
00:10:28,419 --> 00:10:29,860
所以在这个数组里头

296
00:10:29,860 --> 00:10:31,539
每一个单元都是那个结构

297
00:10:31,539 --> 00:10:32,710
那个结构里面有name

298
00:10:32,710 --> 00:10:33,700
有gender

299
00:10:33,700 --> 00:10:34,509
有age

300
00:10:34,509 --> 00:10:37,360
然后我们调用那个get list函数

301
00:10:37,360 --> 00:10:38,320
get list函数

302
00:10:38,320 --> 00:10:40,389
在这儿他得到了这个数组

303
00:10:40,389 --> 00:10:41,938
它得到了这个number

304
00:10:41,940 --> 00:10:47,190
然后呢我们呢做了一个循环遍历整个数组

305
00:10:47,190 --> 00:10:49,169
要输入姓名

306
00:10:49,169 --> 00:10:50,759
性别和年龄啊

307
00:10:50,759 --> 00:10:52,590
那输入姓名的时候呢

308
00:10:52,590 --> 00:10:56,909
因为我们要输入的是一个这个字符串对吧

309
00:10:56,909 --> 00:10:59,429
因此呢我们这儿呢又用了一个小技巧

310
00:10:59,429 --> 00:11:02,490
我们出现了之前没讲过的s print f

311
00:11:02,490 --> 00:11:03,990
我们用过print f

312
00:11:03,990 --> 00:11:05,789
这是直接向标准输出输出

313
00:11:05,789 --> 00:11:07,289
我们用过f print f

314
00:11:07,289 --> 00:11:08,940
这是向文件输出

315
00:11:08,940 --> 00:11:12,318
print f呢是像一个字符串输出

316
00:11:12,559 --> 00:11:14,419
我们做了一个字符数组

317
00:11:14,419 --> 00:11:17,720
这个字符数组呢大小呢是那个20啊

318
00:11:17,720 --> 00:11:21,159
然后呢我们往这个字符数组里面输出东西

319
00:11:21,240 --> 00:11:22,620
这是它的格式

320
00:11:22,620 --> 00:11:23,460
所以你把s拿掉

321
00:11:23,460 --> 00:11:24,419
这是print f对吧

322
00:11:24,419 --> 00:11:25,440
所以这是它的格式

323
00:11:25,440 --> 00:11:28,500
百分号百分号表示说我要输出个百分号

324
00:11:29,320 --> 00:11:30,929
s是要输出的那个字

325
00:11:30,929 --> 00:11:34,099
而百分号d呢是后面的这个值

326
00:11:34,340 --> 00:11:37,159
所以我们这个东西是用来干什么的

327
00:11:37,159 --> 00:11:38,899
他最后做出来的是给了我们这样

328
00:11:38,899 --> 00:11:39,440
一个字符串

329
00:11:39,440 --> 00:11:42,840
叫做百分号19s

330
00:11:44,340 --> 00:11:45,379
这个东西

331
00:11:45,559 --> 00:11:49,370
就是将来用来在这里scaf的时候呢

332
00:11:49,370 --> 00:11:54,219
其实它你如果把这个format看成是百分号

333
00:11:54,240 --> 00:11:55,500
19s

334
00:11:55,500 --> 00:11:58,259
那这就是一个普通的scaf啊

335
00:11:58,259 --> 00:12:00,198
所以我们是以这个方式呢

336
00:12:00,279 --> 00:12:03,960
让他给我们产生一个格式字符串啊

337
00:12:03,960 --> 00:12:05,309
这产生一个格式作战

338
00:12:05,309 --> 00:12:07,440
那么所以我们先说说说这是第几个学生

339
00:12:07,440 --> 00:12:09,330
然后要求用户的输入他的名字

340
00:12:09,330 --> 00:12:10,409
他的性别

341
00:12:10,409 --> 00:12:11,899
然后呢他的年龄

342
00:12:12,200 --> 00:12:14,179
这样呢这个get list做完

343
00:12:14,179 --> 00:12:16,039
我们就得到了一个数组

344
00:12:16,039 --> 00:12:19,828
这个数组里面呢有number个学生的数据

345
00:12:19,828 --> 00:12:21,089
那么回到may呢

346
00:12:21,089 --> 00:12:23,129
我们就调用了save函数啊

347
00:12:23,129 --> 00:12:23,908
如果save成功

348
00:12:23,908 --> 00:12:24,749
我们就会保存成功

349
00:12:24,749 --> 00:12:25,929
否则是保存失败

350
00:12:25,929 --> 00:12:27,940
save做的事情呢是这样

351
00:12:27,940 --> 00:12:29,889
我们打开了那个文件

352
00:12:29,889 --> 00:12:31,740
叫做student.data

353
00:12:31,740 --> 00:12:33,389
然后呢我们说我们要w

354
00:12:33,389 --> 00:12:35,039
所以我们要写那个文件

355
00:12:35,039 --> 00:12:36,149
如果打开成功

356
00:12:36,149 --> 00:12:37,740
我们就用f right

357
00:12:37,740 --> 00:12:40,799
把这个a s t u这个数组写进去

358
00:12:40,799 --> 00:12:41,820
写多少呢

359
00:12:41,820 --> 00:12:45,519
size of student一共有number个

360
00:12:45,519 --> 00:12:48,309
每个是size of student的那么大

361
00:12:48,309 --> 00:12:49,360
然后写到哪儿呢

362
00:12:49,360 --> 00:12:50,620
写到fp里面去

363
00:12:50,620 --> 00:12:52,809
写完之后我们就把它关掉了

364
00:12:52,809 --> 00:12:58,570
然后如果fi返回的结果是number个东西的话

365
00:12:58,570 --> 00:13:02,679
ok那就说明我们写进去的东西是对的好

366
00:13:02,679 --> 00:13:04,929
那它就会返回一

367
00:13:04,929 --> 00:13:07,080
否则的话会返回零

368
00:13:07,080 --> 00:13:08,159
对吧啊

369
00:13:08,159 --> 00:13:09,000
会返回零

370
00:13:09,000 --> 00:13:11,389
返回零呢我们就说哦保存失败啊

371
00:13:11,389 --> 00:13:12,350
否则就保存成功

372
00:13:12,350 --> 00:13:13,789
我们来试一下这个程序啊

373
00:13:13,789 --> 00:13:15,289
我们把它编译一下

374
00:13:15,289 --> 00:13:16,279
叫做query

375
00:13:17,840 --> 00:13:19,360
我们来执行这个query

376
00:13:19,360 --> 00:13:20,440
我们要俩学生啊

377
00:13:20,440 --> 00:13:21,100
稍微简单点

378
00:13:21,100 --> 00:13:25,759
第一个叫做张这个性别男年龄22

379
00:13:25,759 --> 00:13:29,659
第二个呢叫做理性别女年龄23啊

380
00:13:29,659 --> 00:13:30,740
24啊

381
00:13:31,299 --> 00:13:32,309
保存成功

382
00:13:32,309 --> 00:13:33,938
那我们得到什么呢

383
00:13:34,399 --> 00:13:37,460
我们看一下student.data呢

384
00:13:37,460 --> 00:13:41,580
现在是一个56个字节的文件啊

385
00:13:41,580 --> 00:13:43,440
如果我们用文本的方式说

386
00:13:43,440 --> 00:13:45,099
我们要摸一下这个data

387
00:13:45,320 --> 00:13:48,200
他会告诉你这可能是个binary文件

388
00:13:48,200 --> 00:13:49,039
要不要看呢

389
00:13:49,039 --> 00:13:49,220
算了

390
00:13:49,220 --> 00:13:50,000
我们别看了啊

391
00:13:50,000 --> 00:13:53,120
二进制文件直接用魔法是没法看的呃

392
00:13:53,120 --> 00:13:56,539
unix有个工具叫做o d o d可以用来看一下

393
00:13:56,539 --> 00:13:57,980
不过呢这个看起来呢

394
00:13:57,980 --> 00:14:00,379
其实大家看的还是啥也看不明白哈

395
00:14:00,379 --> 00:14:02,210
我们找一个图形工具来看这个东西

396
00:14:02,210 --> 00:14:04,899
我们现在看到的这个呃图形工具

397
00:14:04,899 --> 00:14:06,519
打开了这个二进制文件以后啊

398
00:14:06,519 --> 00:14:08,129
给我们看到的结果是这样的哈

399
00:14:08,129 --> 00:14:09,750
这边呢是二进制数据

400
00:14:09,750 --> 00:14:12,240
这边呢是他试图把这些二进制数据啊

401
00:14:12,240 --> 00:14:13,049
变成字符串

402
00:14:13,049 --> 00:14:17,620
让我们看到我们看到了这个四个字节是吧

403
00:14:17,620 --> 00:14:20,679
12345678 90 11 12

404
00:14:20,679 --> 00:14:23,279
一直到这里

405
00:14:23,279 --> 00:14:25,440
20个字节应该是我们那个name

406
00:14:25,440 --> 00:14:27,000
那个字符数组对吧

407
00:14:27,000 --> 00:14:28,679
后面有点东西乱七八糟的

408
00:14:28,679 --> 00:14:29,340
其实没关系

409
00:14:29,340 --> 00:14:31,568
因为这个零这里的这个零

410
00:14:31,568 --> 00:14:34,389
这是那个张满z h a n g是吧

411
00:14:34,389 --> 00:14:36,548
这个零呢已经表明这个字符串结束了

412
00:14:36,548 --> 00:14:38,899
后面只不过他没有帮我们去填零而已

413
00:14:38,899 --> 00:14:41,299
然后呢这个呢是它的这是零

414
00:14:41,299 --> 00:14:42,879
这是他的gender是零

415
00:14:42,879 --> 00:14:44,710
这个呢是它的age

416
00:14:44,710 --> 00:14:47,200
这是16进制的16就是16+6

417
00:14:47,200 --> 00:14:48,940
就是22啊

418
00:14:48,940 --> 00:14:49,980
所以他22岁

419
00:14:49,980 --> 00:14:51,659
然后这是下一个人了

420
00:14:51,659 --> 00:14:53,759
这是李啊

421
00:14:53,759 --> 00:14:57,029
然后这是20个字节的礼

422
00:14:57,029 --> 00:15:01,230
那么他的这个卷der呢是一

423
00:15:01,230 --> 00:15:03,309
这是00001

424
00:15:03,309 --> 00:15:04,690
这是他的年龄

425
00:15:04,690 --> 00:15:07,330
16进制的18就是16+8

426
00:15:07,330 --> 00:15:08,769
他是24岁

427
00:15:08,769 --> 00:15:11,340
所以fright

428
00:15:11,340 --> 00:15:13,679
可以把数据以二进制的方式

429
00:15:13,679 --> 00:15:15,078
写到文件里头去

430
00:15:15,759 --> 00:15:17,220
那么对应的读出来

431
00:15:17,220 --> 00:15:18,179
用f6 的

432
00:15:19,120 --> 00:15:21,059
除了驴的right之外呢

433
00:15:21,059 --> 00:15:22,320
在这种文件当中

434
00:15:22,320 --> 00:15:23,519
我们还可以做定位

435
00:15:24,019 --> 00:15:24,980
所谓定位

436
00:15:24,980 --> 00:15:25,340
就是

437
00:15:25,340 --> 00:15:29,759
我可以知道我现在处在文件的什么位置上

438
00:15:29,759 --> 00:15:33,779
我也可以直接让我跑到文件的某个地方去

439
00:15:35,320 --> 00:15:37,200
所以我们就接着刚才那个程序

440
00:15:37,200 --> 00:15:39,859
如果我已经把student.data的写好了

441
00:15:40,299 --> 00:15:42,220
我要怎么能够把这个student等

442
00:15:42,220 --> 00:15:43,960
data里面的数据给读出来呢

443
00:15:43,960 --> 00:15:45,719
我们做了这样一个程序

444
00:15:46,240 --> 00:15:49,000
我们去打开了这个student.data文件

445
00:15:49,000 --> 00:15:50,080
刚才是w的

446
00:15:50,080 --> 00:15:51,100
现在我们是r的

447
00:15:51,100 --> 00:15:53,039
我们要打开来读啊

448
00:15:53,080 --> 00:15:54,759
然后如果打开成功的话

449
00:15:54,759 --> 00:16:00,480
我们先f seek到seek的e n d

450
00:16:00,480 --> 00:16:05,919
f seek呢是说我要把我这个读写的位置啊

451
00:16:05,919 --> 00:16:07,360
移到什么地方去

452
00:16:07,360 --> 00:16:08,379
seek e n d呢

453
00:16:08,379 --> 00:16:11,919
表示说从尾巴上开始往前倒过来算

454
00:16:11,919 --> 00:16:13,230
倒过来算零

455
00:16:13,230 --> 00:16:15,210
所以这句话做完以后呢

456
00:16:15,210 --> 00:16:18,559
我的位置当前的位置就在尾巴上了

457
00:16:18,559 --> 00:16:20,570
然后我用f tale

458
00:16:20,570 --> 00:16:23,539
来得到现在所在的那个位置

459
00:16:24,519 --> 00:16:27,779
也就是说我移到最尾巴上

460
00:16:27,779 --> 00:16:31,529
我得到的那个位置其实表达的是什么

461
00:16:31,529 --> 00:16:34,279
表达的就是这个文件的大小

462
00:16:34,279 --> 00:16:38,958
然后我用这个size去除以student the size of

463
00:16:39,120 --> 00:16:40,980
结果我就可以得到说

464
00:16:40,980 --> 00:16:45,078
现在在我这个文件里面有几个这样的结构

465
00:16:45,519 --> 00:16:47,500
其实于是呢我就输出说啊

466
00:16:47,500 --> 00:16:49,539
有几个数据你要看第几个

467
00:16:49,539 --> 00:16:51,759
那读进来一个index

468
00:16:51,840 --> 00:16:53,519
我把这个index减一

469
00:16:53,519 --> 00:16:56,820
因为人人类嘛会说我要看第一个

470
00:16:56,820 --> 00:16:57,480
我要看第二个

471
00:16:57,480 --> 00:16:58,980
我不会说我要看第零个的

472
00:16:58,980 --> 00:16:59,519
对不对

473
00:16:59,519 --> 00:17:01,779
把index减一交给鲁豫的函数

474
00:17:01,980 --> 00:17:05,519
铝的函数呢拿到了这个文件的指针是吧

475
00:17:05,519 --> 00:17:06,690
拿到了这个index

476
00:17:06,690 --> 00:17:09,750
那么就从这个success

477
00:17:09,750 --> 00:17:12,159
也就是这个文件的头开始

478
00:17:12,619 --> 00:17:14,420
往前走到一个什么位置呢

479
00:17:14,420 --> 00:17:16,609
index乘以size of student

480
00:17:16,609 --> 00:17:18,799
所以零的话那就是零对一的话呢

481
00:17:18,799 --> 00:17:21,608
就是一个student size的那个位置上去

482
00:17:21,608 --> 00:17:23,769
到了那个位置上以后呢

483
00:17:23,769 --> 00:17:25,680
去把它给读出来

484
00:17:26,079 --> 00:17:29,380
我读一个size of student

485
00:17:29,380 --> 00:17:31,180
我读一个student的结构

486
00:17:31,180 --> 00:17:32,059
读出来

487
00:17:32,140 --> 00:17:34,509
然后呢把里面的东西name

488
00:17:34,509 --> 00:17:37,480
真的年龄都输出出来

489
00:17:37,480 --> 00:17:37,839
给我们

490
00:17:37,839 --> 00:17:39,910
看来我们来试一下这个程序

491
00:17:39,910 --> 00:17:41,720
我们把这个叫做read

492
00:17:45,640 --> 00:17:47,099
他说有两个数据

493
00:17:47,099 --> 00:17:47,940
你要看第几个

494
00:17:47,940 --> 00:17:49,619
那我们先看第一个

495
00:17:49,740 --> 00:17:52,049
第一个是张男22岁

496
00:17:52,049 --> 00:17:53,039
我们再来一遍

497
00:17:53,039 --> 00:17:54,180
有两个我们看第二个

498
00:17:57,160 --> 00:17:59,859
嗯大量的这种程序

499
00:17:59,859 --> 00:18:01,759
都是以这种方式写出来的啊

500
00:18:02,200 --> 00:18:03,519
写一个c的程序

501
00:18:03,519 --> 00:18:04,569
定义一个结构体

502
00:18:04,569 --> 00:18:08,430
然后呢这个fl写到数据文件里面去

503
00:18:08,430 --> 00:18:10,529
用f seek在里面跳来跳去

504
00:18:10,529 --> 00:18:14,839
找第几个f6 的给它读出来这样的程序

505
00:18:14,839 --> 00:18:17,059
这种写出来的二进制文件

506
00:18:17,059 --> 00:18:18,898
它不具有可移植性

507
00:18:19,420 --> 00:18:23,049
在比如说在int是32位的机器上啊

508
00:18:23,049 --> 00:18:24,279
写的这个数据文件

509
00:18:24,279 --> 00:18:25,240
你就没有办法

510
00:18:25,240 --> 00:18:27,279
直接在int为64位的机器上去

511
00:18:27,279 --> 00:18:28,378
正确的读出来

512
00:18:28,460 --> 00:18:30,109
你写了一个int

513
00:18:30,109 --> 00:18:31,759
你写进去四个字节

514
00:18:31,759 --> 00:18:33,490
到了那边读的时候

515
00:18:33,490 --> 00:18:35,710
他一读就把你两个int

516
00:18:35,710 --> 00:18:37,329
八个字节的东西都读进来了

517
00:18:37,329 --> 00:18:38,650
然后当做是一个int

518
00:18:41,380 --> 00:18:42,930
要解决这个可移植性

519
00:18:42,930 --> 00:18:45,419
那方案之一就是你放弃用int

520
00:18:45,619 --> 00:18:47,000
你不要用int

521
00:18:47,000 --> 00:18:48,289
因为int是变化的

522
00:18:48,289 --> 00:18:50,660
你用typedef去定义出

523
00:18:50,660 --> 00:18:52,779
比如说就是四个字节的那么一个整数

524
00:18:52,880 --> 00:18:54,680
你保证在所有的平台上面

525
00:18:54,680 --> 00:18:57,950
你要重新type def一个不同的展示出来

526
00:18:57,950 --> 00:18:59,200
这是一个方案

527
00:18:59,380 --> 00:19:00,819
当然这是另外一个方案

528
00:19:00,819 --> 00:19:02,680
我们看到现在在互联网上

529
00:19:02,680 --> 00:19:06,130
我们为了解决这些不同的机器之间的

530
00:19:06,130 --> 00:19:07,539
这种整数的不同啊

531
00:19:07,539 --> 00:19:08,609
大小端的不同啊

532
00:19:08,609 --> 00:19:10,769
我们宁愿放弃它的速度

533
00:19:10,769 --> 00:19:12,138
而是用文本

534
00:19:12,819 --> 00:19:15,279
文本就可以解决跨平台移植的问题

535
00:19:19,279 --> 00:19:21,519
我还是前面说的那个观点

536
00:19:21,519 --> 00:19:22,869
时至今日

537
00:19:22,869 --> 00:19:25,849
人们已经很少直接用c语言的

538
00:19:25,849 --> 00:19:28,490
这种最底层的文件读写

539
00:19:28,490 --> 00:19:30,980
数据读写的方式来操作数据了

540
00:19:30,980 --> 00:19:31,940
要么数据库

541
00:19:31,940 --> 00:19:33,619
要么专门的第三方库

