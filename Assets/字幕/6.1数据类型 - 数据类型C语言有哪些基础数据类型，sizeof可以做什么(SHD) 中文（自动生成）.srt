1
00:00:04,700 --> 00:00:07,599
c语言是一种有类型的语言

2
00:00:07,919 --> 00:00:09,990
所以有类型的原理意思是什么呢

3
00:00:09,990 --> 00:00:11,990
我们c语言程序里面的变量啊

4
00:00:11,990 --> 00:00:14,300
必须首先要在使用前定义

5
00:00:14,300 --> 00:00:16,190
而且还需要确定类型

6
00:00:16,190 --> 00:00:18,170
你看对于这样一个程序

7
00:00:18,170 --> 00:00:20,780
如果我们一上来就说a等于六

8
00:00:20,939 --> 00:00:22,469
那我们编译的时候

9
00:00:22,469 --> 00:00:26,998
他会说错误使用了未定义的标识符

10
00:00:26,998 --> 00:00:29,079
a这个a等于六

11
00:00:29,500 --> 00:00:30,640
你没有在

12
00:00:31,780 --> 00:00:34,000
你没你在使用这个a这个变量之前

13
00:00:34,000 --> 00:00:35,320
没有去定义过它

14
00:00:35,320 --> 00:00:36,399
在c语言来说

15
00:00:36,399 --> 00:00:37,329
这是一种错误

16
00:00:37,329 --> 00:00:38,950
我们要去定义它的时候

17
00:00:38,950 --> 00:00:40,689
不仅要说a是一个变量

18
00:00:40,689 --> 00:00:44,198
我们还要说a是一个int类型的变量

19
00:00:44,259 --> 00:00:46,719
我们之前至少学过两种类型

20
00:00:46,719 --> 00:00:50,259
int和double这两种类型它们是不一样的

21
00:00:50,479 --> 00:00:53,509
一个是只能表示完整的数

22
00:00:53,509 --> 00:00:54,619
不带小数点的

23
00:00:54,619 --> 00:00:57,000
一个是可以表示带小数点的数

24
00:00:57,000 --> 00:00:58,979
所以c语言就是这样一种语言啊

25
00:00:58,979 --> 00:01:00,359
这种语言的程序里面的变量

26
00:01:00,359 --> 00:01:01,820
是需要预先定义的

27
00:01:02,500 --> 00:01:04,319
在c语言以后呢

28
00:01:04,319 --> 00:01:07,200
呃编程语言向两个方向去发展一个方向

29
00:01:07,200 --> 00:01:08,489
我们看到像c加加

30
00:01:08,489 --> 00:01:10,019
像java这样的语言

31
00:01:10,019 --> 00:01:11,780
它更加强调类型

32
00:01:11,780 --> 00:01:15,140
他对类型的检查比c语言还要严格啊

33
00:01:15,140 --> 00:01:17,900
c语言有的时候允许你在不同的类型之间

34
00:01:17,900 --> 00:01:21,469
使用一些这个过渡的事情啊

35
00:01:21,469 --> 00:01:23,299
在不同的类型之间使用一些

36
00:01:23,299 --> 00:01:24,439
自动转换的事情

37
00:01:24,439 --> 00:01:26,120
但是呢c加加和jav呢

38
00:01:26,120 --> 00:01:28,200
在这件事情上面的检查会更严格

39
00:01:28,540 --> 00:01:30,370
而另外一个方向

40
00:01:30,370 --> 00:01:32,290
我们看到有些语言是javascript

41
00:01:32,290 --> 00:01:33,760
像python

42
00:01:33,760 --> 00:01:35,200
像ph这样的语言

43
00:01:35,200 --> 00:01:36,618
它不看这种类型

44
00:01:36,620 --> 00:01:39,620
它甚至可以不需要你事先定义变量

45
00:01:39,620 --> 00:01:40,340
你要用变量了

46
00:01:40,340 --> 00:01:41,399
你就直接用

47
00:01:41,480 --> 00:01:46,340
你也不需要去说我这个变量是int还是double int

48
00:01:46,340 --> 00:01:47,120
对于c语言来说

49
00:01:47,120 --> 00:01:47,900
我们后面马上会学

50
00:01:47,900 --> 00:01:49,789
到时候我们还有各种各样不同的int

51
00:01:49,789 --> 00:01:51,709
那么对于像python这样的语言

52
00:01:51,709 --> 00:01:52,789
它也不区分数字

53
00:01:52,789 --> 00:01:54,168
就是数字p h b也是这样

54
00:01:54,168 --> 00:01:55,280
数字就是数字

55
00:01:55,519 --> 00:01:58,040
他不去区分什么样的数字

56
00:01:58,040 --> 00:01:59,540
更加不会去区分这个整数

57
00:01:59,540 --> 00:02:01,140
还有各种大小的整数

58
00:02:02,079 --> 00:02:03,780
这是两个方向啊

59
00:02:03,780 --> 00:02:05,849
编程语言向这两个方向在发展

60
00:02:05,849 --> 00:02:07,640
在这个事情上面呢

61
00:02:07,739 --> 00:02:10,590
其实学界就有两派啊

62
00:02:10,590 --> 00:02:15,498
那么一派的观点认为说这个明确的类型呢

63
00:02:15,498 --> 00:02:16,278
好处是什么呢

64
00:02:16,278 --> 00:02:18,378
就是可以尽早的去发现

65
00:02:18,378 --> 00:02:19,909
程序当中的简单错误

66
00:02:19,909 --> 00:02:23,719
比如说你本来呢这个地方应该是用double的啊

67
00:02:23,719 --> 00:02:25,259
结果呢你用了int

68
00:02:25,259 --> 00:02:27,599
那么当然大家都知道用了int以后

69
00:02:27,599 --> 00:02:29,430
你不能表达小数点后面的东西了

70
00:02:29,430 --> 00:02:30,599
那么很可能呢

71
00:02:30,599 --> 00:02:33,870
这是你写程序的时候不小心啊写错了

72
00:02:33,870 --> 00:02:36,599
那么如果这个语言有强烈性检查的

73
00:02:36,599 --> 00:02:38,560
他可以帮你早期的去找出来

74
00:02:38,560 --> 00:02:40,360
所以这是支持强力型那些人的

75
00:02:40,360 --> 00:02:41,199
主要的观点啊

76
00:02:41,199 --> 00:02:43,539
就是说有助于在更早的时候

77
00:02:43,539 --> 00:02:45,959
发现你程序里面的一些潜在的

78
00:02:45,959 --> 00:02:47,519
这个简单的错误

79
00:02:48,538 --> 00:02:50,680
而反对强类型的人呢

80
00:02:50,680 --> 00:02:53,020
也就是说像支持像python啊

81
00:02:53,020 --> 00:02:53,800
像lip啊

82
00:02:53,800 --> 00:02:55,960
像像p h p这样的语言的人呢

83
00:02:55,960 --> 00:02:58,490
就觉得说过于强调类型的话呢

84
00:02:58,490 --> 00:03:01,099
就迫使程序员去面对底层

85
00:03:01,099 --> 00:03:03,259
因为我们在想这些问题的时候

86
00:03:03,259 --> 00:03:05,479
我们想的可能是说我现在要有个数字

87
00:03:05,479 --> 00:03:06,740
但是我可能不太在乎

88
00:03:06,740 --> 00:03:08,030
说这个数字的范围

89
00:03:08,030 --> 00:03:10,000
到底是小于32767呢

90
00:03:10,000 --> 00:03:11,860
还是大于32767

91
00:03:11,860 --> 00:03:12,759
我也不太在乎

92
00:03:12,759 --> 00:03:15,280
说我这个数字将来会不会出现有小数点呢

93
00:03:15,280 --> 00:03:17,439
我反正我现在需要有一个变量去表示数字

94
00:03:17,439 --> 00:03:19,340
那我就有个变量保存数字就好了

95
00:03:19,699 --> 00:03:23,240
我们在这里并没有任何的意见去表达

96
00:03:23,240 --> 00:03:24,409
说哪个是对的

97
00:03:24,409 --> 00:03:25,099
哪个是错的

98
00:03:25,099 --> 00:03:26,939
并不因为我们现在正在学习c语言

99
00:03:26,939 --> 00:03:28,259
所以我们一定要说这个是对的

100
00:03:28,259 --> 00:03:29,520
或者那个是错的啊

101
00:03:29,520 --> 00:03:31,680
这是呃我我们要告诉大家说

102
00:03:31,680 --> 00:03:32,868
在学界

103
00:03:32,868 --> 00:03:34,968
在工业界有两种不同的观点啊

104
00:03:34,968 --> 00:03:36,288
他们对于编程语言的发展

105
00:03:36,288 --> 00:03:37,459
有各自不同的想法

106
00:03:37,459 --> 00:03:39,468
也因此我们会有各种各样不同的语言

107
00:03:39,468 --> 00:03:40,180
对不对

108
00:03:41,240 --> 00:03:47,250
那总体来说早期的语言是强调类型的呃

109
00:03:47,250 --> 00:03:49,319
面向底层的语言是强调类型的

110
00:03:49,319 --> 00:03:51,539
因为当我们做面向底层的程序的时候

111
00:03:51,539 --> 00:03:55,629
我们可能需要用非常明确的类型来表达

112
00:03:55,629 --> 00:03:58,240
我们在计算机内部的一些东西

113
00:03:58,240 --> 00:04:01,659
但是越是面向应用的语言啊

114
00:04:01,659 --> 00:04:03,610
越是离底层的距离越远的语言

115
00:04:03,610 --> 00:04:06,818
它会越忽视类型呃

116
00:04:06,818 --> 00:04:08,169
越强调呃

117
00:04:08,169 --> 00:04:10,479
这个编程在在编程当中

118
00:04:10,479 --> 00:04:12,180
事物逻辑所起的作用

119
00:04:13,960 --> 00:04:15,900
那对于c语言来说呢

120
00:04:15,900 --> 00:04:17,250
它因为太早了

121
00:04:17,250 --> 00:04:18,670
70年代出现的语言

122
00:04:18,670 --> 00:04:21,129
所以呢它它是需要类型的啊

123
00:04:21,129 --> 00:04:22,360
它的变量需要类型

124
00:04:22,360 --> 00:04:23,829
我们都见过这个事情

125
00:04:23,829 --> 00:04:26,829
但是呢他对类型的安全检查并不足够

126
00:04:26,829 --> 00:04:29,829
和后后来的啊这些后期的语言相比呢

127
00:04:29,829 --> 00:04:33,459
它并不是表现为一个非常强的强类型语言

128
00:04:33,459 --> 00:04:35,180
但是呢他又是一个类型语言

129
00:04:37,060 --> 00:04:39,120
那么在c语言当中有什么样的类型呢

130
00:04:39,120 --> 00:04:43,139
呃我们大概可以分成四个大类啊

131
00:04:43,139 --> 00:04:47,019
我们有整数浮点数

132
00:04:47,019 --> 00:04:50,180
逻辑指针和自定义类型

133
00:04:50,538 --> 00:04:52,579
我刚才好像是说四个大类对吧

134
00:04:52,579 --> 00:04:56,310
好四个大类是把逻辑放到整数里头去

135
00:04:56,310 --> 00:04:57,689
我们以后讲到逻辑的时候

136
00:04:57,689 --> 00:04:58,170
我们再来说

137
00:04:58,170 --> 00:05:00,600
为什么会会这么去说这件事情啊

138
00:05:00,740 --> 00:05:04,120
呃说整数整数里头呢

139
00:05:04,199 --> 00:05:06,120
我们之前学过的是int啊

140
00:05:06,120 --> 00:05:08,120
我们知道int表现表达的就是整数

141
00:05:08,120 --> 00:05:09,680
但实际上对于c语言来说

142
00:05:09,680 --> 00:05:10,819
它不仅仅只有int

143
00:05:10,819 --> 00:05:12,740
它有很多其他的int

144
00:05:12,740 --> 00:05:14,060
有各种各样的int

145
00:05:14,060 --> 00:05:16,980
你看我们有char short int long long long啊

146
00:05:16,980 --> 00:05:18,000
对浮点数来说

147
00:05:18,000 --> 00:05:19,680
我们之前学的是double呃

148
00:05:19,680 --> 00:05:20,879
但是我们在讲double的时候

149
00:05:20,879 --> 00:05:22,199
提到过float这个词

150
00:05:22,199 --> 00:05:22,800
对不对

151
00:05:22,800 --> 00:05:25,519
那实际上呢呃我们还会有long double啊

152
00:05:25,519 --> 00:05:28,339
那么逻辑呢是一个叫做bo啊

153
00:05:28,339 --> 00:05:29,420
bo的意思就是补脸啊

154
00:05:29,420 --> 00:05:30,769
布尔量啊补脸

155
00:05:30,769 --> 00:05:31,819
那么还有指针

156
00:05:31,819 --> 00:05:32,899
还有自定义类型

157
00:05:32,899 --> 00:05:34,879
自定义类型呢我们到后面再来讲啊

158
00:05:34,879 --> 00:05:37,610
呃前面的这四种可以被叫做

159
00:05:37,610 --> 00:05:39,769
c语言的基础类型啊

160
00:05:39,769 --> 00:05:43,199
啊这是就这个语言本身就有的啊

161
00:05:43,199 --> 00:05:44,069
基础的类型

162
00:05:44,069 --> 00:05:47,670
那这里面的蓝色的这些是c99 的类型

163
00:05:47,670 --> 00:05:49,079
尤其是这个不

164
00:05:49,079 --> 00:05:51,060
这个不往后面后面讲到的时候再说

165
00:05:51,060 --> 00:05:52,810
但事实上呢可能呃

166
00:05:52,810 --> 00:05:54,910
都不是一个真正的类型啊

167
00:05:54,910 --> 00:05:57,720
它只是人为定义出来的那么一个东西

168
00:05:58,379 --> 00:05:59,959
所以c语言有很多复杂的类型

169
00:05:59,959 --> 00:06:02,329
尤其是你看整数有那么多种是浮点

170
00:06:02,329 --> 00:06:02,899
又有flow

171
00:06:02,899 --> 00:06:03,319
又有double

172
00:06:03,319 --> 00:06:04,579
他们到底有什么区别呢

173
00:06:04,579 --> 00:06:07,540
各种类型有什么不同类型的不同

174
00:06:07,540 --> 00:06:08,620
表现在这么几个地方

175
00:06:08,620 --> 00:06:12,019
一个呢当然不同的类型会有不同的名字

176
00:06:12,019 --> 00:06:14,100
也就意味着当你在定义变量的时候

177
00:06:14,100 --> 00:06:15,389
你要么给的是int

178
00:06:15,389 --> 00:06:16,500
要么给的是shot

179
00:06:16,500 --> 00:06:18,000
要么给的是long long

180
00:06:18,000 --> 00:06:19,230
你总得给他一个名字

181
00:06:19,230 --> 00:06:21,060
来说明我这个变量是什么类型的

182
00:06:21,060 --> 00:06:22,779
所以类型的名字会不一样

183
00:06:22,779 --> 00:06:23,500
第二个呢

184
00:06:23,500 --> 00:06:25,600
输入输出的时候的格式化的

185
00:06:25,600 --> 00:06:28,420
这个格式化字符串里面那个百分号

186
00:06:28,420 --> 00:06:29,350
后面的东西都不同

187
00:06:29,350 --> 00:06:30,370
我们前面已经知道说

188
00:06:30,370 --> 00:06:31,329
如果你要输出一个整数

189
00:06:31,329 --> 00:06:32,329
你要按百分号d

190
00:06:32,329 --> 00:06:33,769
如果你要输出一个浮点数

191
00:06:33,769 --> 00:06:34,939
你要用百分号f

192
00:06:34,939 --> 00:06:36,170
而且我们还知道很麻烦的是

193
00:06:36,170 --> 00:06:38,089
你浮点数输的时候百分之l f对吧

194
00:06:38,089 --> 00:06:39,980
有很多很细节的事情

195
00:06:39,980 --> 00:06:43,959
然后呢表达的数的范围是不一样的

196
00:06:43,959 --> 00:06:47,439
我们这里给了那么一个呃不等式哈

197
00:06:47,439 --> 00:06:48,939
我们说这个恰小于小的

198
00:06:48,939 --> 00:06:49,360
小于in的

199
00:06:49,360 --> 00:06:50,199
小于f小于double

200
00:06:50,199 --> 00:06:53,408
这个意思是说对于一般的类型来说

201
00:06:53,408 --> 00:06:55,689
恰这个类型所能表达的数的范围

202
00:06:55,689 --> 00:06:57,069
比shot来的小

203
00:06:57,069 --> 00:06:58,329
sht比int来的小

204
00:06:58,329 --> 00:06:59,949
int比float来的小

205
00:06:59,949 --> 00:07:01,759
float比double还要来的小

206
00:07:02,079 --> 00:07:05,019
然后接下去就涉及到

207
00:07:05,019 --> 00:07:06,519
在计算机内部的事情了

208
00:07:06,519 --> 00:07:10,240
它在内存当中所占据的大小是不一样的

209
00:07:10,740 --> 00:07:12,209
chara是一个字节

210
00:07:12,209 --> 00:07:14,220
long demo要16个字节

211
00:07:14,220 --> 00:07:17,699
也就是说一个变量到底在内存里面有多大

212
00:07:18,060 --> 00:07:19,139
是不一样的

213
00:07:19,139 --> 00:07:22,060
不同的类型它占据的空间是不同的

214
00:07:22,860 --> 00:07:27,199
然后还有一个呃不太为人所注意的事情

215
00:07:27,199 --> 00:07:31,379
就是不同的类型的变量在这个内存当中

216
00:07:31,379 --> 00:07:33,000
它的表现形式是不一样的

217
00:07:33,000 --> 00:07:36,199
整型的变量是二进制

218
00:07:36,500 --> 00:07:38,959
自然二进制码或者是二进制的不满

219
00:07:38,959 --> 00:07:40,939
而对于浮点类型的数据

220
00:07:40,939 --> 00:07:43,019
无论是float double还是long double

221
00:07:43,019 --> 00:07:44,970
它是一种编码形式

222
00:07:44,970 --> 00:07:46,779
它不是自然而行之术

223
00:07:47,139 --> 00:07:50,019
编码形式就意味着它不能直接拿来做运算

224
00:07:50,019 --> 00:07:52,360
你拿两个浮点数在二进制层面上面

225
00:07:52,360 --> 00:07:53,529
在计算机内部之间

226
00:07:53,529 --> 00:07:56,519
拿两个浮点数来做加法是做不了的

227
00:07:56,519 --> 00:07:58,589
它是一种编码的格式

228
00:07:58,589 --> 00:08:01,899
而两个整数是可以直接在加法器里面

229
00:08:01,899 --> 00:08:02,740
做加法的

230
00:08:02,740 --> 00:08:04,319
所以这些都是他们的不同

231
00:08:04,319 --> 00:08:06,839
c语言呢给出了一个工具啊

232
00:08:06,839 --> 00:08:08,740
有一个运算符叫做size of

233
00:08:08,899 --> 00:08:12,589
这个size of可以给出某个类型或者某个变量

234
00:08:12,589 --> 00:08:14,660
在内存当中所占据的字节数

235
00:08:14,660 --> 00:08:19,259
比如说size of int告诉你int占据了几个字节啊

236
00:08:19,259 --> 00:08:21,060
在内存里面占据几个字节

237
00:08:21,060 --> 00:08:22,019
size of i

238
00:08:22,019 --> 00:08:22,500
会告诉你

239
00:08:22,500 --> 00:08:24,720
i这个变量在内存里面占据几个字节

240
00:08:24,720 --> 00:08:25,870
我们来试一下这件事情

241
00:08:25,870 --> 00:08:26,949
就拿我们这个代码

242
00:08:26,949 --> 00:08:29,529
现在呢我们有一个int的类型的a

243
00:08:29,529 --> 00:08:33,419
然后呢我们就可以用print f让他输出一下

244
00:08:33,419 --> 00:08:37,440
说这个size of int是多少啊

245
00:08:37,440 --> 00:08:39,799
我们让他说得明白点

246
00:08:39,799 --> 00:08:44,019
说这是size of int等于多少

247
00:08:44,080 --> 00:08:46,960
然后呢我们还可以让他再输出一下

248
00:08:46,960 --> 00:08:49,360
说size of a等于多少

249
00:08:49,360 --> 00:08:51,429
所以呢这个是size of a

250
00:08:51,429 --> 00:08:52,979
我们来试一下这个代码

251
00:08:53,080 --> 00:08:55,330
他说的size of int是四

252
00:08:55,330 --> 00:08:57,958
size of a也是四

253
00:08:58,000 --> 00:08:59,320
他会告诉你说

254
00:08:59,320 --> 00:09:00,580
我们现在的int呢

255
00:09:00,580 --> 00:09:03,179
在内存当中占据的是四个字节

256
00:09:03,320 --> 00:09:05,120
一个字节是八个比特

257
00:09:05,120 --> 00:09:06,200
所以四个字节也意味着

258
00:09:06,200 --> 00:09:08,059
这是一个32位的变量

259
00:09:08,059 --> 00:09:11,419
这个变量在内存当中要占据32个比特

260
00:09:11,419 --> 00:09:13,039
或者说占据四个字节

261
00:09:13,039 --> 00:09:14,039
我们可以试一下

262
00:09:14,039 --> 00:09:16,289
如果我们让他说啊

263
00:09:16,289 --> 00:09:17,279
double是多少

264
00:09:17,279 --> 00:09:19,339
他说size of double是八

265
00:09:19,580 --> 00:09:22,700
也就是说double的这个变量

266
00:09:22,700 --> 00:09:27,669
它的这个占据的空间呢是我们int的两倍啊

267
00:09:27,669 --> 00:09:30,159
他要八个字节才能用来表达一个double

268
00:09:30,159 --> 00:09:32,679
我们看一下我们的long double

269
00:09:33,080 --> 00:09:36,200
他说long double要16个字节啊

270
00:09:36,200 --> 00:09:39,509
所以通过size of可以帮你去了解呃

271
00:09:39,509 --> 00:09:40,620
这些类型

272
00:09:40,620 --> 00:09:43,830
它们各自在内存当中占据多大的空间

273
00:09:43,830 --> 00:09:46,839
那么这和我们后面的事情是有关系的哈

274
00:09:46,839 --> 00:09:50,769
但是呢我们的size of它是一个呃静态运算符

275
00:09:50,769 --> 00:09:52,960
它的结果在编译的时刻就决定了

276
00:09:52,960 --> 00:09:53,889
这什么意思呢

277
00:09:53,889 --> 00:09:54,820
我们来试一下

278
00:09:54,820 --> 00:09:58,500
如果我们现在呢想要做这样一件事情

279
00:09:58,500 --> 00:10:03,279
我们知道a加加可以把a给加一

280
00:10:03,279 --> 00:10:04,908
对不对好呃

281
00:10:04,908 --> 00:10:06,678
然后呢我们在做完这个事情以后呢

282
00:10:06,678 --> 00:10:08,669
我们来说a等于多少对吧

283
00:10:08,669 --> 00:10:10,559
所以这一行呢如果他做了a加加

284
00:10:10,559 --> 00:10:12,240
那么我们下一行就应该得到的结果

285
00:10:12,240 --> 00:10:13,080
说a等于七

286
00:10:13,080 --> 00:10:13,919
我们来试一下

287
00:10:13,919 --> 00:10:15,240
他说a等于六

288
00:10:16,259 --> 00:10:17,340
为什么a还是等于六

289
00:10:17,340 --> 00:10:20,440
因为a加加根本就没有做啊

290
00:10:20,440 --> 00:10:22,960
根本就没有做这个size of是静态的

291
00:10:22,960 --> 00:10:25,120
也就是说编译器在编译的时候

292
00:10:25,120 --> 00:10:26,409
看到这有个size of

293
00:10:26,409 --> 00:10:29,269
他就会去看后面的这个表达式

294
00:10:29,269 --> 00:10:32,318
它的结果会是什么类型的

295
00:10:32,318 --> 00:10:35,318
然后根据这个类型就决定了这个size of

296
00:10:35,318 --> 00:10:36,578
以及后面这个括号里面

297
00:10:36,578 --> 00:10:38,078
整个我现在高亮起来

298
00:10:38,078 --> 00:10:40,960
这一部分要被替换成一个什么样的数字

299
00:10:40,960 --> 00:10:42,879
所以当你的程序编译完以后

300
00:10:42,879 --> 00:10:44,859
这个六就已经确定下来了

301
00:10:44,899 --> 00:10:48,318
这个a加加并没有产生实际要执行的代码

302
00:10:49,059 --> 00:10:50,759
好比如说我们可以再试一下

303
00:10:50,759 --> 00:10:53,698
如果说我们现在让他做a加一点

304
00:10:54,019 --> 00:10:55,220
a加一点

305
00:10:55,220 --> 00:10:59,899
所以我们要他去做size of a加一点的事情

306
00:11:00,100 --> 00:11:03,190
他会告诉我们说size of a加一点等于八

307
00:11:03,190 --> 00:11:04,840
为什么a加一点等于八

308
00:11:04,840 --> 00:11:07,198
因为一点是一个double

309
00:11:07,620 --> 00:11:09,419
a是一个整数

310
00:11:09,500 --> 00:11:11,899
在家的两边出现了double和整数

311
00:11:11,899 --> 00:11:13,159
它会把两个都变成double

312
00:11:13,159 --> 00:11:14,600
然后最后的结果是一个double

313
00:11:14,600 --> 00:11:16,399
因此这件事情编译其实知道的

314
00:11:16,399 --> 00:11:18,730
编译知道说这个运算的结果是个double

315
00:11:18,730 --> 00:11:21,659
所以他会说这个size of a加一点的结果

316
00:11:21,659 --> 00:11:23,100
就是double的那个size

317
00:11:23,100 --> 00:11:23,980
也就是八

318
00:11:23,980 --> 00:11:27,039
这一切在编译的时候就已经确定了的啊

319
00:11:27,039 --> 00:11:29,480
size of并不会真的去做计算

