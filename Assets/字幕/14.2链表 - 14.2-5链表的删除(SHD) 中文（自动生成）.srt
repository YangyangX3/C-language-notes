1
00:00:04,360 --> 00:00:05,679
ok找总是容易的

2
00:00:05,679 --> 00:00:05,980
对不对

3
00:00:05,980 --> 00:00:07,059
我们知道了怎么便利

4
00:00:07,059 --> 00:00:08,800
怎么去从头走到尾的

5
00:00:08,800 --> 00:00:10,660
每一个拿出来看看是不是如果是的

6
00:00:10,660 --> 00:00:12,949
就就就就找到了就好了

7
00:00:12,949 --> 00:00:14,199
那生存

8
00:00:15,740 --> 00:00:17,980
ok我们把这段代码再拿下来说

9
00:00:17,980 --> 00:00:19,620
如果我现在想要做删除

10
00:00:22,859 --> 00:00:24,678
现在在这个时候我们找到了

11
00:00:24,678 --> 00:00:26,778
但是我们并不是去打印什么东西

12
00:00:26,778 --> 00:00:28,099
我们需要把它给删掉

13
00:00:28,099 --> 00:00:30,048
但是现在我们的局面是什么

14
00:00:30,048 --> 00:00:31,219
这有点点tricky

15
00:00:31,219 --> 00:00:34,700
你看现在如果说我们列表是这样的啊

16
00:00:34,700 --> 00:00:35,179
这是head

17
00:00:36,439 --> 00:00:38,159
假如说他想找四

18
00:00:38,799 --> 00:00:41,759
当我们的p指向这个东西的时候

19
00:00:41,759 --> 00:00:47,799
他发现说p所指的那个value呢正好就是四

20
00:00:48,340 --> 00:00:50,770
因此我们要把它给删掉

21
00:00:50,770 --> 00:00:52,240
要把它给删掉

22
00:00:52,240 --> 00:00:53,779
要做什么事情呢

23
00:00:54,380 --> 00:00:55,840
其实是几件不同的事情

24
00:00:55,840 --> 00:00:57,009
首先第一件事情是

25
00:00:57,009 --> 00:01:03,250
我们要让他前面的那个node的指针指向它

26
00:01:03,250 --> 00:01:04,579
后面的那个node

27
00:01:06,079 --> 00:01:09,359
然后第二件事情是我们要free那个p

28
00:01:11,859 --> 00:01:12,629
对吧

29
00:01:12,629 --> 00:01:14,099
这两件不同的事情

30
00:01:14,099 --> 00:01:16,159
那麻烦就来了

31
00:01:16,840 --> 00:01:19,780
他前面的那个node是什么

32
00:01:20,620 --> 00:01:22,739
我们只有一个练一个一个指针

33
00:01:22,739 --> 00:01:24,599
说它前面那个节点呢

34
00:01:24,599 --> 00:01:26,280
会有一个指针指向它自己

35
00:01:26,280 --> 00:01:28,099
但是我们并没有指回去的

36
00:01:28,219 --> 00:01:29,659
我我们有这样的链表

37
00:01:29,659 --> 00:01:30,799
但是我们现在这个不是

38
00:01:30,799 --> 00:01:33,319
如果在列表当中有两个方向的

39
00:01:33,319 --> 00:01:34,519
有指过来又指过去的那种

40
00:01:34,519 --> 00:01:35,299
叫做双向链表

41
00:01:35,299 --> 00:01:37,500
现在我们这里叫做单向链表

42
00:01:39,060 --> 00:01:42,420
所以你没有怎么办

43
00:01:43,719 --> 00:01:46,118
这就意味着我们这个for循环就得改

44
00:01:46,819 --> 00:01:48,250
通常我们的做法是说

45
00:01:48,250 --> 00:01:50,170
如果你还有另外一个指针

46
00:01:50,170 --> 00:01:52,019
那个指针指向它前面那个

47
00:01:53,799 --> 00:01:55,319
那这件事情就简单了对吧

48
00:01:57,480 --> 00:02:02,859
我们要做的事情就是kill the next等于p的

49
00:02:03,939 --> 00:02:05,790
然后我们fp就ok了

50
00:02:05,790 --> 00:02:07,950
如果现在p这个不是

51
00:02:07,950 --> 00:02:10,500
那我们要做的事情就是让p指向下一个

52
00:02:10,500 --> 00:02:11,199
对不对

53
00:02:11,419 --> 00:02:14,780
也就是p等于p所指的next

54
00:02:15,039 --> 00:02:17,020
但是在那个之前我们还要做这件事情

55
00:02:17,020 --> 00:02:19,060
让q指向现在p所指的那个

56
00:02:19,060 --> 00:02:21,479
所以在之前要做p等于q这个事情

57
00:02:22,859 --> 00:02:24,598
我们来看看代码怎么写

58
00:02:24,598 --> 00:02:25,979
因此在这个事情呢

59
00:02:25,979 --> 00:02:27,658
这个时候呢我们光有个p不够了

60
00:02:27,658 --> 00:02:28,588
我们还有个q

61
00:02:28,588 --> 00:02:29,878
然后一开始的时候呢

62
00:02:29,878 --> 00:02:30,879
q等于

63
00:02:33,539 --> 00:02:35,939
然后呢p等于list head

64
00:02:36,139 --> 00:02:37,879
判断标准仍然是p在不在

65
00:02:37,879 --> 00:02:39,919
但是在q p等于p的next之前

66
00:02:39,919 --> 00:02:41,030
让q等于p

67
00:02:41,030 --> 00:02:43,139
所以当找到的时候

68
00:02:43,759 --> 00:02:46,629
我们要做的事情是q所指的next

69
00:02:46,629 --> 00:02:50,139
等于p所指的next

70
00:02:50,139 --> 00:02:51,139
然后

71
00:02:53,599 --> 00:02:55,099
free那个屁

72
00:02:58,919 --> 00:03:01,039
不过这么简单是不够的

73
00:03:01,039 --> 00:03:03,770
想想我们刚才在说add的时候发生的问题

74
00:03:03,770 --> 00:03:04,639
在add的时候

75
00:03:04,639 --> 00:03:05,659
我们有一种特殊情况

76
00:03:05,659 --> 00:03:07,259
是说你整个列表是空的

77
00:03:07,259 --> 00:03:09,300
现在在这儿也有特殊情况

78
00:03:11,099 --> 00:03:14,699
如果你觉得自己想象能力不够好

79
00:03:15,479 --> 00:03:17,240
没有办法一下子想到

80
00:03:17,240 --> 00:03:18,830
这里的特殊情况是什么

81
00:03:18,830 --> 00:03:20,699
那我再教你一招

82
00:03:21,740 --> 00:03:23,469
非常机械的一招

83
00:03:23,469 --> 00:03:26,060
当你在用指针的时候

84
00:03:27,080 --> 00:03:28,719
非常机械的做法是

85
00:03:28,719 --> 00:03:33,780
你什么时候你的这个指针变量出现在erro

86
00:03:33,879 --> 00:03:37,400
就是这种error出现在error的左边了

87
00:03:37,400 --> 00:03:38,599
这意味着什么

88
00:03:38,599 --> 00:03:39,259
这意味着

89
00:03:39,259 --> 00:03:41,960
现在你要去用这个指针所指的那个东西了

90
00:03:41,960 --> 00:03:44,389
因此这也就意味着在这个时刻

91
00:03:44,389 --> 00:03:46,740
这个指针它不能升到

92
00:03:48,099 --> 00:03:48,930
对不对

93
00:03:48,930 --> 00:03:51,960
所以非常简单的去识别出

94
00:03:51,960 --> 00:03:53,990
在你的程序当中的边界情况

95
00:03:53,990 --> 00:03:55,789
如果你没有足够的想象能力的话

96
00:03:55,789 --> 00:03:57,560
那你就去看在你的程序当中

97
00:03:57,560 --> 00:04:01,379
什么时候这个变量放在a roll的左边了

98
00:04:01,439 --> 00:04:04,020
然后你去看你有没有足够的代码

99
00:04:04,020 --> 00:04:06,979
去判断他是不是闹

100
00:04:08,740 --> 00:04:09,300
对不对

101
00:04:09,300 --> 00:04:10,740
比如说我们现在来看

102
00:04:10,740 --> 00:04:13,919
这句话要用到p所指的value了

103
00:04:13,919 --> 00:04:16,560
这个p有没有人去判断他是不是闹呢

104
00:04:17,180 --> 00:04:19,240
表面上看起来我这儿没有直接的

105
00:04:19,240 --> 00:04:21,100
但是实际上我的for循环

106
00:04:21,100 --> 00:04:23,920
这个就是用来判断说他是不是脑子

107
00:04:24,360 --> 00:04:25,139
对不对

108
00:04:25,139 --> 00:04:26,519
如果p是闹的话

109
00:04:26,519 --> 00:04:28,050
其实循环进不来

110
00:04:28,050 --> 00:04:29,399
所以这句话是不会被执行的

111
00:04:29,399 --> 00:04:31,100
所以这句话这句话是安全的

112
00:04:31,100 --> 00:04:31,519
对不对

113
00:04:31,519 --> 00:04:33,769
这就完全就同样的这个地方

114
00:04:33,769 --> 00:04:35,360
这个p也是安全的

115
00:04:35,360 --> 00:04:37,519
也同样的这个p是安全的

116
00:04:37,579 --> 00:04:41,319
但是这个q就不是安全的

117
00:04:41,459 --> 00:04:46,920
我们没有机制去保证这个q一定不是闹

118
00:04:46,920 --> 00:04:49,480
没有写一幅语句判断这件事情

119
00:04:49,598 --> 00:04:52,959
所以这正好就是我们这种情况下的一个

120
00:04:52,959 --> 00:04:54,360
边界条件

121
00:04:54,839 --> 00:04:56,459
什么边界条件呢

122
00:04:56,459 --> 00:04:59,139
如果你现在找到说这个是你的

123
00:04:59,139 --> 00:05:00,339
要删除的那个东西

124
00:05:00,339 --> 00:05:01,060
这当然没问题

125
00:05:01,060 --> 00:05:02,079
因为q只想他了

126
00:05:02,079 --> 00:05:04,480
如果你现在发现说第一个节点

127
00:05:04,480 --> 00:05:05,860
就是你要找的那个东西

128
00:05:05,860 --> 00:05:06,519
p在这

129
00:05:06,519 --> 00:05:08,199
而这个时候也就是for循环

130
00:05:08,199 --> 00:05:09,040
刚进去的时候

131
00:05:09,040 --> 00:05:09,519
对不对

132
00:05:09,519 --> 00:05:11,100
而这个时候的q呢

133
00:05:11,519 --> 00:05:13,100
他是得闹

134
00:05:13,459 --> 00:05:14,899
这就是我们的特殊情况

135
00:05:14,899 --> 00:05:16,490
因为在这种特殊情况下

136
00:05:16,490 --> 00:05:20,269
你不是让q所指的next等于p所指next

137
00:05:20,269 --> 00:05:23,329
你应该让head等于p所指的next

138
00:05:23,329 --> 00:05:24,279
也就是

139
00:05:27,100 --> 00:05:28,790
所以回到代码

140
00:05:28,790 --> 00:05:31,639
我们在这儿要做的事情是在做这句话之前

141
00:05:31,639 --> 00:05:32,629
我们要识别一下

142
00:05:32,629 --> 00:05:34,850
如果q存在的话

143
00:05:34,850 --> 00:05:38,899
那我们才能做这个事情

144
00:05:40,259 --> 00:05:42,259
else呢我们要做的形式

145
00:05:46,668 --> 00:05:49,339
要等于p所指的next

146
00:05:51,220 --> 00:05:53,620
但是最后不管怎么样都要fp

147
00:05:54,899 --> 00:05:57,889
所以这是这是我们教你的

148
00:05:57,889 --> 00:06:03,139
在这一类的程序当中最机械的一个办法

149
00:06:05,199 --> 00:06:08,399
你可以没有那么好的空间想象能力

150
00:06:08,399 --> 00:06:09,598
逻辑思维能力

151
00:06:09,598 --> 00:06:12,300
去想出他的各种各样的bug

152
00:06:12,319 --> 00:06:13,939
各种各样的边界条件

153
00:06:13,939 --> 00:06:15,980
那你就机械的去看你的代码当中

154
00:06:15,980 --> 00:06:17,180
有没有可能出现

155
00:06:17,180 --> 00:06:20,060
你有没有哪一个指针在ero的左边

156
00:06:20,060 --> 00:06:21,019
在他使用的时候

157
00:06:21,019 --> 00:06:23,360
是没有代码去保证它的安全的

158
00:06:23,360 --> 00:06:24,800
如果存在这样的情况

159
00:06:24,800 --> 00:06:26,889
那你就要放代码去保证它的安全

160
00:06:26,889 --> 00:06:29,529
把它的各种等于到

161
00:06:29,529 --> 00:06:31,060
不等于到的情况都做出来

162
00:06:31,060 --> 00:06:31,990
等于NULL的时候怎么做

163
00:06:31,990 --> 00:06:33,279
不等于到的时候怎么做

164
00:06:33,598 --> 00:06:36,418
你如果能把这些事情全都做完了

165
00:06:36,418 --> 00:06:37,499
这是非常机械的动作

166
00:06:37,499 --> 00:06:37,798
对不对

167
00:06:37,798 --> 00:06:39,119
你把这些事情都做完了

168
00:06:39,119 --> 00:06:40,858
ok你的代码一定是好的

169
00:06:40,858 --> 00:06:41,500
一定是安全

