1
00:00:04,280 --> 00:00:06,080
既然我们有了那么多的类型

2
00:00:06,080 --> 00:00:08,900
你看我们有chart shot int long

3
00:00:08,900 --> 00:00:09,980
long了那么多的整数

4
00:00:09,980 --> 00:00:11,599
我们有float double

5
00:00:11,599 --> 00:00:12,140
long double

6
00:00:12,140 --> 00:00:13,160
那么多的浮点数

7
00:00:13,160 --> 00:00:16,739
那么这些类型放在一起运算的时候

8
00:00:16,739 --> 00:00:18,178
如果我们的运算符的两边

9
00:00:18,178 --> 00:00:19,379
出现不一致的类型

10
00:00:19,379 --> 00:00:21,778
那么会自动转化成为较大

11
00:00:21,778 --> 00:00:23,759
或者说较宽的类型

12
00:00:23,759 --> 00:00:24,809
大的意思

13
00:00:24,809 --> 00:00:25,919
宽的意思是说

14
00:00:25,919 --> 00:00:28,199
那个类型能够表达的数的范围更大

15
00:00:28,199 --> 00:00:32,600
所以我们知道说ch会自动转换成shot shot

16
00:00:32,600 --> 00:00:33,979
会自动转换成int int

17
00:00:33,979 --> 00:00:35,689
会自动转换成long long

18
00:00:35,689 --> 00:00:37,859
如果需要会自动转换成long long

19
00:00:37,859 --> 00:00:40,859
而如果整数和浮点在一起的话

20
00:00:40,859 --> 00:00:42,539
那么整数会被置换

21
00:00:42,539 --> 00:00:43,920
自动转换成浮点

22
00:00:43,920 --> 00:00:46,719
float会被自动转换成double

23
00:00:46,719 --> 00:00:49,299
所以当两边类型不一致的时候

24
00:00:49,299 --> 00:00:51,369
它会自动做转换这件事情

25
00:00:51,369 --> 00:00:52,859
c语言会替我们做

26
00:00:54,159 --> 00:00:58,219
但是对于print f来说有一点点特别啊

27
00:00:58,219 --> 00:00:59,600
这个事情有点特别

28
00:00:59,600 --> 00:01:02,960
任何小于int的类型都会被转换成int

29
00:01:02,960 --> 00:01:04,969
当你要去print f的时候

30
00:01:04,969 --> 00:01:05,870
你的chara

31
00:01:05,870 --> 00:01:08,060
你的shot会被自动转换成int

32
00:01:08,060 --> 00:01:11,019
而你的float也会被自动转换成double

33
00:01:11,019 --> 00:01:13,180
所以这就是为什么我们在print f的时候

34
00:01:13,180 --> 00:01:15,969
我们用百分号f就足以输出double

35
00:01:15,969 --> 00:01:17,709
不需要百分号lf

36
00:01:17,709 --> 00:01:19,659
因为无论是float还是double

37
00:01:19,659 --> 00:01:21,969
传给print def的时候都已经变成double了

38
00:01:21,969 --> 00:01:24,039
所以摆放f就足够表明了

39
00:01:24,039 --> 00:01:25,759
但是gf的时候不行

40
00:01:26,079 --> 00:01:27,280
skin f的时候

41
00:01:27,280 --> 00:01:30,700
他要明确的知道后面那个变量的大小

42
00:01:30,700 --> 00:01:32,590
所以如果你要输入short

43
00:01:32,590 --> 00:01:33,760
你需要百分啊

44
00:01:33,760 --> 00:01:34,448
hd

45
00:01:34,448 --> 00:01:35,649
如果你要int

46
00:01:35,649 --> 00:01:36,789
你需要百分号d

47
00:01:36,789 --> 00:01:37,868
如果你要long long

48
00:01:37,868 --> 00:01:39,399
你要百分号l d

49
00:01:39,399 --> 00:01:43,500
但是如果你要以整数的形式输入一个差

50
00:01:43,500 --> 00:01:44,519
我们没有办法

51
00:01:44,519 --> 00:01:45,900
你必须先输入给一个整数

52
00:01:45,900 --> 00:01:47,579
然后再交给那个ta类型

53
00:01:48,939 --> 00:01:50,159
除了自动类型转换

54
00:01:50,159 --> 00:01:51,719
我们还可以做强制类型转换

55
00:01:51,719 --> 00:01:52,799
如果你要把一个量

56
00:01:52,799 --> 00:01:54,799
强制转换成另外一个类型

57
00:01:54,799 --> 00:01:55,879
通常这种强制是

58
00:01:55,879 --> 00:01:57,920
因为我们需要做往小的地方转

59
00:01:57,920 --> 00:02:00,609
比如说你要把一个int强制转换成一个chara

60
00:02:00,609 --> 00:02:03,909
你要把一个double强制转换成一个int

61
00:02:03,909 --> 00:02:06,129
那么这个时候我们需要采用这样的形式

62
00:02:06,129 --> 00:02:08,580
就是类型圆括号值

63
00:02:08,819 --> 00:02:12,419
注意这个写法是类型的名字

64
00:02:12,419 --> 00:02:14,189
后面外面有括号

65
00:02:14,189 --> 00:02:15,659
后面跟的是直

66
00:02:16,118 --> 00:02:19,479
有的语言它有另外一种形式是类型

67
00:02:19,479 --> 00:02:20,799
后面跟上圆括号

68
00:02:20,799 --> 00:02:22,169
圆括号里面放直

69
00:02:22,169 --> 00:02:24,330
c语言不是这么干的

70
00:02:24,330 --> 00:02:26,669
c语言是要在类型的外面加上

71
00:02:26,669 --> 00:02:28,229
只要加上圆括号

72
00:02:28,229 --> 00:02:30,639
比如说10.2int

73
00:02:30,639 --> 00:02:33,129
那就把10.2这个double转换成int了

74
00:02:33,129 --> 00:02:34,000
32笑的

75
00:02:34,000 --> 00:02:37,090
就把32这个int转换成shot了啊

76
00:02:37,090 --> 00:02:39,718
但是呢这个时候你要注意存在安全性

77
00:02:39,718 --> 00:02:43,079
因为小的量它不一定能够表达大的量

78
00:02:43,079 --> 00:02:45,538
比如说如果你把32768付给了short

79
00:02:45,538 --> 00:02:46,378
会变成什么呢

80
00:02:46,378 --> 00:02:47,269
我们来试一下

81
00:02:47,269 --> 00:02:52,919
我们说我们32768付给了shot

82
00:02:53,280 --> 00:02:54,000
short

83
00:02:54,000 --> 00:02:55,620
32768作为一个整数

84
00:02:55,620 --> 00:02:56,939
它是32768

85
00:02:56,939 --> 00:02:58,919
但是shot的这个类型

86
00:02:58,919 --> 00:03:01,229
最大只能表达到32767

87
00:03:01,229 --> 00:03:03,629
所以如果把32768给了sht

88
00:03:03,629 --> 00:03:07,199
它的结果就是负的32768

89
00:03:07,919 --> 00:03:09,020
挺惊人吧

90
00:03:09,020 --> 00:03:11,120
如果不是short

91
00:03:11,199 --> 00:03:12,159
32768

92
00:03:12,159 --> 00:03:13,270
就是32768

93
00:03:13,270 --> 00:03:15,520
如果把它赋给short

94
00:03:15,520 --> 00:03:18,419
它就变成负的32768了

95
00:03:20,718 --> 00:03:21,579
大家想一想

96
00:03:21,579 --> 00:03:24,429
我们在讲整数的时候解释过这件事情

97
00:03:24,429 --> 00:03:27,259
如果我们把它强制给了char

98
00:03:28,338 --> 00:03:29,520
它是零

99
00:03:29,520 --> 00:03:31,800
为什么32768对于char是零

100
00:03:31,800 --> 00:03:32,879
你自己想想看

101
00:03:32,879 --> 00:03:34,169
chr是八个比特的

102
00:03:34,169 --> 00:03:36,419
32768是一个什么样的数

103
00:03:36,419 --> 00:03:38,579
32768是15个比特的零

104
00:03:38,579 --> 00:03:39,899
加一个比特的一

105
00:03:39,899 --> 00:03:41,370
第16位上是一

106
00:03:41,370 --> 00:03:44,400
对于x来说取得最低的那八个比特

107
00:03:44,400 --> 00:03:46,039
我们就只看到了零

108
00:03:46,560 --> 00:03:48,030
强制类型转换呢

109
00:03:48,030 --> 00:03:49,620
只是从那个变量计算出了一个

110
00:03:49,620 --> 00:03:50,400
新的类型的值

111
00:03:50,400 --> 00:03:51,659
它不会去改变那个量

112
00:03:51,659 --> 00:03:53,729
无论是值还是类型都不改变

113
00:03:53,729 --> 00:03:56,490
所以如果我们现在是说我有个int i

114
00:03:56,490 --> 00:03:58,340
叫做32768

115
00:03:58,379 --> 00:04:01,379
我另外有个shot的变量s

116
00:04:01,379 --> 00:04:05,159
然后我们把这个i强制转换成short

117
00:04:05,679 --> 00:04:08,588
然后最后呢我们仍然去输出那个i

118
00:04:08,588 --> 00:04:11,258
在这个过程当中i会不会变呢

119
00:04:11,258 --> 00:04:12,308
i没有变

120
00:04:12,308 --> 00:04:15,819
i仍然是32768强制类型转换

121
00:04:15,819 --> 00:04:18,459
只是用这个变量i的值

122
00:04:18,459 --> 00:04:20,250
去算出了一个新的shot

123
00:04:20,250 --> 00:04:21,870
但是他不会去改变这个i

124
00:04:21,870 --> 00:04:23,370
它不是去改变量

125
00:04:23,370 --> 00:04:25,439
它是去计算一个新的值出来

126
00:04:25,439 --> 00:04:27,000
对于这个式子来说呢

127
00:04:27,038 --> 00:04:29,139
呃我们我们想要做的也许是

128
00:04:29,139 --> 00:04:31,629
a除以b以后的结果转换成int

129
00:04:31,629 --> 00:04:36,720
但实际上他会做的事情呢是把a转换成int

130
00:04:36,720 --> 00:04:40,689
然后去除以b再把这个结果虽然a是int

131
00:04:40,689 --> 00:04:41,649
但因为b还是double

132
00:04:41,649 --> 00:04:43,629
所以整个结果还是double double的结果

133
00:04:43,629 --> 00:04:45,620
再去付给我们的整形的i

134
00:04:46,819 --> 00:04:49,059
因为我们强制类型转换的优先级

135
00:04:49,059 --> 00:04:50,978
是比四则运算还要来得高的

136
00:04:50,978 --> 00:04:52,658
比加减乘除都要来得高

137
00:04:52,658 --> 00:04:54,579
所以如果我们想要我做

138
00:04:54,579 --> 00:04:55,538
我们刚才那个结果呢

139
00:04:55,538 --> 00:04:57,098
我们应该是把后面加上括号

140
00:04:57,098 --> 00:04:58,899
说a除以b的结果

141
00:04:58,899 --> 00:05:03,199
整个我们再来做int的强制类型转换

142
00:05:03,459 --> 00:05:06,290
如果我们想要做a和b的除

143
00:05:06,290 --> 00:05:07,730
如果我们做成这个样子

144
00:05:07,730 --> 00:05:10,759
那么其实它会先做a和b的整数的除法

145
00:05:10,759 --> 00:05:13,199
然后再去强制转换成double

146
00:05:13,199 --> 00:05:15,720
如果我们想要让a变成double

147
00:05:15,720 --> 00:05:17,279
以后去做double的除法

148
00:05:17,279 --> 00:05:19,500
我们得把这个圆括号给去掉

