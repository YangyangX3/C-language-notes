1
00:00:04,320 --> 00:00:06,330
我们的浮点数是有两种的

2
00:00:06,330 --> 00:00:08,460
一种呢是double

3
00:00:08,460 --> 00:00:10,480
另外一种呢是float

4
00:00:10,759 --> 00:00:12,550
我们有两种浮点数

5
00:00:12,550 --> 00:00:14,470
这两种浮点数当然有不同啊

6
00:00:14,470 --> 00:00:16,239
就跟不同的整数类型一样

7
00:00:16,239 --> 00:00:16,989
我们有shot

8
00:00:16,989 --> 00:00:17,469
有int

9
00:00:17,469 --> 00:00:18,489
它们的大小不一样

10
00:00:18,489 --> 00:00:20,109
浮点类型大小也不一样

11
00:00:20,109 --> 00:00:22,809
float呢在计算机里头是32位

12
00:00:22,809 --> 00:00:24,960
也就是说它占据四个字节

13
00:00:25,339 --> 00:00:27,500
而double呢是64位

14
00:00:27,500 --> 00:00:28,789
它要占据八个字节

15
00:00:28,789 --> 00:00:29,780
所以double

16
00:00:29,780 --> 00:00:33,200
显然你看这个从从这个占据内存大小来说

17
00:00:33,200 --> 00:00:34,899
它也是float的两倍啊

18
00:00:34,960 --> 00:00:37,530
呃他们的范围也不一样

19
00:00:37,530 --> 00:00:39,149
这个float的话呢

20
00:00:39,149 --> 00:00:41,219
它的范围大概是十的38次方

21
00:00:41,219 --> 00:00:44,009
那么double呢是十的308次方

22
00:00:44,009 --> 00:00:45,390
显然这个要大了很多

23
00:00:45,390 --> 00:00:47,320
这不是大了十倍的关系啊

24
00:00:47,320 --> 00:00:50,850
这是十的多少次幂的关系

25
00:00:50,850 --> 00:00:52,418
所以这个大的非常多

26
00:00:53,060 --> 00:00:55,240
但是呢你要仔细看这里的描述

27
00:00:55,240 --> 00:00:55,780
他是这样的

28
00:00:55,780 --> 00:00:59,990
他说这是在1.2乘以十的-38次方

29
00:00:59,990 --> 00:01:02,840
到3.4乘以十的-38次方

30
00:01:02,840 --> 00:01:05,239
而且呢这个地方还是不那么准确的

31
00:01:05,239 --> 00:01:08,450
大约是1.2乘十的-38次方

32
00:01:08,450 --> 00:01:09,759
加上一个正负

33
00:01:09,759 --> 00:01:11,049
这句话什么意思呢

34
00:01:11,049 --> 00:01:13,239
这是整个数的范围

35
00:01:13,239 --> 00:01:14,640
这是零

36
00:01:16,859 --> 00:01:21,950
在接近零的地方到一个很远的地方

37
00:01:21,950 --> 00:01:24,959
这中间是有效的范围

38
00:01:24,959 --> 00:01:27,870
在这个地方小于零的某一个点

39
00:01:27,870 --> 00:01:29,849
到一个很远的地方

40
00:01:29,849 --> 00:01:32,250
这中间也是有效的范围

41
00:01:32,250 --> 00:01:35,189
但是在这个中间靠近零

42
00:01:37,260 --> 00:01:40,899
有那么一小片区域是我们无法表达的

43
00:01:42,140 --> 00:01:44,049
十的-38次方

44
00:01:44,049 --> 00:01:45,759
这是一个很小的数

45
00:01:45,799 --> 00:01:47,480
但是它很接近零

46
00:01:47,480 --> 00:01:50,069
但是它并不等于零

47
00:01:50,069 --> 00:01:54,120
在这个数和零中间有那么一块区域

48
00:01:54,120 --> 00:01:58,099
这块区域是我们无法用float来表达的

49
00:01:58,099 --> 00:01:59,269
对于double来说

50
00:01:59,269 --> 00:02:01,159
我们可以表达的更小一点

51
00:02:01,159 --> 00:02:04,480
负的308次方大概到这里了

52
00:02:04,480 --> 00:02:07,659
但是它和零中间仍然存在一小块区域

53
00:02:07,659 --> 00:02:09,159
这小块区域里面的数字

54
00:02:09,159 --> 00:02:11,849
是我们无法表达的啊

55
00:02:11,849 --> 00:02:15,000
所以它的这个范围是这样一个东西

56
00:02:15,338 --> 00:02:16,658
靠近零的

57
00:02:16,658 --> 00:02:20,109
非常小的那些数字在正-2端无法表达

58
00:02:24,598 --> 00:02:28,740
所以零是他特地拿出来可以表达的一个数

59
00:02:28,740 --> 00:02:32,719
还有正负的无穷大是它可以表达的

60
00:02:32,859 --> 00:02:34,538
n a n是什么意思呢

61
00:02:34,538 --> 00:02:38,400
n a n的意思是说它不是一个有效的数字

62
00:02:38,459 --> 00:02:40,139
我们可以用浮点来表达

63
00:02:40,139 --> 00:02:42,658
一个不是有效的数字的这个值

64
00:02:42,658 --> 00:02:43,799
到我后面回来看

65
00:02:43,799 --> 00:02:45,959
我们怎么能够做出无穷大

66
00:02:45,959 --> 00:02:47,840
怎么能够做出n来啊

67
00:02:47,979 --> 00:02:49,300
还有一件事情

68
00:02:49,300 --> 00:02:50,979
float和double

69
00:02:50,979 --> 00:02:53,949
float和double他们有不同的有效数字

70
00:02:53,949 --> 00:02:55,849
有效数字的意思是说

71
00:02:55,849 --> 00:02:58,610
在你用float所表达的数里头

72
00:02:58,610 --> 00:02:59,599
如果是七

73
00:02:59,599 --> 00:03:00,590
就是他float的

74
00:03:00,590 --> 00:03:01,370
有些是七

75
00:03:01,370 --> 00:03:04,349
意思就是说只有七个数字是有效的

76
00:03:04,349 --> 00:03:06,759
第八个数字是不准确的

77
00:03:06,759 --> 00:03:09,039
第九个数字大家就更不准确了

78
00:03:09,039 --> 00:03:09,879
对double来说

79
00:03:09,879 --> 00:03:11,659
只有15个数字是有效的

80
00:03:11,759 --> 00:03:13,080
不同的呃

81
00:03:13,080 --> 00:03:16,409
文件上面会对这个数字也有一点点以呃

82
00:03:16,409 --> 00:03:18,289
这个这个呃不同啊

83
00:03:18,289 --> 00:03:20,150
有的会说啊7~8个数字

84
00:03:20,150 --> 00:03:21,469
有的会说15~16个数字

85
00:03:21,469 --> 00:03:22,860
也有的会说6~7个数字

86
00:03:22,860 --> 00:03:25,379
那么我们前面已经用过浮点的输入输出

87
00:03:25,379 --> 00:03:27,180
我们知道对double呢在print f的时候

88
00:03:27,180 --> 00:03:28,500
你可以用百分号f

89
00:03:28,618 --> 00:03:29,938
在scaf的时候呢

90
00:03:29,938 --> 00:03:31,490
你必须用百分号lf

91
00:03:31,490 --> 00:03:33,590
对float print f的时候

92
00:03:33,590 --> 00:03:34,849
你用的还是百分号f

93
00:03:34,849 --> 00:03:35,990
但是scaf的时候呢

94
00:03:35,990 --> 00:03:36,889
你要用百分号f

95
00:03:36,889 --> 00:03:38,360
而不能是百分lf

96
00:03:38,360 --> 00:03:41,120
另外这里还有一个百分号e print f的时候

97
00:03:41,120 --> 00:03:42,259
如果采用百分号e

98
00:03:42,259 --> 00:03:45,689
他会做的事情是输出一个科学技术法啊

99
00:03:45,689 --> 00:03:47,610
我们来看一下它到底会输出什么样的东西

100
00:03:47,610 --> 00:03:48,419
给我们

101
00:03:48,500 --> 00:03:50,240
如果我们有一个double

102
00:03:50,240 --> 00:03:53,680
比如说等于123456789

103
00:03:54,639 --> 00:03:56,639
现在呢我们需要它print f

104
00:03:57,718 --> 00:04:02,028
百分号e来给我们输出一下这个f f

105
00:04:02,028 --> 00:04:03,879
我们看看他给我们输出了什么

106
00:04:07,319 --> 00:04:10,639
然后103x10的三次方

107
00:04:11,520 --> 00:04:16,310
如果我们让它输出的是百分号f的话

108
00:04:16,310 --> 00:04:20,158
这个f f会给我们输出的是在逗号后面

109
00:04:20,158 --> 00:04:21,119
1234.5

110
00:04:21,119 --> 00:04:22,399
67890

111
00:04:22,399 --> 00:04:25,490
它是一个普通的带小数点的数

112
00:04:25,490 --> 00:04:28,819
而这个呢是以科学计数法来表示的

113
00:04:28,819 --> 00:04:31,678
那么一个数我们还可以试一下

114
00:04:31,678 --> 00:04:33,980
如果是大写的e会有什么样的结果

115
00:04:35,079 --> 00:04:39,478
就是这个e表示这个指数的这个e啊

116
00:04:39,478 --> 00:04:40,769
换成了大写字母

117
00:04:40,769 --> 00:04:41,879
仅此而已

118
00:04:42,660 --> 00:04:43,639
科学技术法呢

119
00:04:43,639 --> 00:04:47,459
就是用这样一种方式来表达一个数字啊

120
00:04:47,459 --> 00:04:48,779
它具有这么几个部分

121
00:04:48,779 --> 00:04:50,759
在最前面可以有加号或者减号

122
00:04:50,759 --> 00:04:52,860
表明整个数是正数还是负数

123
00:04:52,879 --> 00:04:54,019
可能有小数点

124
00:04:54,019 --> 00:04:55,040
可以没有小数点

125
00:04:55,040 --> 00:04:57,259
可以用小写的e或者大写的e

126
00:04:57,439 --> 00:05:00,079
后面的那个指数部分可以是负的

127
00:05:00,079 --> 00:05:00,800
如果是正的话

128
00:05:00,800 --> 00:05:02,060
这个正好也可以省略掉

129
00:05:02,060 --> 00:05:05,569
然后整个词中间不能有任何的空格

130
00:05:05,569 --> 00:05:07,519
这样呢就形成一个科学计数法

131
00:05:07,519 --> 00:05:09,649
我们既可以用百分号e

132
00:05:09,649 --> 00:05:11,269
让它输出科学技术法的值

133
00:05:11,269 --> 00:05:12,899
我们也可以在程序里面

134
00:05:12,899 --> 00:05:14,819
如果你的值很大

135
00:05:14,819 --> 00:05:17,029
比如说0.0000001

136
00:05:17,029 --> 00:05:19,160
有非常多的小数

137
00:05:19,160 --> 00:05:21,259
这个小数点后面很多的零在那里头

138
00:05:21,259 --> 00:05:23,029
你也可以用科学计数法来表达它

139
00:05:23,029 --> 00:05:24,610
你在程序里面可以这样子来写

140
00:05:24,610 --> 00:05:29,858
说我们这个fs呢是等于一一负的十

141
00:05:29,858 --> 00:05:33,369
这也是c语言能够接受的一种这个呃

142
00:05:33,369 --> 00:05:34,238
常数啊

143
00:05:34,238 --> 00:05:35,779
字面量的表达形式

144
00:05:36,079 --> 00:05:38,930
这时候我们的输出就会是这样子的

145
00:05:38,930 --> 00:05:42,649
一点乘以十的-10次方

146
00:05:42,649 --> 00:05:46,310
但是如果把它作为一个double来输出的时候

147
00:05:46,310 --> 00:05:49,339
我们得到的反而只有零点了

148
00:05:49,339 --> 00:05:52,660
因为这是1x10的-10次方

149
00:05:52,660 --> 00:05:53,410
对不对

150
00:05:53,410 --> 00:05:57,089
我们如何要能够在这个地方得到零

151
00:05:57,089 --> 00:05:57,870
0000

152
00:05:57,870 --> 00:06:00,779
后面的这个后面的那个一呢

153
00:06:00,779 --> 00:06:03,949
我们得要在百分号和f中间给出一个数字

154
00:06:03,949 --> 00:06:05,629
比如说点16

155
00:06:05,629 --> 00:06:06,230
这意思是

156
00:06:06,230 --> 00:06:07,490
我希望你在小数点后面

157
00:06:07,490 --> 00:06:10,470
给我输出16位的数字

158
00:06:10,470 --> 00:06:13,709
这个时候我们会看到它给我们带来的是一

159
00:06:13,709 --> 00:06:16,709
23456789

160
00:06:16,709 --> 00:06:20,120
十十个十位的那么一个啊

161
00:06:20,120 --> 00:06:21,139
意义在哪里

162
00:06:21,379 --> 00:06:23,000
double是可以表达这个

163
00:06:23,000 --> 00:06:24,259
因为它有15位有效数字

164
00:06:24,259 --> 00:06:26,029
它足以表达114 十

165
00:06:26,029 --> 00:06:28,819
但是如果你不去指定要输出多少位

166
00:06:28,819 --> 00:06:29,959
小数的时候

167
00:06:30,639 --> 00:06:32,158
他给我们看到的是零

168
00:06:32,158 --> 00:06:33,959
所以我们在百分号和f之间

169
00:06:33,959 --> 00:06:35,369
可以加上小数点

170
00:06:35,369 --> 00:06:38,620
加上数字来指定说我要输出小数点后几位

171
00:06:38,620 --> 00:06:40,660
但是呢在这个时候做输出呢

172
00:06:40,660 --> 00:06:41,980
它是做四舍五入的

173
00:06:41,980 --> 00:06:43,120
所以我们来试一下

174
00:06:43,120 --> 00:06:46,660
看我们让他去输出0.0049

175
00:06:46,779 --> 00:06:48,579
这个呢是点三

176
00:06:48,579 --> 00:06:50,560
也就是小数点后面要保留三位

177
00:06:50,560 --> 00:06:52,089
所以保留的是这三位

178
00:06:52,089 --> 00:06:53,379
那么后面是一个九

179
00:06:53,379 --> 00:06:57,139
因此呢我们看到说他给我们输出结果

180
00:06:57,139 --> 00:06:58,699
这是0.005

181
00:06:59,420 --> 00:07:02,470
如果我们要求他输出30位

182
00:07:02,470 --> 00:07:04,420
这是0.0049

183
00:07:04,420 --> 00:07:06,519
他给我们输出的是这样的一个数字

184
00:07:06,519 --> 00:07:09,800
你看不是说0.0049

185
00:07:09,800 --> 00:07:10,910
后面0000

186
00:07:10,910 --> 00:07:14,180
而是0.0489999999

187
00:07:14,180 --> 00:07:16,548
但后面还有些东西呃

188
00:07:16,548 --> 00:07:18,858
这是实际上这是真实的情况

189
00:07:18,858 --> 00:07:20,658
也就是说在计算机内部

190
00:07:20,658 --> 00:07:22,620
实际上他是这个数字

191
00:07:22,620 --> 00:07:24,209
我们的0.0049

192
00:07:24,209 --> 00:07:26,939
不能够精确地被表达为0.0049

193
00:07:26,939 --> 00:07:27,870
在计算机内部

194
00:07:27,870 --> 00:07:29,579
因为从数学上来说

195
00:07:29,579 --> 00:07:32,980
当然数的范围内所有的数是连续的

196
00:07:32,980 --> 00:07:36,939
连续的意思是说你任意取两个点

197
00:07:37,019 --> 00:07:41,220
你在这中间你可以得到任意多的数

198
00:07:41,220 --> 00:07:45,220
任意两点中间的数的数量应该是无限的

199
00:07:45,920 --> 00:07:47,959
但是对于计算机来说

200
00:07:47,959 --> 00:07:53,500
你最终只能用离散的数字去表达数字

201
00:07:53,500 --> 00:07:54,339
也就是说

202
00:07:54,339 --> 00:07:56,500
如果对于double来说

203
00:07:56,500 --> 00:07:58,000
我们可以表达这个数

204
00:07:58,000 --> 00:07:59,620
我们也可以下一个数

205
00:07:59,620 --> 00:08:01,060
我们能够表达的是这个数

206
00:08:01,060 --> 00:08:04,160
那么位于这两个数中间的那些数

207
00:08:04,160 --> 00:08:06,319
就是double所不能表达的

208
00:08:07,839 --> 00:08:12,040
当我们写出那个0.0048的时候

209
00:08:12,519 --> 00:08:14,740
我们的计算机就要帮我们

210
00:08:14,740 --> 00:08:15,879
如果0.0048

211
00:08:15,879 --> 00:08:17,980
正好是在他能够表达的两个数

212
00:08:17,980 --> 00:08:19,000
中间的一个数

213
00:08:19,000 --> 00:08:22,500
那么我们就必须选择离他最近的那个数

214
00:08:22,500 --> 00:08:23,939
比方说我们就认为说

215
00:08:23,939 --> 00:08:26,560
这个可以用来表达0.0048

216
00:08:26,879 --> 00:08:29,730
但是它和实际的0.0048之间

217
00:08:29,730 --> 00:08:31,379
是有距离的

218
00:08:31,379 --> 00:08:34,139
这个距离就是浮点数的误差

219
00:08:34,639 --> 00:08:36,458
这和它的精度无关

220
00:08:36,460 --> 00:08:39,250
当然double能够表达更多的数

221
00:08:39,250 --> 00:08:41,200
就意味着对于double来说

222
00:08:41,200 --> 00:08:43,440
它的相邻的两个数之间的距离

223
00:08:43,440 --> 00:08:44,820
会比float的

224
00:08:44,820 --> 00:08:47,490
相邻的两个数之间的距离要来得小

225
00:08:47,490 --> 00:08:50,879
所以他能相对更准确地表达一些数字

226
00:08:50,879 --> 00:08:54,139
但是具体的一个数字

227
00:08:54,139 --> 00:08:57,379
在double里头依然可能是不准确的

228
00:08:58,360 --> 00:08:59,669
这是天生的

229
00:08:59,669 --> 00:09:01,519
这是没有任何办法的

230
00:09:02,059 --> 00:09:03,320
我们在计算机里面

231
00:09:03,320 --> 00:09:05,600
是无法准确的去表达一个数

232
00:09:05,600 --> 00:09:07,539
除非我们不使用

233
00:09:07,539 --> 00:09:09,730
像double float这样的基础类型

234
00:09:09,730 --> 00:09:12,399
比方说我们把我们知道

235
00:09:12,399 --> 00:09:15,570
2/3是无法准确表达的

236
00:09:15,570 --> 00:09:18,450
可是如果我在计算机里面就把它记录成为

237
00:09:18,450 --> 00:09:21,179
二和三这两个整数的话

238
00:09:21,240 --> 00:09:23,979
那么我们还是可以去准确表达它的

239
00:09:24,039 --> 00:09:26,440
当然这就完全是另外一个故事了

240
00:09:26,440 --> 00:09:29,559
这个事情已经远远超过我们c语言这门课

241
00:09:29,559 --> 00:09:30,849
所能表达的事情了

242
00:09:30,849 --> 00:09:34,089
这个数是000.0049最近的那个数

243
00:09:34,089 --> 00:09:35,679
所以我们就得到了这个数

244
00:09:35,720 --> 00:09:38,240
然后我们再来看这个有意思的结果

245
00:09:38,240 --> 00:09:40,479
这个做的是零点

246
00:09:40,919 --> 00:09:43,599
我们要求小数点后面三位

247
00:09:43,860 --> 00:09:45,120
求小数点后面三位

248
00:09:45,120 --> 00:09:46,679
但是他的第四位是个四

249
00:09:46,679 --> 00:09:48,120
所以按照四舍五入的规律

250
00:09:48,120 --> 00:09:49,429
它不会进位上去

251
00:09:49,429 --> 00:09:52,100
然后你看我们得到的结果是负的

252
00:09:52,100 --> 00:09:53,698
零点

253
00:09:54,139 --> 00:09:55,909
本来我们知道对于数学来说

254
00:09:55,909 --> 00:09:57,599
零是没有正和负的

255
00:09:58,019 --> 00:10:00,539
但是在我们这样的程序安排当中

256
00:10:00,539 --> 00:10:02,659
它就会给我们输出负的零

257
00:10:03,500 --> 00:10:06,220
这个原因就是因为后面被抹掉了

258
00:10:06,220 --> 00:10:08,679
但是前面那个负号呢仍然记下来了

259
00:10:08,679 --> 00:10:10,929
这个数字本身当然它还是负的

260
00:10:10,929 --> 00:10:12,950
但是作为四舍五入的结果

261
00:10:12,950 --> 00:10:14,929
它就没有任何有效的

262
00:10:14,929 --> 00:10:17,299
这个非零的数字在里头了

263
00:10:17,840 --> 00:10:19,519
这个是四舍五入的

264
00:10:19,519 --> 00:10:20,480
我们还可以再看一下

265
00:10:20,480 --> 00:10:22,500
如果是0.0045的时候

266
00:10:23,440 --> 00:10:25,220
他果然是四舍五入的

