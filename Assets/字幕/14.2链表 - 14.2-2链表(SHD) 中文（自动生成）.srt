1
00:00:04,400 --> 00:00:06,679
假如说我们想要实现的是说哦

2
00:00:06,679 --> 00:00:09,119
这是一个数组啊

3
00:00:09,119 --> 00:00:11,099
然后呢我们下面有另外一个数组

4
00:00:11,099 --> 00:00:16,679
然后我们让这个数组指向下一个数组

5
00:00:17,059 --> 00:00:18,829
然后如果不够了

6
00:00:18,829 --> 00:00:21,500
我再来一块那么大小的东西

7
00:00:21,500 --> 00:00:23,359
让它指向他

8
00:00:23,359 --> 00:00:24,980
我们我们想的是很好

9
00:00:24,980 --> 00:00:27,050
图可以画成这么美好的样子

10
00:00:27,050 --> 00:00:30,118
但是实际的去想一想

11
00:00:30,118 --> 00:00:32,488
如果这是一个int的数组

12
00:00:32,488 --> 00:00:34,079
我们如何能让它

13
00:00:34,079 --> 00:00:37,179
最后还能指向下一个东西呢

14
00:00:37,880 --> 00:00:39,219
我不能说诶

15
00:00:39,219 --> 00:00:41,740
你你那个指针不是跟跟int一样大吗

16
00:00:41,740 --> 00:00:43,098
又不是永远是这样子的

17
00:00:44,219 --> 00:00:47,000
所以更常见的做法其实不是这样子

18
00:00:47,000 --> 00:00:48,350
而是另外一种样子

19
00:00:48,350 --> 00:00:52,469
那时候我们会说我们呢有那么一个东西

20
00:00:52,469 --> 00:00:54,630
它里头其实要分成两部分

21
00:00:54,630 --> 00:00:56,670
一部分是那个数据

22
00:00:56,670 --> 00:00:58,848
另外一部分是一个指针

23
00:00:58,848 --> 00:01:01,698
于是那个指针就可以指向下一个

24
00:01:01,979 --> 00:01:03,450
同样的东西

25
00:01:03,450 --> 00:01:05,129
那个里面也是两个

26
00:01:05,129 --> 00:01:06,150
有一个数据

27
00:01:06,150 --> 00:01:07,170
还有个指针

28
00:01:07,170 --> 00:01:09,480
它又指向了下一个

29
00:01:10,140 --> 00:01:12,090
当然到了最后一个

30
00:01:12,090 --> 00:01:14,250
如果我们这时候只有三个数

31
00:01:14,250 --> 00:01:15,510
三个这样的数据

32
00:01:15,510 --> 00:01:17,609
那么在最后一个我们画这样一个符号

33
00:01:17,609 --> 00:01:20,618
说哦它没有后面的东西了

34
00:01:21,659 --> 00:01:24,379
然后我们再需要有一个指针

35
00:01:24,379 --> 00:01:26,420
去指向第一个东西

36
00:01:26,420 --> 00:01:29,629
说这是整个事情的头

37
00:01:29,629 --> 00:01:31,099
这是哪个头

38
00:01:31,959 --> 00:01:34,920
这样构成的一个东西叫做链表

39
00:01:34,920 --> 00:01:36,120
link the list

40
00:01:36,120 --> 00:01:38,500
链表指的就是这样的东西

41
00:01:38,700 --> 00:01:41,480
有很多的带着数据的

42
00:01:41,519 --> 00:01:42,659
这些东西呢

43
00:01:42,659 --> 00:01:44,640
我们把它叫做节点

44
00:01:44,640 --> 00:01:45,930
带着数据的节点

45
00:01:45,930 --> 00:01:48,120
可是每个节点呢其实是两样东西

46
00:01:48,120 --> 00:01:50,930
数据还有指向下一个的指针

47
00:01:50,930 --> 00:01:54,299
于是到程序里面它变成什么样子呢

48
00:01:54,659 --> 00:01:56,219
这就是我们那个节点的定义

49
00:01:56,219 --> 00:01:57,840
我们把它定义成一个结构

50
00:01:57,840 --> 00:01:59,579
这个结构里面的只有两样东西

51
00:01:59,579 --> 00:02:01,109
一个东西是那个value

52
00:02:01,109 --> 00:02:03,359
另外一个东西是一个指针

53
00:02:03,359 --> 00:02:05,459
名字叫做next下一个嘛

54
00:02:05,459 --> 00:02:09,439
那它的类型呢是rap下划线抖的

55
00:02:09,739 --> 00:02:11,118
这个加下划线note

56
00:02:11,118 --> 00:02:12,229
就这个东西对吧

57
00:02:12,229 --> 00:02:16,128
我们知道如果我们现在呢没有这个type def

58
00:02:16,128 --> 00:02:19,259
那这事儿很顺理成章说啊

59
00:02:19,259 --> 00:02:21,039
当然我们也不会有这个node

60
00:02:21,039 --> 00:02:22,360
那如果是这个样子呢

61
00:02:22,360 --> 00:02:23,199
我们的意思是说

62
00:02:23,199 --> 00:02:25,419
我们有一个rap叫做下划线note

63
00:02:25,419 --> 00:02:27,969
那么当然当我们在这个里头

64
00:02:27,969 --> 00:02:29,530
我们我们要指向他自己嘛

65
00:02:29,530 --> 00:02:33,069
下一个还是他这种类型的一个结构变量

66
00:02:33,069 --> 00:02:33,370
对不对

67
00:02:33,370 --> 00:02:36,240
所以我们还得说这是jd的

68
00:02:36,240 --> 00:02:39,120
然后现在我们把它放在type def里头了

69
00:02:39,878 --> 00:02:41,938
我们想说我们要定义一种类型

70
00:02:41,938 --> 00:02:43,139
这种类型叫做node

71
00:02:43,139 --> 00:02:44,938
将来我们不需要再带上structure

72
00:02:44,938 --> 00:02:45,179
对不对

73
00:02:45,179 --> 00:02:47,158
我们在讲结构的时候讲讲这个事情

74
00:02:47,158 --> 00:02:48,359
我们有了typedef之后

75
00:02:48,359 --> 00:02:51,209
我们可以省调到处去打那个structure

76
00:02:51,209 --> 00:02:52,618
然后我会把它叫做node

77
00:02:52,618 --> 00:02:54,299
那为什么我们在这儿不能说

78
00:02:54,299 --> 00:02:57,479
这是node的那个指针呢

79
00:02:57,780 --> 00:03:01,620
因为在这一行在第六行的时候

80
00:03:01,620 --> 00:03:04,159
node还没有出现

81
00:03:04,860 --> 00:03:05,419
编译器

82
00:03:05,419 --> 00:03:06,500
在这个第六行的时候

83
00:03:06,500 --> 00:03:07,759
不知道no的是什么

84
00:03:07,759 --> 00:03:09,560
但是你如果告诉他说

85
00:03:09,560 --> 00:03:12,169
这个下划线note这件事情

86
00:03:12,169 --> 00:03:13,639
编译器是知道的

87
00:03:13,919 --> 00:03:16,439
所以这是我们非常常见的一种写法

88
00:03:16,439 --> 00:03:17,969
我们在这儿用这个

89
00:03:17,969 --> 00:03:20,580
然后typedef把它定义成另外一个东西

90
00:03:20,580 --> 00:03:21,560
叫做node

91
00:03:21,959 --> 00:03:23,460
这是我们这个结构

92
00:03:24,278 --> 00:03:25,618
接下来的问题

93
00:03:25,618 --> 00:03:29,248
其实跟我们前面在说可变的数组是一样的

94
00:03:29,248 --> 00:03:30,838
我们需要对它做一些操作

95
00:03:30,838 --> 00:03:31,560
对不对

96
00:03:32,360 --> 00:03:35,080
我们需要有一些东西去表达它

97
00:03:35,080 --> 00:03:36,340
比如说在我们那张图上

98
00:03:36,340 --> 00:03:40,000
我们看到我们最起码要有一个东西来表达

99
00:03:40,000 --> 00:03:41,180
它的第一个

100
00:03:41,519 --> 00:03:44,519
然后我们要怎么样去放这些东西

101
00:03:44,519 --> 00:03:46,379
所以我们有一系列的代码要去写

102
00:03:46,379 --> 00:03:48,750
我们先来看我们要做的第一件事情是

103
00:03:48,750 --> 00:03:50,699
我们要往这个链表里面

104
00:03:50,699 --> 00:03:53,099
加一个新的元素进去

105
00:03:53,099 --> 00:03:54,750
这件事情要怎么做

106
00:03:54,750 --> 00:03:57,900
所以我们现在呢打算写一个程序

107
00:03:57,900 --> 00:04:00,979
去使用我们这样的这种结构啊

108
00:04:00,979 --> 00:04:02,840
然后去构造一些什么样的东西

109
00:04:02,840 --> 00:04:04,250
我们的故事背景呢是说

110
00:04:04,250 --> 00:04:06,500
我们的程序要去读书很多的number

111
00:04:06,579 --> 00:04:09,998
然后读到-1为止会读到多少个number

112
00:04:09,998 --> 00:04:11,020
我不知道

113
00:04:12,099 --> 00:04:13,259
读到-1为止

114
00:04:13,259 --> 00:04:15,360
然后我又需要把每一个都记下来

115
00:04:15,360 --> 00:04:16,920
我们之前反复遇到过这样的事情

116
00:04:16,920 --> 00:04:18,839
我们知道最开始求average的时候

117
00:04:18,839 --> 00:04:19,560
求平均数的时候

118
00:04:19,560 --> 00:04:21,720
我们知道说如果你需要求平均数啊

119
00:04:21,720 --> 00:04:22,920
那那我们不用记每一个

120
00:04:22,920 --> 00:04:24,540
我们每次都加起来就可以了

121
00:04:24,718 --> 00:04:26,579
后来学了数组的时候

122
00:04:26,579 --> 00:04:27,418
我们说呃

123
00:04:27,418 --> 00:04:29,038
如果我们想要输出大于平均数的

124
00:04:29,038 --> 00:04:30,160
什么东西的时候

125
00:04:30,860 --> 00:04:31,360
好吧

126
00:04:31,360 --> 00:04:32,449
那时候我们就发现说

127
00:04:32,449 --> 00:04:34,610
因为数组的缺陷就在于

128
00:04:34,610 --> 00:04:36,110
它的大小必须是事先知道的

129
00:04:36,110 --> 00:04:38,089
因此我们不能用读入-1表示

130
00:04:38,089 --> 00:04:39,089
结束这种事情了

131
00:04:39,089 --> 00:04:41,639
我们我们必须让用户先告诉我们

132
00:04:41,639 --> 00:04:43,230
你有多少个数字要处理

133
00:04:43,230 --> 00:04:45,389
然后我们去产生那么大的一个数组

134
00:04:45,389 --> 00:04:46,819
然后我们才来才能

135
00:04:46,819 --> 00:04:48,199
才能够继续的去读这些东西

136
00:04:48,199 --> 00:04:49,250
才能继续做处理

137
00:04:49,250 --> 00:04:51,620
现在我们就把这个事情再往前推一步

138
00:04:51,620 --> 00:04:54,019
就说我就是有那么多的数字要读进来

139
00:04:54,019 --> 00:04:54,800
我不知道有多少个

140
00:04:54,800 --> 00:04:55,879
我事先不知道有多少个

141
00:04:55,879 --> 00:04:57,079
我就是要读到-1

142
00:04:57,079 --> 00:04:58,339
告诉你结束了

143
00:04:59,379 --> 00:05:01,620
我们怎么来利用我们刚学的这些东西

144
00:05:01,620 --> 00:05:01,980
来做事情

145
00:05:01,980 --> 00:05:04,620
当然利用我们之前学的那个变长数组

146
00:05:04,620 --> 00:05:05,879
我们也能做这个事情

147
00:05:05,879 --> 00:05:08,379
我们现在忘了那个变长数组

148
00:05:08,379 --> 00:05:11,199
我们想要用我们刚刚讲的那种图上画的

149
00:05:11,199 --> 00:05:12,850
link list的那种链表来做

150
00:05:12,850 --> 00:05:14,000
我们要怎么做

151
00:05:15,480 --> 00:05:18,360
所以在这个地方我们读到了那个数字

152
00:05:18,478 --> 00:05:20,488
我们需要把这个数字放到

153
00:05:20,488 --> 00:05:21,418
为了方便起见

154
00:05:21,418 --> 00:05:23,459
我们把这个结构的定义抄在上面

155
00:05:23,459 --> 00:05:25,709
放到这个某个node里头去

156
00:05:25,709 --> 00:05:28,689
然后让它要加到已有的那个地方

157
00:05:30,370 --> 00:05:30,939
对不对

158
00:05:30,939 --> 00:05:34,949
所以也许在这个地方我们要做的事情是说

159
00:05:34,949 --> 00:05:37,800
ok那我们需要在这里

160
00:05:45,170 --> 00:05:47,269
加到某个link list去

161
00:05:47,269 --> 00:05:51,259
那这个link list是以什么方式来表达

162
00:05:51,259 --> 00:05:53,259
说这是这个link list

163
00:05:53,420 --> 00:05:55,939
你看我们在这个图上最关键的是什么

164
00:05:55,939 --> 00:05:56,899
是这个had

165
00:05:56,899 --> 00:05:58,459
我们有个东西是had

166
00:05:58,459 --> 00:05:59,540
我们这个东西是head

167
00:05:59,540 --> 00:06:03,579
这个head用来表达说我在这里它所代表的

168
00:06:03,579 --> 00:06:06,100
他所指的是那一个linulist

169
00:06:06,100 --> 00:06:08,139
所以首先其实在我们的程序里头

170
00:06:08,139 --> 00:06:10,480
得要有那个表达head的东西

171
00:06:11,800 --> 00:06:12,839
我们先这样做

172
00:06:12,839 --> 00:06:17,069
我们先说我们在这儿有一个node的指针

173
00:06:17,069 --> 00:06:17,879
叫做head

174
00:06:17,879 --> 00:06:19,879
它一开始是等于now

175
00:06:19,978 --> 00:06:20,728
对啊

176
00:06:23,009 --> 00:06:24,838
这个head所指也是一个空

177
00:06:24,838 --> 00:06:27,740
也就是说这个整个link list是空的

178
00:06:28,019 --> 00:06:31,040
ok然后我们要add到link list去

179
00:06:31,040 --> 00:06:32,569
我们先把代码在这里写

180
00:06:32,569 --> 00:06:33,500
然后我们再来看

181
00:06:33,500 --> 00:06:35,209
是不是像我们在可变数组那样

182
00:06:35,209 --> 00:06:36,230
把它把它拿出来

183
00:06:36,230 --> 00:06:37,610
作为一套函数来写

184
00:06:37,610 --> 00:06:39,920
如果我们现在要add到in the list剧

185
00:06:39,920 --> 00:06:43,490
首先第一件事情是我们要制造出这个strong node

186
00:06:43,490 --> 00:06:48,439
也就是说这个node的一个结构体出来怎么做

187
00:06:49,560 --> 00:06:51,560
我们这个node的这个结构体

188
00:06:51,560 --> 00:06:53,569
是不断的要出现的

189
00:06:53,569 --> 00:06:54,740
我每读入一个数

190
00:06:54,740 --> 00:06:57,259
我要做一个node的结构体给他

191
00:06:57,259 --> 00:06:58,160
再读一个数

192
00:06:58,160 --> 00:06:59,540
又做一个node结构体给他

193
00:06:59,540 --> 00:07:01,399
然后当当然我们还要去把它们连起来

194
00:07:01,399 --> 00:07:02,029
对不对

195
00:07:02,029 --> 00:07:06,620
所以也许在这个地方我们需要做一件事情

196
00:07:06,620 --> 00:07:09,899
是说我们需要有一个node的指针

197
00:07:10,199 --> 00:07:14,279
是是以malloc的方式来得到的

198
00:07:14,279 --> 00:07:15,480
当然为了用malloc

199
00:07:15,480 --> 00:07:19,360
我们得去include那个s t d lib.h

200
00:07:21,319 --> 00:07:23,499
ok我们得到了这个之后

201
00:07:23,499 --> 00:07:26,379
我们要对这个p所指的那一块东西去做点

202
00:07:26,379 --> 00:07:26,970
初始化

203
00:07:26,970 --> 00:07:30,120
p所指的那个value呢就应该等于这里的number

204
00:07:30,120 --> 00:07:34,310
然后p所指的那个next呢就应该等于那个now

205
00:07:34,310 --> 00:07:37,339
因为这是新的一个他要被放到后面去的

206
00:07:37,339 --> 00:07:39,589
我们现在要做的事情是我们新来了一个

207
00:07:39,589 --> 00:07:41,000
我们要把它加到它的后面去

208
00:07:41,000 --> 00:07:45,089
所以我们新的那一个呢是在最后的那一个

209
00:07:45,089 --> 00:07:49,139
他的那个next应该是一个now

210
00:07:49,779 --> 00:07:53,040
然后我们要让末尾的那个的next

211
00:07:53,040 --> 00:07:57,028
指向我们现在的这个新的这个对不对

212
00:07:57,028 --> 00:07:58,980
因此接下来的信息是什么

213
00:07:59,180 --> 00:08:04,550
接下来的事情应该是我们要找到最后那个

214
00:08:04,550 --> 00:08:07,519
然后把它接上去

215
00:08:07,519 --> 00:08:09,500
那怎么找到最后那一个呢

216
00:08:09,939 --> 00:08:11,019
我们要便利

217
00:08:11,019 --> 00:08:11,500
对不对

218
00:08:11,500 --> 00:08:13,379
所以我们有个

219
00:08:15,560 --> 00:08:17,810
啊一开始让他等于那个head好了

220
00:08:17,810 --> 00:08:22,069
然后做的事是说while这个last还有next的话

221
00:08:22,069 --> 00:08:24,529
如果last next不是闹的话

222
00:08:24,529 --> 00:08:28,959
那么last呢就等于last所指的next

223
00:08:30,620 --> 00:08:32,649
因此当这个循环结束的时候

224
00:08:32,649 --> 00:08:37,379
这个last就是我们的最后哪一个了

225
00:08:39,019 --> 00:08:41,559
回过来说我们现在做的事情是说

226
00:08:41,559 --> 00:08:42,909
回到这张图上

227
00:08:42,909 --> 00:08:46,559
我们让last呢一开始等于这个

228
00:08:47,440 --> 00:08:49,679
然后我们看它的next有没有东西

229
00:08:49,679 --> 00:08:50,639
现在它next有东西

230
00:08:50,639 --> 00:08:54,899
于是我们让last等于last所指的那个东西的next

231
00:08:54,899 --> 00:08:56,519
于是last就指向了它

232
00:08:56,700 --> 00:08:58,379
还有没有东西有东西

233
00:08:58,379 --> 00:08:59,580
last next就是这样的

234
00:08:59,580 --> 00:09:01,919
他当last指向它的时候

235
00:09:01,919 --> 00:09:04,500
原来我们还没有attach上去的时候

236
00:09:04,500 --> 00:09:06,879
我们发现说他的next是now

237
00:09:06,879 --> 00:09:08,558
于是这件事情就停下来了

238
00:09:08,558 --> 00:09:10,089
因此当这个循环停下来的时候

239
00:09:10,089 --> 00:09:12,609
last所指的就是最后一个

240
00:09:12,609 --> 00:09:14,960
于是接下来我们要做的事情

241
00:09:14,960 --> 00:09:18,679
就是这个last所指的next呢

242
00:09:18,679 --> 00:09:20,929
就应该等于我们现在这儿的p

243
00:09:20,929 --> 00:09:23,078
ok这事就算完了

244
00:09:24,259 --> 00:09:27,958
不过这代码写到这儿是有问题的

245
00:09:28,740 --> 00:09:32,000
问题就在于你想当当

246
00:09:32,000 --> 00:09:33,590
一开始我们只有一个head

247
00:09:33,590 --> 00:09:35,419
那个head指向的是now

248
00:09:35,419 --> 00:09:36,860
什么东西都没有的时候

249
00:09:36,860 --> 00:09:41,820
我们现在的代码是说让last等于这个head

250
00:09:41,820 --> 00:09:45,120
然后我们就要去判断说last所指的next

251
00:09:45,399 --> 00:09:48,940
我们说的last所指的head next

252
00:09:48,940 --> 00:09:51,220
现在last就等于这个东西

253
00:09:51,220 --> 00:09:52,570
last就等于这个head

254
00:09:52,570 --> 00:09:56,269
它的这个error是无效的

255
00:09:56,269 --> 00:10:00,419
因为last本身是now nerror是无效的

256
00:10:01,720 --> 00:10:04,830
因此这种情况下的问题就在于

257
00:10:04,830 --> 00:10:08,938
我们在这个代码当中要去用last

258
00:10:10,120 --> 00:10:14,839
但是我们没有去看过last现在本身是不是脑

259
00:10:15,059 --> 00:10:16,740
所以我们需要在这儿加点东西

260
00:10:16,740 --> 00:10:21,480
我们需要说如果这个last不是now的话

261
00:10:21,480 --> 00:10:24,559
那我们才来做这些事情

262
00:10:27,220 --> 00:10:30,019
其实一直要到这儿

263
00:10:32,259 --> 00:10:33,779
那否则的话呢

264
00:10:34,220 --> 00:10:36,139
如果last是now

265
00:10:36,139 --> 00:10:37,399
也就是说had是now

266
00:10:37,399 --> 00:10:41,470
其实我们要做的事情是head等于p对不对

267
00:10:41,470 --> 00:10:44,749
第一个第一个是第一个是个特殊的情况

268
00:10:44,749 --> 00:10:47,568
第一个原来had等于指向的是等于的是now

269
00:10:47,568 --> 00:10:48,440
什么也没指

270
00:10:48,440 --> 00:10:50,149
当你有了第一个之后

271
00:10:50,149 --> 00:10:52,590
你应该让head指向你的第一个

272
00:10:52,590 --> 00:10:55,659
当然这个时候你的第一个the next是

273
00:10:56,120 --> 00:10:57,919
这才是一个完备的代码

274
00:10:57,919 --> 00:11:00,580
所以别看我们做了一个

275
00:11:00,580 --> 00:11:02,440
只是做的最简单的第一件事情

276
00:11:02,440 --> 00:11:06,750
我们要去制造出那个链表的一个元素

277
00:11:06,750 --> 00:11:09,720
但是我们得要做这么复杂的一段遗传动作

