1
00:00:04,400 --> 00:00:07,859
c语言被称作是接近底层的语言

2
00:00:08,378 --> 00:00:09,909
是有很多原因的

3
00:00:09,909 --> 00:00:13,478
当然一方面c语言的程序编译完以后

4
00:00:13,478 --> 00:00:16,179
能够直接在机器上运行

5
00:00:16,739 --> 00:00:17,879
我们目前看到

6
00:00:17,879 --> 00:00:20,519
基本上任何一台新的机器出来以后

7
00:00:20,519 --> 00:00:22,359
任何一个新的硬件出来以后

8
00:00:22,359 --> 00:00:23,739
c语言是唯一的

9
00:00:23,739 --> 00:00:25,719
可以在这个上面写程序的一个手段

10
00:00:25,719 --> 00:00:26,289
当然了

11
00:00:26,289 --> 00:00:27,579
再往下我们还有汇编

12
00:00:27,579 --> 00:00:30,600
那是另外一个故事呃

13
00:00:30,739 --> 00:00:32,270
另外一方面呢

14
00:00:32,270 --> 00:00:33,590
c语言本身

15
00:00:33,590 --> 00:00:36,959
它提供了一些比较接近底层的操作

16
00:00:37,020 --> 00:00:41,250
这些操作呢如果你不是要直接去操纵硬件

17
00:00:41,250 --> 00:00:43,259
直接去做一些非常底层的事情

18
00:00:43,259 --> 00:00:44,579
你一般是用不到的

19
00:00:45,240 --> 00:00:47,579
我们今天就来看一些这样的操作

20
00:00:48,359 --> 00:00:51,950
我们屏幕上列出来的这个叫做安慰运算

21
00:00:51,950 --> 00:00:56,929
这些运算符都是把这个整数

22
00:00:56,929 --> 00:01:01,439
当做是一个这个二进制的东西来做计算的

23
00:01:02,560 --> 00:01:04,290
那么有哪些呢

24
00:01:04,290 --> 00:01:05,969
我们有安慰的余

25
00:01:05,969 --> 00:01:08,439
安慰的或安慰的取反

26
00:01:08,599 --> 00:01:11,359
其实你看我们在讲逻辑运算的时候

27
00:01:11,359 --> 00:01:13,250
我们逻辑运算符有逻辑语

28
00:01:13,250 --> 00:01:14,870
那时候是两个演的

29
00:01:14,870 --> 00:01:17,920
有逻辑或那时候是两个竖线

30
00:01:17,920 --> 00:01:19,599
我们有逻辑的取反

31
00:01:19,599 --> 00:01:20,500
那是一个感叹号

32
00:01:20,500 --> 00:01:21,519
但是现在安慰的取反

33
00:01:21,519 --> 00:01:22,989
那是一个波浪号啊

34
00:01:22,989 --> 00:01:23,920
我们还有安慰的

35
00:01:23,920 --> 00:01:25,819
抑或还有左翼和右翼

36
00:01:25,819 --> 00:01:28,489
那我们逐一来看一下这些运算符

37
00:01:28,489 --> 00:01:30,099
安慰的鱼呢

38
00:01:30,280 --> 00:01:34,959
安慰的鱼呢是说两个数两个整数啊

39
00:01:34,959 --> 00:01:35,530
做鱼

40
00:01:35,530 --> 00:01:38,799
那么它的这个呃对应的位上面

41
00:01:38,799 --> 00:01:42,079
如果两位两个整数对应的位上都是一的

42
00:01:42,159 --> 00:01:45,400
你说x的d i y和y的第i位都是一的

43
00:01:45,400 --> 00:01:47,530
那么这个鱼的结果呢就是一

44
00:01:47,530 --> 00:01:50,299
否则的话余的结果就是零

45
00:01:50,340 --> 00:01:51,920
我们来做一下看

46
00:01:52,200 --> 00:01:54,299
假如呢我们有两个二进制数啊

47
00:01:54,299 --> 00:01:56,819
一个是0101啊

48
00:01:56,819 --> 00:01:59,459
一个是1010

49
00:02:00,180 --> 00:02:01,739
这这是一个二进制数啊

50
00:02:01,739 --> 00:02:05,040
这个二进制数呢就是10 16进制的5a啊

51
00:02:05,040 --> 00:02:06,840
然后呢他和另外一个二进制数

52
00:02:06,840 --> 00:02:09,379
比如说啊1000

53
00:02:09,379 --> 00:02:12,110
这个1100

54
00:02:12,110 --> 00:02:14,599
这个石榴这个变成16进制呢

55
00:02:14,599 --> 00:02:17,080
它就是一个这个八

56
00:02:19,399 --> 00:02:20,889
把c啊

57
00:02:20,889 --> 00:02:24,659
那么这两个数如果做鱼的话

58
00:02:25,139 --> 00:02:27,240
那鱼的意思呢就是对应位上呢

59
00:02:27,240 --> 00:02:30,599
这两位呢只有全一的时候才会是一

60
00:02:30,599 --> 00:02:32,150
所以这两位是一

61
00:02:32,150 --> 00:02:33,620
他是一啊

62
00:02:33,620 --> 00:02:35,569
那其他的都没有全一

63
00:02:35,569 --> 00:02:37,680
所以其他的就都是零

64
00:02:38,800 --> 00:02:40,560
于是呢我们得到的结果呢

65
00:02:40,560 --> 00:02:41,340
这个是什么呢

66
00:02:41,340 --> 00:02:43,979
这个就是零八啊

67
00:02:43,979 --> 00:02:45,000
这叫做安慰鱼

68
00:02:45,000 --> 00:02:47,550
也就是说它的每一位要拿来

69
00:02:47,550 --> 00:02:49,770
逐一的去做这个呃运算

70
00:02:49,770 --> 00:02:51,689
做这个鱼的运算啊

71
00:02:51,689 --> 00:02:53,789
只有当对应的位上面都是一的时候

72
00:02:53,789 --> 00:02:54,860
它才是

73
00:02:55,159 --> 00:02:56,960
那它的结果才是一

74
00:02:57,199 --> 00:02:59,780
那么我们的这种这个安慰鱼呢

75
00:02:59,780 --> 00:03:01,520
经常用在两种应用上面

76
00:03:01,520 --> 00:03:02,419
那一种呢

77
00:03:02,419 --> 00:03:06,090
比如说我们希望让某一位或者某些位为零

78
00:03:06,090 --> 00:03:09,509
比如说我们现在这儿写的这个x娱乐零

79
00:03:09,509 --> 00:03:12,460
x f e f e是什么

80
00:03:13,319 --> 00:03:16,219
f呢就是e e e e

81
00:03:16,219 --> 00:03:19,280
而e呢就是1110

82
00:03:19,719 --> 00:03:22,840
所以如果他和另外一个数去相遇

83
00:03:22,840 --> 00:03:27,128
比如说另外那个数是10100101

84
00:03:27,128 --> 00:03:29,960
那么和那个数据相比的话呢

85
00:03:30,359 --> 00:03:31,919
这个是零

86
00:03:31,919 --> 00:03:36,179
所以不管第二个数这一位上是零还是一的

87
00:03:36,179 --> 00:03:37,120
一定是零

88
00:03:37,259 --> 00:03:39,210
而这些位上都是一

89
00:03:39,210 --> 00:03:39,960
都是一的话

90
00:03:39,960 --> 00:03:42,810
那就意味着如果第二个数上面是一

91
00:03:42,810 --> 00:03:44,079
它会是一

92
00:03:44,079 --> 00:03:47,229
第二个书上面是零呢会是零

93
00:03:47,229 --> 00:03:48,849
所以当我们拿

94
00:03:48,849 --> 00:03:51,819
其实如果拿一个一去和另外一个数相遇

95
00:03:51,819 --> 00:03:54,370
就意味着我们看的是那个数是多少

96
00:03:54,370 --> 00:03:55,449
保持不变

97
00:03:55,449 --> 00:03:56,099
你看

98
00:03:57,919 --> 00:03:59,500
从这儿划条线七

99
00:03:59,500 --> 00:04:01,389
这这七个比特保持不变

100
00:04:01,389 --> 00:04:03,520
而这个比特呢因为这里是零

101
00:04:03,520 --> 00:04:04,810
所以就变成零了

102
00:04:04,810 --> 00:04:08,509
所以其实这个是f一他在做的事情

103
00:04:08,509 --> 00:04:12,360
就是使得另外一个数的最低位变成零

104
00:04:12,539 --> 00:04:15,659
还有一种应用呢是取一个数当中的一段

105
00:04:15,659 --> 00:04:19,740
比如说x和0x f f去相遇了

106
00:04:19,740 --> 00:04:21,980
怎么叫做取当中一段呢

107
00:04:22,379 --> 00:04:24,920
我们知道我们的一个int啊

108
00:04:25,079 --> 00:04:27,209
是要有32个比特的对吧

109
00:04:27,209 --> 00:04:29,519
所以呢它可能是这样的

110
00:04:29,519 --> 00:04:32,540
有四个字节来表达一个int

111
00:04:34,439 --> 00:04:38,959
现在呢我说我这个数啊是零零啊

112
00:04:38,959 --> 00:04:39,980
16进制表达的啊

113
00:04:39,980 --> 00:04:46,680
0000f f这样两个一鱼约了以后呢

114
00:04:46,680 --> 00:04:48,449
这些全是零了对吧

115
00:04:48,449 --> 00:04:49,709
因为这个已经是零了嘛

116
00:04:49,709 --> 00:04:50,600
所以这些全是零

117
00:04:50,600 --> 00:04:52,819
然后这个最后这个字节呢

118
00:04:52,819 --> 00:04:54,079
那就你原来是什么

119
00:04:54,079 --> 00:04:54,920
我就留下什么

120
00:04:54,920 --> 00:04:56,759
比如原来是10101010

121
00:04:56,759 --> 00:04:58,500
ok那我留下还是1010

122
00:04:58,500 --> 00:05:00,839
10101010是什么

123
00:05:00,839 --> 00:05:02,040
这是aa啊

124
00:05:03,500 --> 00:05:05,740
所以我们用这个方法

125
00:05:05,740 --> 00:05:08,100
就可以取得一个书当中的一段

126
00:05:08,319 --> 00:05:10,300
你具体给出多少个二进制的一

127
00:05:10,300 --> 00:05:13,420
那么它就是那些一对应的那些位会留下来

128
00:05:13,420 --> 00:05:15,100
其他的东西都拿走了

129
00:05:15,100 --> 00:05:15,939
这是安慰

130
00:05:15,939 --> 00:05:18,569
取余一个竖线呢

131
00:05:18,569 --> 00:05:19,939
这是安慰取货

132
00:05:20,000 --> 00:05:21,589
那么这就是或的意思

133
00:05:21,589 --> 00:05:24,860
这两个数的对应的位上面有一个一结果

134
00:05:24,860 --> 00:05:25,279
就是一

135
00:05:25,279 --> 00:05:28,259
否则的话就是零啊

136
00:05:28,259 --> 00:05:29,819
我们我们也可以再来做一下这个运算

137
00:05:29,819 --> 00:05:33,788
看如果我们有10101010

138
00:05:33,788 --> 00:05:35,918
这就是我刚才说的这个aa啊

139
00:05:35,918 --> 00:05:41,048
它和01010100啊

140
00:05:41,048 --> 00:05:43,079
这个呢是五

141
00:05:44,720 --> 00:05:47,389
如果这两个我们取货

142
00:05:47,389 --> 00:05:50,689
那只要对应的位上面有一的

143
00:05:50,689 --> 00:05:51,589
它就是一了

144
00:05:51,589 --> 00:05:55,670
所以就变成11111110

145
00:05:55,670 --> 00:05:58,490
因为最后这个比特大家都是零啊

146
00:05:58,490 --> 00:06:00,819
那这个呢是就是f1 

147
00:06:01,218 --> 00:06:04,430
所以这就是或运算或运算的

148
00:06:04,430 --> 00:06:06,079
跟这个余运算一样

149
00:06:06,079 --> 00:06:07,220
也常用于两种应用

150
00:06:07,220 --> 00:06:10,279
一种呢我们想使得某个位为一

151
00:06:10,439 --> 00:06:12,660
那么我们就给他换上那个位

152
00:06:12,660 --> 00:06:13,740
上为一的一个数

153
00:06:13,740 --> 00:06:16,019
比如说我们现在x去或0x01 

154
00:06:16,019 --> 00:06:17,819
就意味着我们希望这个数

155
00:06:17,819 --> 00:06:19,908
最右边的那个比特为一

156
00:06:19,908 --> 00:06:21,528
不管它原来是零还是一

157
00:06:21,528 --> 00:06:22,728
我们或上这个东西以后

158
00:06:22,728 --> 00:06:23,920
它一定是一了

159
00:06:23,920 --> 00:06:25,660
你用加做不到这一点对吧

160
00:06:25,660 --> 00:06:26,620
你你给他加一

161
00:06:26,620 --> 00:06:27,339
他可能原来是一

162
00:06:27,339 --> 00:06:28,660
你加一后它就变成零了

163
00:06:28,660 --> 00:06:31,540
所以或一那就是不管它原来是零还是一

164
00:06:31,540 --> 00:06:32,480
他都变成一

165
00:06:32,480 --> 00:06:35,300
还有呢我们可以用它把两个数拼起来

166
00:06:35,300 --> 00:06:39,009
比如说你看00f f和f f001 或

167
00:06:39,009 --> 00:06:41,620
那么这两个f呢用来填充了这个

168
00:06:41,620 --> 00:06:43,269
这两个f呢用填充了这个结果

169
00:06:43,269 --> 00:06:44,470
就是四个f对吧

170
00:06:44,470 --> 00:06:45,779
连x f f f啊

171
00:06:47,439 --> 00:06:49,680
这是安慰取反

172
00:06:50,139 --> 00:06:51,339
安慰取反的意思

173
00:06:51,339 --> 00:06:54,240
就是把他的每一个比特从一变成零

174
00:06:55,079 --> 00:06:58,579
这个和我们去算它的补码是不一样的

175
00:06:58,579 --> 00:07:00,949
我们之前讲过算补码是要做减法对吧

176
00:07:00,949 --> 00:07:03,680
但是安慰取反呢是每一个比特去取反

177
00:07:03,680 --> 00:07:04,879
我们来看一下

178
00:07:05,120 --> 00:07:08,870
如果我有10101010

179
00:07:08,870 --> 00:07:10,160
这是aa

180
00:07:10,240 --> 00:07:13,019
那对他安慰取反的结果

181
00:07:13,079 --> 00:07:15,360
就是每一位都变成翻过来了

182
00:07:15,360 --> 00:07:18,300
零变一一变零一变零零变一一变

183
00:07:18,300 --> 00:07:20,069
零零变一一变零零变一

184
00:07:20,069 --> 00:07:21,220
这就是五五

185
00:07:21,420 --> 00:07:23,339
这叫做安慰取反

186
00:07:23,740 --> 00:07:25,779
但是这和算补码是不一样的

187
00:07:25,779 --> 00:07:26,500
算补码的时候

188
00:07:26,500 --> 00:07:32,269
实际上我们是拿1亿

189
00:07:32,269 --> 00:07:37,230
去减这个10101010

190
00:07:37,230 --> 00:07:38,639
减出来一个结果

191
00:07:38,639 --> 00:07:41,699
这和取补码啊是不同的

192
00:07:41,699 --> 00:07:42,990
这个剪出来呢

193
00:07:42,990 --> 00:07:45,279
这是零一

194
00:07:46,920 --> 00:07:47,720
零

195
00:07:50,759 --> 00:07:55,410
10101啊

196
00:07:55,410 --> 00:07:58,379
这是这个它的补码的形式

197
00:07:58,379 --> 00:08:01,658
这和这个取反啊是不一样的

198
00:08:01,658 --> 00:08:03,399
我们也可以写程序啊

199
00:08:03,399 --> 00:08:06,338
来试验一下这个a a的取反和补码

200
00:08:06,338 --> 00:08:07,560
他们是不是一样的

201
00:08:07,959 --> 00:08:09,399
好我们现在呢是这样

202
00:08:09,399 --> 00:08:11,199
我们做了一个aa啊

203
00:08:11,199 --> 00:08:12,279
我们做了一个aa

204
00:08:12,279 --> 00:08:14,500
然后呢我们先直接输出aa

205
00:08:14,500 --> 00:08:16,060
16进制的形式是吧

206
00:08:16,779 --> 00:08:20,800
另外呢我们算了他的这个去安慰去反

207
00:08:20,800 --> 00:08:23,199
我们也算了它的补码对吧

208
00:08:23,199 --> 00:08:24,430
那他的负数就是补码

209
00:08:24,430 --> 00:08:26,889
但这里面呢有一个问题是这样嗯

210
00:08:26,889 --> 00:08:29,579
这些运算啊做补满也好

211
00:08:29,579 --> 00:08:32,820
也就去减减减做减负副c啊

212
00:08:32,820 --> 00:08:34,769
或者是这个安慰取反

213
00:08:34,769 --> 00:08:37,399
它的运算结果是int

214
00:08:37,399 --> 00:08:41,179
但我们希望看到它是作为一个字符类大小

215
00:08:41,179 --> 00:08:42,440
的一个字节大小的

216
00:08:42,440 --> 00:08:44,549
那么一个那整数来输出啊

217
00:08:44,549 --> 00:08:47,009
所以我们要把它类型转换为char才行

218
00:08:47,009 --> 00:08:48,509
我们看到结果是这样

219
00:08:48,509 --> 00:08:51,369
本来是a a那如果对他取反呢

220
00:08:51,369 --> 00:08:52,089
安慰取反呢

221
00:08:52,089 --> 00:08:54,309
他就是五五每一位都翻过来了

222
00:08:54,309 --> 00:08:57,039
而如果对它取负呢

223
00:08:57,039 --> 00:08:58,750
它是56啊

224
00:08:58,750 --> 00:09:01,269
因为aa其实就是负的56啊

225
00:09:01,269 --> 00:09:04,389
如果把它作为一个呃有符号的char的话

226
00:09:04,389 --> 00:09:05,649
它就是负的56

227
00:09:05,649 --> 00:09:06,940
所以呢对它取负呢

228
00:09:06,940 --> 00:09:08,080
它就是56了

229
00:09:08,080 --> 00:09:09,940
因此我们看到这两个运算它是不一样的

230
00:09:09,940 --> 00:09:12,820
那求补码和这个曲阜啊

231
00:09:12,820 --> 00:09:14,679
求取反它是不一样的

232
00:09:14,679 --> 00:09:17,710
那么我们之前讲的是逻辑运算啊

233
00:09:17,710 --> 00:09:19,958
呃今天我们讲的是安慰的运算

234
00:09:20,740 --> 00:09:22,590
实际上对于逻辑运算来说呢

235
00:09:22,590 --> 00:09:24,600
它只看到整数只有两个值

236
00:09:24,600 --> 00:09:25,259
要么是零

237
00:09:25,259 --> 00:09:27,059
要么是一所有非零的值

238
00:09:27,059 --> 00:09:28,159
它都认为是一

239
00:09:28,159 --> 00:09:30,799
因此我们可以认为说逻辑运算呢

240
00:09:30,799 --> 00:09:34,070
相当于先把所有的非零值都变成一

241
00:09:34,070 --> 00:09:35,909
然后做安慰运算

242
00:09:35,909 --> 00:09:37,950
因为实际上在计算机内部呢

243
00:09:37,950 --> 00:09:39,450
呃只有安慰运算

244
00:09:39,450 --> 00:09:42,330
并没有我们在c语言当中这种逻辑运算啊

245
00:09:42,330 --> 00:09:43,230
没有这种运算

246
00:09:43,230 --> 00:09:45,860
它只有安慰的这种二进制的运算

247
00:09:45,860 --> 00:09:48,440
所以呢如果我们要做五and 4的话呢

248
00:09:48,440 --> 00:09:51,139
我们知道这两个做了鱼以后的结果呢

249
00:09:53,480 --> 00:09:55,240
它的结果是四啊

250
00:09:55,240 --> 00:09:56,440
呃我们不去展开了哈

251
00:09:56,440 --> 00:09:57,700
大家大家时间关系

252
00:09:57,700 --> 00:09:58,240
我们不展开

253
00:09:58,240 --> 00:10:00,870
大家可以自己去在纸上演算一下

254
00:10:00,870 --> 00:10:04,179
为什么五和四取了鱼以后就变成四了啊

255
00:10:04,580 --> 00:10:08,899
而如果五和四做逻辑运算的话呢

256
00:10:08,899 --> 00:10:11,658
相当于先把这两个数字都变成一

257
00:10:11,658 --> 00:10:14,639
所以就变成一和一再去做余的运算

258
00:10:14,639 --> 00:10:17,129
结果呢最后就是一了啊

259
00:10:17,129 --> 00:10:19,318
那五和四或一下呢

260
00:10:19,480 --> 00:10:21,789
五和四对应的位置上或一下呢

261
00:10:21,789 --> 00:10:23,169
结果就变成五了

262
00:10:23,169 --> 00:10:26,889
而五和四做一下逻辑或呢两个竖线啊

263
00:10:26,889 --> 00:10:30,370
那就变成他就认为是两个一去做逻辑或

264
00:10:30,370 --> 00:10:33,529
结果呢就是呃两个一去做安慰货啊

265
00:10:33,529 --> 00:10:34,850
那么结果呢就是一个一

266
00:10:35,929 --> 00:10:39,078
而这个对四取反呢

267
00:10:39,299 --> 00:10:41,340
它是它的结果是三啊

268
00:10:41,340 --> 00:10:42,899
因为四是100

269
00:10:42,899 --> 00:10:45,419
那么安慰去反应这边011了

270
00:10:45,419 --> 00:10:46,450
零一就是三

271
00:10:46,450 --> 00:10:50,409
那么而对四取逻辑的反呢

272
00:10:50,409 --> 00:10:53,289
这个它相当于对一去做逻辑的反

273
00:10:53,289 --> 00:10:54,659
那么结果呢是个零

274
00:10:54,659 --> 00:10:57,690
所以逻辑运算和安慰运算是不一样的

275
00:10:57,690 --> 00:11:00,059
初学者在这件事情上面呢很容易出错

276
00:11:00,059 --> 00:11:01,720
很容易犯错啊

277
00:11:01,720 --> 00:11:04,970
这个呃他可能会知道说哦

278
00:11:04,970 --> 00:11:06,350
and符号表示鱼

279
00:11:06,350 --> 00:11:09,318
然后呢在做逻辑上的时候放了一个

280
00:11:09,740 --> 00:11:11,210
而不是放了两个

281
00:11:11,210 --> 00:11:13,220
那么这个时候呢它的结果

282
00:11:13,220 --> 00:11:15,019
它的意义就会是不一样的

283
00:11:16,799 --> 00:11:18,860
这个符号叫做安慰

284
00:11:18,860 --> 00:11:22,299
抑或在有的编程语言

285
00:11:22,299 --> 00:11:24,159
比如像pasco这样的编程语言当中的

286
00:11:24,159 --> 00:11:25,779
这个符号表示幂次

287
00:11:25,779 --> 00:11:26,860
但是在c语言当中

288
00:11:26,860 --> 00:11:29,000
我们没有用来表示幂次的运算符

289
00:11:29,000 --> 00:11:30,559
而这个符号是表示安慰

290
00:11:30,559 --> 00:11:32,269
抑或他的意思是说

291
00:11:32,269 --> 00:11:33,679
如果两个位相等

292
00:11:33,679 --> 00:11:34,820
那么结果为零

293
00:11:34,820 --> 00:11:35,840
两个位不相等

294
00:11:35,840 --> 00:11:37,000
结果为一

295
00:11:37,600 --> 00:11:38,940
我们来看一下

296
00:11:38,940 --> 00:11:41,039
如果我们现在有101

297
00:11:41,039 --> 00:11:47,259
10100和01001011

298
00:11:47,259 --> 00:11:49,240
去做易货的预算

299
00:11:50,379 --> 00:11:52,740
那么这个时候呢他的意思是说

300
00:11:52,740 --> 00:11:56,120
如果这两位是不相等的

301
00:11:56,120 --> 00:11:58,009
结果就是一不相等的

302
00:11:58,009 --> 00:11:59,090
结果是一不相等的

303
00:11:59,090 --> 00:11:59,870
结果是一不相等的

304
00:11:59,870 --> 00:12:00,740
结果是一结果

305
00:12:00,740 --> 00:12:01,429
结果呢

306
00:12:01,429 --> 00:12:04,169
所以这两个数因为每一位都不相等

307
00:12:04,169 --> 00:12:07,450
所以呢他们的结果就是全一了

308
00:12:07,450 --> 00:12:09,070
假如说我改一改

309
00:12:09,070 --> 00:12:11,710
说哎这个东西呢它们是相等的

310
00:12:11,710 --> 00:12:13,210
这一位上面它们是相等的

311
00:12:13,210 --> 00:12:15,159
那么这一位他就要变成零了

312
00:12:15,159 --> 00:12:17,080
如果我把这个改成一

313
00:12:17,080 --> 00:12:19,000
那就是这一位上它们是相等的

314
00:12:19,000 --> 00:12:21,820
那么这一位他们就是零了啊

315
00:12:21,820 --> 00:12:24,458
所以这是做异或的运算

316
00:12:27,539 --> 00:12:30,019
这个异或的运算呢有一个有意思的地方

317
00:12:30,019 --> 00:12:32,330
你看我现在得到这个结果了对吧

318
00:12:32,330 --> 00:12:37,808
我再拿它和01100011去做异或

319
00:12:37,808 --> 00:12:40,149
也就是这个数再翻下来做一下

320
00:12:40,149 --> 00:12:42,679
抑或变成什么呢

321
00:12:42,679 --> 00:12:43,940
这两个不相等

322
00:12:43,940 --> 00:12:45,440
一相等

323
00:12:45,440 --> 00:12:46,460
零不相等

324
00:12:46,460 --> 00:12:48,679
一不相等于相等

325
00:12:48,679 --> 00:12:50,179
零不相等

326
00:12:50,179 --> 00:12:51,559
一相等相等

327
00:12:51,559 --> 00:12:53,500
你看这是什么

328
00:12:53,500 --> 00:12:55,419
10110100

329
00:12:55,419 --> 00:12:57,460
就是我们的一开始的那个数

330
00:12:57,460 --> 00:12:59,279
10110100

331
00:12:59,759 --> 00:13:03,360
对一个数做了一遍异或得到了这个结果

332
00:13:03,360 --> 00:13:05,159
用同样的数再做一遍

333
00:13:05,159 --> 00:13:07,019
异或就翻回去了

334
00:13:07,860 --> 00:13:10,220
这就是异或的有意思的地方

335
00:13:10,220 --> 00:13:14,509
那用这个呢可以做一个有趣的加密运算

336
00:13:14,509 --> 00:13:16,720
我拿一个马

337
00:13:16,720 --> 00:13:20,320
拿一个编码对对这个所有的这字符串当中

338
00:13:20,320 --> 00:13:22,259
所有的字符做一遍异或运算

339
00:13:22,259 --> 00:13:23,759
做完以后得到一遍

340
00:13:23,759 --> 00:13:25,649
得到一些乱七八糟的东西

341
00:13:25,649 --> 00:13:28,820
然后接收到这一堆乱七八糟

342
00:13:28,820 --> 00:13:30,620
加密以后的东西的那一方呢

343
00:13:30,620 --> 00:13:33,860
只要再拿同样的这个编码去做一遍疑惑

344
00:13:33,860 --> 00:13:35,659
就可以得到有意义的结果了

345
00:13:35,659 --> 00:13:38,539
但这是一个非常弱的加密方法是吧

346
00:13:38,539 --> 00:13:40,370
既然大家都知道了啊

347
00:13:40,370 --> 00:13:42,110
另外如果两个数是相等的

348
00:13:42,110 --> 00:13:44,539
那么做一遍异或的结果呢就会是零

349
00:13:44,539 --> 00:13:46,370
我们也可以用这个方式来判断

350
00:13:46,370 --> 00:13:47,980
两个数是否相等啊

351
00:13:47,980 --> 00:13:49,480
当然从c语言的角度

352
00:13:49,480 --> 00:13:50,860
我们没有这个必要是吧

353
00:13:50,860 --> 00:13:52,480
我们直接写x等于等于y

354
00:13:52,480 --> 00:13:53,620
就可以得到运算结果

355
00:13:53,620 --> 00:13:55,960
至于说编译器给你产生的代码

356
00:13:55,960 --> 00:13:58,000
实际上在用这个cpu里头

357
00:13:58,000 --> 00:13:59,559
一条什么样的汇编指令

358
00:13:59,559 --> 00:14:00,759
在执行这个机器指令

359
00:14:00,759 --> 00:14:01,659
在执行这个事情

360
00:14:01,659 --> 00:14:03,279
其实跟我们没有关系啊

361
00:14:03,279 --> 00:14:04,600
但我们需要知道说

362
00:14:04,600 --> 00:14:06,100
抑或可以用来做这样的事情

