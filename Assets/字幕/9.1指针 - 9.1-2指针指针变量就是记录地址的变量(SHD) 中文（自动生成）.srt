1
00:00:04,519 --> 00:00:07,710
前面看了前面看的取地址符这么多

2
00:00:07,710 --> 00:00:09,720
便便画画可以取这个

3
00:00:09,720 --> 00:00:11,849
可以取那个可以看起来很有趣

4
00:00:11,849 --> 00:00:13,859
我可以看到数组里面那些变量的地址

5
00:00:13,859 --> 00:00:16,620
那些单元的地址是怎么怎么怎么排列的

6
00:00:17,480 --> 00:00:18,640
有什么用呢

7
00:00:19,339 --> 00:00:20,980
我们我们只要拿它做点事情

8
00:00:20,980 --> 00:00:21,550
对不对

9
00:00:21,550 --> 00:00:25,300
如果我们能够取得一个变量的地址

10
00:00:25,300 --> 00:00:28,530
然后把这个地址呢作为一个值

11
00:00:28,530 --> 00:00:30,839
传给某个函数

12
00:00:31,059 --> 00:00:33,280
那么在那个函数里面

13
00:00:33,280 --> 00:00:35,020
能不能通过这个地址

14
00:00:35,020 --> 00:00:37,039
访问到外面的那个变量

15
00:00:37,759 --> 00:00:39,820
你想我们scaf怎么做事情呢

16
00:00:41,259 --> 00:00:42,640
caf也就是一个函数

17
00:00:42,640 --> 00:00:43,320
对不对

18
00:00:44,039 --> 00:00:48,799
学计算机一定要有一个非常强大的心理状

19
00:00:48,799 --> 00:00:49,310
态

20
00:00:49,310 --> 00:00:50,378
什么呢

21
00:00:50,479 --> 00:00:54,219
计算机的所有东西都是人做出来的

22
00:00:54,780 --> 00:00:56,490
别人能想得出来的

23
00:00:56,490 --> 00:00:58,229
我也一定能想得出来

24
00:00:58,229 --> 00:01:01,719
在计算机里头没有任何黑魔法

25
00:01:01,939 --> 00:01:05,780
所有的东西只不过是我现在不知道而已

26
00:01:06,239 --> 00:01:08,849
总有一天我会把所有的细节

27
00:01:08,849 --> 00:01:11,420
所有的内部的东西全都搞明白了

28
00:01:11,579 --> 00:01:14,340
那个scaf里面到底怎么做事情的

29
00:01:16,230 --> 00:01:17,819
我们还没有来得及去看

30
00:01:17,819 --> 00:01:20,079
caf的原始的代码是怎么样的

31
00:01:20,079 --> 00:01:21,489
cafe也不过是个函数

32
00:01:21,489 --> 00:01:23,819
也不过是某个人给他写出来的

33
00:01:24,099 --> 00:01:25,540
那个人和我们一样

34
00:01:25,540 --> 00:01:26,920
同样只是一个脑袋而已

35
00:01:28,599 --> 00:01:32,129
所以也就是一个c语言的函数

36
00:01:33,659 --> 00:01:37,019
他一定用的也不过就是c语言所提供给我

37
00:01:37,019 --> 00:01:38,638
们的那些手段而已

38
00:01:38,638 --> 00:01:40,228
我们在caf的时候

39
00:01:40,228 --> 00:01:42,370
传给他了一个变量的地址

40
00:01:42,370 --> 00:01:43,840
再次跟f里头

41
00:01:43,840 --> 00:01:46,599
他就有办法拿我们传进去的这个地址

42
00:01:46,599 --> 00:01:49,329
把它从输入标准输入里面

43
00:01:49,329 --> 00:01:51,179
分析出来的那个整数

44
00:01:51,239 --> 00:01:52,500
那个double

45
00:01:54,219 --> 00:01:57,819
放到我们所指定的那个变量的里头去

46
00:01:57,819 --> 00:02:00,200
这件事情他是怎么做的

47
00:02:01,040 --> 00:02:04,450
我们能不能照着这个样子做

48
00:02:04,450 --> 00:02:06,259
做我们自己的东西

49
00:02:08,419 --> 00:02:11,758
所以caf里头一定有一个办法

50
00:02:11,758 --> 00:02:14,068
它的函数原型里头一定有一个办法

51
00:02:14,068 --> 00:02:16,550
可以接收到这个地址

52
00:02:16,550 --> 00:02:17,750
我们前面试过

53
00:02:17,750 --> 00:02:19,849
如果你把这个地址交给一个整数

54
00:02:19,849 --> 00:02:21,210
这事情不靠谱

55
00:02:21,210 --> 00:02:25,860
因为整数和地址不见得永远是相同的类型

56
00:02:25,860 --> 00:02:30,139
那么什么样的类型可以接收取地址

57
00:02:30,139 --> 00:02:31,219
得到的那个地址呢

58
00:02:33,979 --> 00:02:38,289
指针一个指针类型的变量

59
00:02:38,289 --> 00:02:40,800
就是保存地址的变量

60
00:02:40,800 --> 00:02:42,900
就是保存那个and的取地址符

61
00:02:42,900 --> 00:02:46,020
得到的其他变量的地址的那么一个变量

62
00:02:46,639 --> 00:02:50,000
所以如果你看我们有int i

63
00:02:50,000 --> 00:02:52,319
我们就可以做出一个int*p

64
00:02:52,319 --> 00:02:56,219
这个星号在这儿表示的意思是说p是什么

65
00:02:56,219 --> 00:02:57,699
p是一个指针

66
00:02:57,699 --> 00:03:00,219
我们通常会用p来表示一个指针

67
00:03:00,219 --> 00:03:03,129
因为这是英文pointer的第一个字母

68
00:03:03,129 --> 00:03:05,199
所以这是一个指针

69
00:03:05,618 --> 00:03:08,579
这个新表示说p是一个指针

70
00:03:08,579 --> 00:03:11,639
它指向的是一个int

71
00:03:11,639 --> 00:03:15,699
现在呢我们把这个i的地址交给了这个p

72
00:03:16,959 --> 00:03:19,118
所以这个时候发生的是什么呢

73
00:03:19,118 --> 00:03:22,120
我们原本呢有一个变量i

74
00:03:23,300 --> 00:03:25,539
现在呢我们又有了一个变量

75
00:03:25,539 --> 00:03:29,110
p这个p这个变量是一个指针

76
00:03:29,110 --> 00:03:30,819
它里面获得的值是什么

77
00:03:30,819 --> 00:03:31,569
i的地址

78
00:03:31,569 --> 00:03:35,439
比如说i放在0x2000 的地方

79
00:03:35,439 --> 00:03:38,180
ok那p就得到那个值2000

80
00:03:38,740 --> 00:03:39,990
在这种情况下

81
00:03:39,990 --> 00:03:44,060
我们就有一个说法说p呢指向了i

82
00:03:44,439 --> 00:03:46,599
所以当我们在说p指向i的时候

83
00:03:46,599 --> 00:03:49,659
我们实际的意思就是p里面的值呢

84
00:03:49,659 --> 00:03:52,030
就是i那个变量的地址

85
00:03:52,030 --> 00:03:54,770
这个时候我们就说p指向来

86
00:03:54,770 --> 00:03:59,060
在下面这两行当中有小细节要小心

87
00:03:59,060 --> 00:04:01,949
这个型号它可以靠近int

88
00:04:01,949 --> 00:04:05,979
它也可以远离int靠近变量

89
00:04:05,979 --> 00:04:08,080
但是在这两行当中

90
00:04:08,080 --> 00:04:09,699
他们的说法是一样的

91
00:04:09,699 --> 00:04:11,020
他们的意思是一样的

92
00:04:11,020 --> 00:04:15,270
他们都表示说他们都表示说p是一个指针

93
00:04:15,270 --> 00:04:16,649
指向一个int

94
00:04:16,649 --> 00:04:18,060
而q是什么

95
00:04:18,060 --> 00:04:21,740
q只是一个普通的int类型的变量

96
00:04:22,139 --> 00:04:23,879
所以换句话说

97
00:04:23,879 --> 00:04:27,779
我们并不是把星号加给了int

98
00:04:27,779 --> 00:04:30,120
我们是把星号加给了p

99
00:04:30,120 --> 00:04:33,120
我们说新p是一个int

100
00:04:33,360 --> 00:04:35,519
于是p是一个指针了

101
00:04:35,519 --> 00:04:39,620
而并不是说p是int星这种类型

102
00:04:40,339 --> 00:04:41,980
所以在c语言来说

103
00:04:41,980 --> 00:04:43,899
我们并没有int新这种类型

104
00:04:43,899 --> 00:04:46,879
我们只是说新p是一个int

105
00:04:49,699 --> 00:04:51,158
它的意思都是一样的

106
00:04:51,158 --> 00:04:52,778
这是初学者很容易犯的错误

107
00:04:52,778 --> 00:04:54,379
他会以为我这么写

108
00:04:54,379 --> 00:04:56,870
q就也是一个指针了不对

109
00:04:56,870 --> 00:04:59,240
如果你想要表达p和q都是指针

110
00:04:59,240 --> 00:05:00,139
你该怎么写

111
00:05:00,139 --> 00:05:02,399
在这还需要有信号

112
00:05:04,980 --> 00:05:09,220
所以我们有了指针类型的变量

113
00:05:09,220 --> 00:05:11,439
在指针类型的变量里面放的实际上是地址

114
00:05:11,439 --> 00:05:13,600
所以它里面的地址会指向

115
00:05:13,600 --> 00:05:15,370
另外一个实际的变量

116
00:05:15,370 --> 00:05:17,850
普通的变量不是指针类型的变量

117
00:05:17,850 --> 00:05:18,730
图中的变量

118
00:05:18,730 --> 00:05:21,490
它里面放的内容就是实际的值

119
00:05:21,490 --> 00:05:24,550
在指针变量里头不会放实际的值

120
00:05:24,550 --> 00:05:27,000
我们只会放别的变量的

121
00:05:27,379 --> 00:05:31,639
int新pp里面只会有别的整数的地址

122
00:05:33,480 --> 00:05:37,519
那当我们把一个指针作为参数的时候

123
00:05:37,519 --> 00:05:38,660
我们就可以这样写

124
00:05:38,660 --> 00:05:42,259
说我的f函数要一个int的指针

125
00:05:42,360 --> 00:05:44,970
那么当我们去调用这个f函数的时候

126
00:05:44,970 --> 00:05:47,899
我们就要交给他一个地址

127
00:05:47,899 --> 00:05:50,860
而不能交给他那个变量本身

128
00:05:50,860 --> 00:05:53,079
或者交给他那个变量的值

129
00:05:53,079 --> 00:05:56,589
我们必须用n的符号取得某个变量的地址

130
00:05:56,589 --> 00:05:59,860
把这个地址传给这个指针

131
00:05:59,860 --> 00:06:01,420
我们来试一下这件事情

132
00:06:01,420 --> 00:06:04,480
我们有在in里面有一个i的变量

133
00:06:04,480 --> 00:06:06,339
那我们可以在main里面来看一下

134
00:06:06,339 --> 00:06:09,620
说这个i的地址是多少

135
00:06:09,680 --> 00:06:13,850
然后呢我们把这个i的地址取出来

136
00:06:13,850 --> 00:06:15,300
交给f函数

137
00:06:15,560 --> 00:06:17,480
在f函数里面呢

138
00:06:17,480 --> 00:06:18,920
他给我们看一下

139
00:06:18,920 --> 00:06:21,879
说现在呢这个p等于多少

140
00:06:22,158 --> 00:06:25,819
然后呢我们可以看一下这两个值是否相等

141
00:06:27,120 --> 00:06:28,279
这是我们运行的结果

142
00:06:28,279 --> 00:06:29,839
我们看到在main里面呢

143
00:06:29,839 --> 00:06:32,019
i的地址是七零

144
00:06:32,139 --> 00:06:34,779
我们把这个地址取出来传给f函数

145
00:06:34,779 --> 00:06:36,339
那么到了f函数里面呢

146
00:06:36,339 --> 00:06:38,529
这个地址也是七零

147
00:06:38,529 --> 00:06:40,639
所以这就意味着什么呢

148
00:06:40,860 --> 00:06:45,089
在main里头我们有一个变量i它里面放了六

149
00:06:45,089 --> 00:06:46,779
它的地址是七零

150
00:06:46,819 --> 00:06:49,168
然后我们把这个地址取出来

151
00:06:49,168 --> 00:06:53,069
交给了另外一个f函数里面的一个变量

152
00:06:53,069 --> 00:06:56,839
叫做p这个p呢它的值是七零

153
00:06:57,000 --> 00:06:59,670
于是我们就可以说p是一个指针

154
00:06:59,670 --> 00:07:02,139
它指向了i这个变量

155
00:07:02,939 --> 00:07:05,050
那么有了这件事情之后

156
00:07:05,050 --> 00:07:06,430
有了这件事情之后

157
00:07:06,430 --> 00:07:08,589
就意味着在f函数里面

158
00:07:08,589 --> 00:07:13,600
我们有外面的妹里面的那个i的地址了

159
00:07:14,038 --> 00:07:15,598
我们不知道它叫做i

160
00:07:16,678 --> 00:07:18,459
但是我们有他的地址了

161
00:07:18,579 --> 00:07:21,579
如果不是这样子传一个地址进去

162
00:07:21,579 --> 00:07:23,079
我们只能得到它的值

163
00:07:23,079 --> 00:07:25,500
如果如果我们另外有一个g函数

164
00:07:25,500 --> 00:07:27,180
这个函数要一个整数作为输入

165
00:07:27,180 --> 00:07:29,699
然后我们把i传给这个g函数

166
00:07:29,699 --> 00:07:31,230
那在这个过程当中

167
00:07:31,230 --> 00:07:35,100
我们在g里面得到的只是i的值

168
00:07:35,180 --> 00:07:36,970
也就是说在这个地方

169
00:07:36,970 --> 00:07:38,410
在g函数里面

170
00:07:38,410 --> 00:07:40,180
我们的那个k那个变量

171
00:07:40,180 --> 00:07:42,069
他拿到的只是i的值

172
00:07:42,069 --> 00:07:45,430
那个六它和外面的i之间没有任何关系

173
00:07:45,430 --> 00:07:47,968
这是我们之前学函数的时候学到的

174
00:07:47,968 --> 00:07:50,908
现在我们通过这个指针变量

175
00:07:50,908 --> 00:07:53,740
通过这个p我们得到了i的地址

176
00:07:53,740 --> 00:07:57,009
这使得f函数里面拥有

177
00:07:57,009 --> 00:07:59,990
能够访问外面那个i的能力了

178
00:07:59,990 --> 00:08:01,970
那么怎么访问他的

179
00:08:03,230 --> 00:08:07,480
访问意味着读或者写都是访问

180
00:08:07,480 --> 00:08:09,250
我们要读到六这个值写呢

181
00:08:09,250 --> 00:08:12,519
我们想要改那个i的变量的值怎么做

182
00:08:12,519 --> 00:08:14,360
如果你有了一个地址

183
00:08:14,360 --> 00:08:17,000
你想访问那个地址上的变量

184
00:08:17,000 --> 00:08:19,310
那么我们要用一个运算符

185
00:08:19,310 --> 00:08:21,910
就是这个信号信号不是一个新的运算符

186
00:08:21,910 --> 00:08:22,209
对不对

187
00:08:22,209 --> 00:08:23,829
我们知道我们做乘法的时候

188
00:08:23,829 --> 00:08:25,480
我们用星号来表达乘法

189
00:08:25,480 --> 00:08:27,910
现在呢我们要用这个型号

190
00:08:27,910 --> 00:08:29,560
把它当做一个新的运算符

191
00:08:29,560 --> 00:08:32,950
一个弹幕的运算符只有一个算子的

192
00:08:32,950 --> 00:08:35,259
我们用它来访问指针的值

193
00:08:35,259 --> 00:08:37,259
所表示的那个地址

194
00:08:37,259 --> 00:08:38,820
在那个地址上的那个变量

195
00:08:40,139 --> 00:08:43,789
那么我们用新号加上那个指针

196
00:08:43,789 --> 00:08:45,370
得到那个变量之后呢

197
00:08:45,370 --> 00:08:47,899
这个变量可以拿来做左值

198
00:08:47,899 --> 00:08:49,399
也可以拿来做右值

199
00:08:49,399 --> 00:08:51,980
也就是说它可以放在辅之号的右边

200
00:08:51,980 --> 00:08:53,000
我们去读它的值

201
00:08:53,000 --> 00:08:54,529
也可以放在辅之号的左边

202
00:08:54,529 --> 00:08:55,839
我们去写它的值

203
00:08:55,839 --> 00:08:57,698
我们来试试看这事儿怎么做

204
00:08:57,698 --> 00:09:00,519
我们在f里头得到了这个地址

205
00:09:00,519 --> 00:09:02,198
那我们可以试试看

206
00:09:02,198 --> 00:09:07,029
我们现在来输出说这个新p等于多少

207
00:09:07,029 --> 00:09:08,169
既然它是一个整数

208
00:09:08,169 --> 00:09:10,979
我们用百分号d我们来输出新p

209
00:09:11,460 --> 00:09:13,139
在这里你要有一个概念

210
00:09:13,139 --> 00:09:18,559
是说当我星号和指针变量联系在一起以后

211
00:09:18,559 --> 00:09:22,620
新p这个整体你可以把它看作是一个整数

212
00:09:22,700 --> 00:09:24,259
因为我们前面在说

213
00:09:24,259 --> 00:09:26,299
你看新p作为一个整体

214
00:09:26,299 --> 00:09:27,350
它是一个整数

215
00:09:27,350 --> 00:09:28,220
不就这个意思嘛

216
00:09:28,220 --> 00:09:28,730
对不对

217
00:09:28,730 --> 00:09:31,129
就好像说我们当时讲数组的时候

218
00:09:31,129 --> 00:09:32,299
你有了一个数组

219
00:09:32,299 --> 00:09:34,070
那么数组当中的某个单元

220
00:09:34,070 --> 00:09:34,820
比如说a0 

221
00:09:34,820 --> 00:09:36,309
你可以把它作为一个整体

222
00:09:36,309 --> 00:09:37,509
看作是一个int

223
00:09:37,509 --> 00:09:38,350
这是一个意思

224
00:09:38,350 --> 00:09:40,330
所以现在我们把新p作为一个整体

225
00:09:40,330 --> 00:09:41,110
当做是一个整数

226
00:09:41,110 --> 00:09:42,539
我们来说说这个整数的值

227
00:09:42,539 --> 00:09:44,399
我们先来试这件事情行不行

228
00:09:45,600 --> 00:09:48,259
我们运行的结果说新key等于六

229
00:09:49,440 --> 00:09:50,299
看到没有

230
00:09:50,299 --> 00:09:51,458
cp等于六

231
00:09:51,580 --> 00:09:54,820
所以这就意味着通过p这个指针

232
00:09:54,820 --> 00:10:00,019
我们访问到了p所指的那个int i里面的值

233
00:10:00,019 --> 00:10:01,009
我们进一步

234
00:10:01,009 --> 00:10:03,578
接下来还要再做更加邪恶的事情

235
00:10:04,639 --> 00:10:09,100
我们让这个新p等于一个值

236
00:10:09,100 --> 00:10:13,610
比如说26做完这件事情以后

237
00:10:13,610 --> 00:10:16,419
i的值会不会被改变呢

238
00:10:16,419 --> 00:10:18,370
如果i的值被改了

239
00:10:18,370 --> 00:10:21,039
我们知道接下去我们要去调集函数

240
00:10:21,039 --> 00:10:22,360
我们要把i传过去

241
00:10:22,360 --> 00:10:23,980
集函数会替我们输出

242
00:10:23,980 --> 00:10:26,840
说那个i现在的值是多少

243
00:10:26,840 --> 00:10:28,399
我们来试一下这个代码

244
00:10:30,000 --> 00:10:32,859
你看他说k等于26了

245
00:10:33,059 --> 00:10:34,139
k等于26

246
00:10:34,139 --> 00:10:34,799
意味着什么

247
00:10:34,799 --> 00:10:37,889
意味着在经历了f函数的调用之后

248
00:10:37,889 --> 00:10:40,219
i的值被改了

249
00:10:41,200 --> 00:10:42,480
我们在讲函数的时候

250
00:10:42,480 --> 00:10:46,490
一再再说c语言的函数调用的时候

251
00:10:46,490 --> 00:10:48,230
发生的参数的转移

252
00:10:48,230 --> 00:10:50,110
那是一种值得传递

253
00:10:50,110 --> 00:10:52,539
我们把值传进了函数

254
00:10:52,539 --> 00:10:53,860
所以在函数里面

255
00:10:53,860 --> 00:10:55,809
函数的参数和调用

256
00:10:55,809 --> 00:10:57,919
它的地方没有任何的联系

257
00:10:57,919 --> 00:11:01,240
现在情况有点不一样

258
00:11:01,940 --> 00:11:03,639
我们仍然坚持说

259
00:11:03,639 --> 00:11:06,399
在这个时候发生的是值的传递

260
00:11:06,399 --> 00:11:11,179
因为你看这是我们这个值这个地址值

261
00:11:11,299 --> 00:11:14,600
这个地址值被传进了函数

262
00:11:14,600 --> 00:11:16,460
所以这仍然是值得传递

263
00:11:16,460 --> 00:11:18,500
但是因为传进来的是地址

264
00:11:18,500 --> 00:11:21,629
所以通过这个地址在函数内部

265
00:11:21,629 --> 00:11:24,690
我们可以以这种方式去访问到

266
00:11:24,690 --> 00:11:26,490
外面的这个i变量

267
00:11:26,490 --> 00:11:30,269
因为p的地址p的值就是i的地址

268
00:11:30,269 --> 00:11:32,730
新p就代表了那个i

269
00:11:32,730 --> 00:11:35,610
所以这样子我们就可以去修改这个i

270
00:11:35,610 --> 00:11:37,259
当我们在做这个运算的时候

271
00:11:37,259 --> 00:11:38,370
cp等于26

272
00:11:38,370 --> 00:11:41,740
我们实际做的事情是对这个i去做的

273
00:11:43,299 --> 00:11:44,470
这就是指针

274
00:11:44,470 --> 00:11:47,279
顺便说这是打信号的内容了

275
00:11:47,279 --> 00:11:49,159
左直为什么叫做左值

276
00:11:49,159 --> 00:11:52,850
是因为出现在复制号左边的不是变量

277
00:11:52,850 --> 00:11:55,220
而是值是表达式计算的结果

278
00:11:55,220 --> 00:11:58,399
你看新p新是个运算符

279
00:11:58,399 --> 00:12:02,120
新p表示说我要取得p这个指针

280
00:12:02,120 --> 00:12:05,779
它的地址代表的那个变量

281
00:12:05,779 --> 00:12:07,700
所以这是表达式运算的结果

282
00:12:07,700 --> 00:12:10,639
但是运算的结果可以放在复制号的左边

283
00:12:10,639 --> 00:12:14,740
来接收一个值数组那个方括号

284
00:12:14,740 --> 00:12:16,570
方括号也是一个运算符

285
00:12:16,570 --> 00:12:19,370
这是取下标的运算符

286
00:12:19,370 --> 00:12:20,700
取单元的运算符

287
00:12:20,700 --> 00:12:22,529
a的方括号0=2

288
00:12:22,529 --> 00:12:24,779
这也是一个左边a方括号零

289
00:12:24,779 --> 00:12:25,710
这也是个运算

290
00:12:25,710 --> 00:12:27,000
这是运算的结果

291
00:12:27,000 --> 00:12:29,399
这个运算的结果放在符号的左边

292
00:12:29,419 --> 00:12:30,769
它可以接收值

293
00:12:30,769 --> 00:12:33,818
所以为什么我们要叫左值

294
00:12:33,818 --> 00:12:37,089
而不是说在在复制号的左边必须是个变量

295
00:12:37,089 --> 00:12:38,798
因为a0 不是变量

296
00:12:38,798 --> 00:12:40,178
新p也不是变量

297
00:12:40,178 --> 00:12:42,309
它们是表达式运算的结果

298
00:12:42,309 --> 00:12:46,019
所以我们我们要说在复制号的左边是左直

299
00:12:46,019 --> 00:12:47,820
在腐蚀号的右边是右值

300
00:12:47,820 --> 00:12:48,600
这是值

301
00:12:48,600 --> 00:12:49,869
这不是变量

302
00:12:49,869 --> 00:12:52,629
现在我们看了指针的两个运算符

303
00:12:52,629 --> 00:12:53,859
一个是取地址

304
00:12:53,859 --> 00:12:58,080
一个是这个取得这个地址

305
00:12:58,080 --> 00:12:59,250
所代表的那个变量

306
00:12:59,250 --> 00:13:02,759
因此这两个运算符是互相颠倒的

307
00:13:02,759 --> 00:13:04,139
互相反作用的

308
00:13:04,299 --> 00:13:06,979
如果你你对一个取得的地址

309
00:13:07,200 --> 00:13:09,480
去取它所代表的那个变量

310
00:13:09,480 --> 00:13:11,669
那就是原来的那个变量

311
00:13:11,669 --> 00:13:15,460
如果你对一个指针所指的那个变量

312
00:13:15,460 --> 00:13:16,299
再去取地址

313
00:13:16,299 --> 00:13:17,818
那就是原来那个指针

314
00:13:20,159 --> 00:13:25,240
那当我们在之前有有些同学发现

315
00:13:25,240 --> 00:13:27,559
说我做skin f的时候

316
00:13:28,299 --> 00:13:29,940
我忘了那个and符号

317
00:13:31,019 --> 00:13:32,859
可是编译器没有报错

318
00:13:33,159 --> 00:13:35,080
但是我运行的时候就错了

319
00:13:35,080 --> 00:13:36,120
为什么

320
00:13:36,399 --> 00:13:38,169
因为你忘了那个and符号

321
00:13:38,169 --> 00:13:39,919
然后你正好又是个整数

322
00:13:40,100 --> 00:13:42,799
然后正好你是32位的架构的话

323
00:13:42,799 --> 00:13:45,710
整数和你的地址是一样大的

324
00:13:45,710 --> 00:13:47,090
和你把一个整数传进去

325
00:13:47,090 --> 00:13:48,529
和你把一个地址传进去

326
00:13:49,610 --> 00:13:50,799
他没看出区别来

327
00:13:50,799 --> 00:13:53,919
他以为你传进去的i是i的地址

328
00:13:53,919 --> 00:13:55,360
他以为你传进去了

329
00:13:55,360 --> 00:13:58,090
0x b f什么什么什么七零那个东西

330
00:13:58,090 --> 00:13:59,620
其实你传进去的是六

331
00:13:59,620 --> 00:14:00,490
他不知道

332
00:14:00,490 --> 00:14:02,049
他以为六是一个地址

333
00:14:02,049 --> 00:14:04,179
然后拿那个地址来做事情了

334
00:14:04,480 --> 00:14:07,210
所以编译不见得会报错

335
00:14:07,210 --> 00:14:10,120
但是运行一定会出错

336
00:14:10,120 --> 00:14:11,590
运行一定会出错

337
00:14:11,590 --> 00:14:16,190
是因为scaf它读进来的那个数字

338
00:14:16,190 --> 00:14:17,779
写到了不该写的地方

339
00:14:17,779 --> 00:14:19,440
他没有写到你的i里头去

340
00:14:19,440 --> 00:14:20,580
他写到了一个

341
00:14:20,580 --> 00:14:21,360
比如说i等于六的话

342
00:14:21,360 --> 00:14:22,740
写到那个六那个地方去了

343
00:14:22,740 --> 00:14:24,240
六那个地方很小

344
00:14:24,620 --> 00:14:26,090
是不能写的

345
00:14:26,090 --> 00:14:27,899
那个地方有很重要的东西

