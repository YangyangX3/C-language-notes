1
00:00:04,559 --> 00:00:05,580
我们知道在c语言当中

2
00:00:05,580 --> 00:00:06,900
我们可以做四则运算

3
00:00:06,900 --> 00:00:07,919
加减乘除

4
00:00:07,919 --> 00:00:09,630
我们可以做关系运算

5
00:00:09,630 --> 00:00:11,720
大于小于等于不等于

6
00:00:12,160 --> 00:00:14,109
除了这两种运算之外

7
00:00:14,109 --> 00:00:16,059
我们还有赋值运算啊

8
00:00:16,059 --> 00:00:16,960
这也是一种运算

9
00:00:16,960 --> 00:00:17,559
对不对啊

10
00:00:17,559 --> 00:00:19,219
a等于b这是运算

11
00:00:19,399 --> 00:00:20,600
除了这三种之外

12
00:00:20,600 --> 00:00:22,379
我们还有逻辑运算

13
00:00:23,059 --> 00:00:26,410
逻辑运算是对逻辑量去进行的运算

14
00:00:26,410 --> 00:00:29,390
它的结果呢只有零或者一

15
00:00:29,390 --> 00:00:30,530
而逻辑量

16
00:00:30,530 --> 00:00:33,558
它是关系运算或者逻辑运算的结果

17
00:00:33,600 --> 00:00:36,179
这个地方有一个递归定义对吧

18
00:00:36,179 --> 00:00:37,929
你看逻辑量是什么

19
00:00:37,929 --> 00:00:39,520
关系运算或者逻辑运算的结果

20
00:00:39,520 --> 00:00:40,810
这个逻辑量用来干什么呢

21
00:00:40,810 --> 00:00:41,770
去做逻辑运算

22
00:00:41,770 --> 00:00:43,329
逻辑运算的结果会有一个逻辑量

23
00:00:43,329 --> 00:00:44,530
这个结果是灵活得一

24
00:00:44,530 --> 00:00:45,130
它是个逻辑量

25
00:00:45,130 --> 00:00:49,079
这个结果可以来做逻辑运算好吧

26
00:00:49,079 --> 00:00:50,100
别管我们怎么绕了

27
00:00:50,100 --> 00:00:52,409
我们来看我们有什么样的逻辑运算

28
00:00:52,409 --> 00:00:53,619
我们有三种

29
00:00:54,380 --> 00:00:57,899
一个感叹号表示说我要取非

30
00:00:57,899 --> 00:00:59,880
也就是说如果a是to的

31
00:00:59,880 --> 00:01:01,140
那么结果就是force

32
00:01:01,140 --> 00:01:01,859
如果a是一

33
00:01:01,859 --> 00:01:02,729
结果就是零

34
00:01:02,729 --> 00:01:03,539
如果a是零

35
00:01:03,539 --> 00:01:06,349
结果就是一两个and符号

36
00:01:06,349 --> 00:01:07,609
注意一定要注意

37
00:01:07,609 --> 00:01:09,780
这是两个and符号

38
00:01:09,780 --> 00:01:11,459
它表示的是逻辑于

39
00:01:11,459 --> 00:01:14,909
也就是说a和b呢必须通通都是一

40
00:01:14,909 --> 00:01:16,680
那么结果才会是一

41
00:01:16,680 --> 00:01:17,890
如果有一个是零

42
00:01:17,890 --> 00:01:19,269
结果就是零了

43
00:01:19,269 --> 00:01:21,099
两条竖线

44
00:01:21,739 --> 00:01:25,549
同样这是两条竖线表示的是逻辑或

45
00:01:25,549 --> 00:01:27,769
所以a或b的意思

46
00:01:27,769 --> 00:01:30,170
a或者b有一个是一

47
00:01:30,170 --> 00:01:32,909
那么整个结果就是一了

48
00:01:32,909 --> 00:01:34,659
这是我们的逻辑运算

49
00:01:35,640 --> 00:01:38,420
如果我们要表达数学当中的区间

50
00:01:38,420 --> 00:01:41,540
比如说x属于四六

51
00:01:41,540 --> 00:01:44,370
这是catch间或者x属于四六的b区间

52
00:01:44,370 --> 00:01:46,409
怎么去写c的表达式呢

53
00:01:46,409 --> 00:01:48,090
其实之前的练习题当中

54
00:01:48,090 --> 00:01:50,370
很多同学犯过错误了

55
00:01:50,370 --> 00:01:50,930
对不对

56
00:01:50,930 --> 00:01:53,909
你如果写出四小于x小于六这个式子

57
00:01:53,909 --> 00:01:56,400
它不是c能够正确计算的式子

58
00:01:56,400 --> 00:01:58,260
它是c能够编译的式子

59
00:01:58,260 --> 00:01:59,400
但是意思不一样

60
00:01:59,400 --> 00:02:03,200
它的意思是说我先去判断四是否小于x

61
00:02:03,239 --> 00:02:05,489
得到的结果是零或者一

62
00:02:05,489 --> 00:02:08,069
然后看这个零或者一是否小于六

63
00:02:08,069 --> 00:02:10,519
既然结果只有零或者一

64
00:02:10,519 --> 00:02:12,709
那么无论零还是一都是小于六的

65
00:02:12,709 --> 00:02:16,759
所以这个式子的结果怎么都是一的

66
00:02:16,759 --> 00:02:20,419
不可能去给你判断x是不是在四和六中间

67
00:02:22,300 --> 00:02:24,270
因此我们需要写出这样的式子

68
00:02:24,270 --> 00:02:25,560
x大于四

69
00:02:25,560 --> 00:02:27,900
并且x小于六

70
00:02:27,900 --> 00:02:31,810
这才是表达x在四和六的开区间中的

71
00:02:31,810 --> 00:02:34,080
那么一个表达式

72
00:02:34,319 --> 00:02:35,879
如果是b区间呢

73
00:02:35,879 --> 00:02:36,810
我们怎么改呢

74
00:02:36,810 --> 00:02:38,219
把大于改成大于等于

75
00:02:38,219 --> 00:02:39,300
小于改成小于等于

76
00:02:39,300 --> 00:02:40,659
那就是表达b区间了

77
00:02:41,718 --> 00:02:44,079
那如果我们要想要判断一个字符

78
00:02:44,079 --> 00:02:45,158
是不是大写字母呢

79
00:02:45,158 --> 00:02:46,560
我们就应该这么去判断

80
00:02:46,560 --> 00:02:48,360
c大于等于大写的a

81
00:02:48,360 --> 00:02:50,909
并且c小于等于大写的z

82
00:02:50,909 --> 00:02:54,650
这个时候表达的就是它处在a到z中间

83
00:02:54,650 --> 00:02:56,509
那么它就是一个大写字母

84
00:02:56,509 --> 00:02:57,900
小写字母的话呢

85
00:02:58,319 --> 00:02:59,879
那就把这里的a和z

86
00:02:59,879 --> 00:03:01,419
换成小写字母就可以了

87
00:03:02,118 --> 00:03:03,459
所以我们来理解一下

88
00:03:03,459 --> 00:03:05,019
说a大于20

89
00:03:05,019 --> 00:03:06,788
并且a就小于30的意思呢

90
00:03:06,788 --> 00:03:09,368
就是age处于20~30中间

91
00:03:09,368 --> 00:03:12,939
并且两头都不包含index小于零

92
00:03:12,939 --> 00:03:14,889
或者index大于99

93
00:03:14,889 --> 00:03:20,519
就是index不在不在0~99的范围内对吧

94
00:03:20,519 --> 00:03:22,438
不属于0~99的范围

95
00:03:22,438 --> 00:03:25,900
那就是它小于零或者大于99

96
00:03:26,099 --> 00:03:29,939
而最后这一行not age小于20

97
00:03:29,939 --> 00:03:31,229
应该怎么理解呢

98
00:03:31,229 --> 00:03:32,939
在这儿我们有两个运算符

99
00:03:32,939 --> 00:03:33,629
对不对

100
00:03:33,629 --> 00:03:35,789
虽然我们说逻辑运算符的优先级

101
00:03:35,789 --> 00:03:37,829
普遍是要低于比较运算符的

102
00:03:37,829 --> 00:03:41,848
可是呢这个not它是一个单位的运算符

103
00:03:41,848 --> 00:03:43,468
我们又有另外一条通行的规则

104
00:03:43,468 --> 00:03:45,479
就是单目运算符的优先级

105
00:03:45,479 --> 00:03:48,088
要高于双目运运算符

106
00:03:48,088 --> 00:03:49,408
所以在这种情况下

107
00:03:49,408 --> 00:03:51,748
实际上表面上看起来好像呢

108
00:03:51,748 --> 00:03:54,868
我们是是在说a就小于20的反面

109
00:03:54,868 --> 00:03:56,818
也就是age大于啊

110
00:03:56,818 --> 00:03:57,359
不小于20

111
00:03:57,359 --> 00:03:58,498
也就a就大于等于20

112
00:03:58,498 --> 00:04:01,079
但是实际上呢这个not会先做

113
00:04:01,079 --> 00:04:04,020
所以会变成说not和a就结合在一起

114
00:04:04,020 --> 00:04:06,150
那age如果是零

115
00:04:06,150 --> 00:04:08,520
not age就会变成一age

116
00:04:08,520 --> 00:04:09,240
如果不是零

117
00:04:09,240 --> 00:04:10,560
not age会变成零

118
00:04:10,560 --> 00:04:12,689
然后再去和20做比较

119
00:04:12,689 --> 00:04:14,490
那因为这个的结果不是零

120
00:04:14,490 --> 00:04:14,969
就是一

121
00:04:14,969 --> 00:04:16,339
所以不是零

122
00:04:16,339 --> 00:04:18,560
就是一和二小于20去做比较的话

123
00:04:18,560 --> 00:04:21,048
那整个表达式永远都是一了

124
00:04:21,048 --> 00:04:24,228
那我们要怎么才能够做到说我们想要比较

125
00:04:24,228 --> 00:04:26,569
不是age小于20呢

126
00:04:26,569 --> 00:04:28,139
我们得要加括号

127
00:04:29,600 --> 00:04:31,990
那么这三个运算符呢

128
00:04:31,990 --> 00:04:35,079
它的优先级是各不相同的

129
00:04:36,480 --> 00:04:38,029
not的优先级最高

130
00:04:38,029 --> 00:04:40,500
and的优先级比or要来的高

131
00:04:40,500 --> 00:04:43,259
所以下面这个式子会怎么算呢

132
00:04:43,259 --> 00:04:44,639
not的优先级最高

133
00:04:44,639 --> 00:04:46,300
所以not done会先算

134
00:04:46,980 --> 00:04:48,540
and后面有括号

135
00:04:50,100 --> 00:04:52,220
当然我们后面会说到这个括号

136
00:04:52,220 --> 00:04:55,250
其实可以不必要用这个括号里面再算的是

137
00:04:55,250 --> 00:04:57,050
count是否大于max

138
00:04:57,050 --> 00:04:58,730
所以count如果大于max

139
00:04:58,730 --> 00:05:01,310
并且down是一个零的话

140
00:05:01,310 --> 00:05:03,740
那么整个结果才会是一

141
00:05:06,420 --> 00:05:09,259
把这些我们之前学到的这些运算符

142
00:05:09,259 --> 00:05:10,399
的优先级摆到一起

143
00:05:10,399 --> 00:05:10,879
看的话

144
00:05:10,879 --> 00:05:12,250
我们看到是这样子的

145
00:05:12,250 --> 00:05:13,180
我们的not

146
00:05:13,180 --> 00:05:14,769
因为它是单目的

147
00:05:14,769 --> 00:05:15,910
它只有一个算子

148
00:05:15,910 --> 00:05:16,209
对不对

149
00:05:16,209 --> 00:05:16,750
单目的

150
00:05:16,750 --> 00:05:18,939
所以它和那些单位的运算符放在一起

151
00:05:18,939 --> 00:05:19,779
他很高

152
00:05:19,779 --> 00:05:21,250
它的优先级很高

153
00:05:21,250 --> 00:05:25,220
我们的and和or优先级很低

154
00:05:25,420 --> 00:05:26,980
低到比c还低呢

155
00:05:26,980 --> 00:05:29,319
你看b关系运算还要低

156
00:05:29,319 --> 00:05:32,139
但是它比腐值运算高一点点

157
00:05:32,139 --> 00:05:33,920
所以腐殖永远是最低的

158
00:05:34,300 --> 00:05:36,579
这样我才能做a等于什么什么

159
00:05:36,579 --> 00:05:37,899
右边任何式子都可以写了

160
00:05:37,899 --> 00:05:38,439
对不对

161
00:05:38,439 --> 00:05:39,879
辅助运算是最低的

162
00:05:39,879 --> 00:05:41,079
and比or高一点

163
00:05:41,079 --> 00:05:44,290
在前面关系运算比我们的逻辑运算还要高

164
00:05:44,290 --> 00:05:48,970
因此我们才能够去做那种a大于六

165
00:05:48,970 --> 00:05:50,860
and and a小于八

166
00:05:50,860 --> 00:05:51,519
这样的事情

167
00:05:51,519 --> 00:05:52,060
对不对

168
00:05:52,060 --> 00:05:53,600
否则怎么做得出来呢

169
00:05:55,819 --> 00:05:58,689
学过这种逻辑运算符之后

170
00:05:58,689 --> 00:06:03,720
你看我们之前讲我们第四周的那个练习题

171
00:06:03,720 --> 00:06:05,250
我们曾经是写出这样的代码

172
00:06:05,250 --> 00:06:07,620
说if i不等于j

173
00:06:07,620 --> 00:06:09,660
然后再来判断if i不等于k

174
00:06:09,660 --> 00:06:11,490
然后再来判断1j不等于k

175
00:06:11,490 --> 00:06:15,149
它就可以被换成是if i不等于j

176
00:06:15,149 --> 00:06:16,560
并且i不等于k

177
00:06:16,560 --> 00:06:18,240
并且j不等于k

178
00:06:18,459 --> 00:06:22,379
这样的一个逻辑运算的式子来

179
00:06:24,300 --> 00:06:25,100
同样的

180
00:06:25,100 --> 00:06:26,839
如果我们的代码原来写成说

181
00:06:26,839 --> 00:06:28,490
如果game over等于等于零

182
00:06:28,490 --> 00:06:29,300
里面再去判断

183
00:06:29,300 --> 00:06:31,060
如果player to move等于等于二

184
00:06:31,060 --> 00:06:32,350
我们就可以把它变成

185
00:06:32,350 --> 00:06:33,759
如果game over等于等于零

186
00:06:33,759 --> 00:06:35,379
并且pay to move等于等于二

187
00:06:35,379 --> 00:06:37,120
我们输出your turn

188
00:06:37,120 --> 00:06:39,529
可是如果我们的代码是这样的

189
00:06:39,529 --> 00:06:41,329
if game over等于等于零

190
00:06:41,329 --> 00:06:43,129
if player to move等于等于二

191
00:06:43,129 --> 00:06:44,089
print f什么什么

192
00:06:44,089 --> 00:06:45,350
else print f什么什么

193
00:06:45,350 --> 00:06:49,740
这个时候你还能不能把它写成这种形式呢

194
00:06:49,740 --> 00:06:50,939
能吗

195
00:06:54,399 --> 00:06:55,240
在

196
00:06:57,000 --> 00:06:58,699
这个逻辑运算当中啊

197
00:06:58,699 --> 00:07:01,120
我们的逻辑运算是自左向右进行的

198
00:07:01,478 --> 00:07:04,869
如果左边的这个结果已经可以决定结果了

199
00:07:04,869 --> 00:07:07,038
那么就不会做右边的计算

200
00:07:07,038 --> 00:07:10,829
如果说a等于等于六已经是不成立的

201
00:07:10,829 --> 00:07:11,910
对于这个and来说

202
00:07:11,910 --> 00:07:13,050
它必须要两边都成立

203
00:07:13,050 --> 00:07:14,970
所以如果a等于等于六不成立

204
00:07:14,970 --> 00:07:17,658
那么b等于等于一就不会去判断了

205
00:07:17,658 --> 00:07:18,918
这当然是个好事情

206
00:07:18,918 --> 00:07:21,288
可以提高我们运算的速度对吧

207
00:07:21,288 --> 00:07:24,550
我这边就不用再去做相应的这些判断

208
00:07:24,550 --> 00:07:25,750
计算这些事情了

209
00:07:25,750 --> 00:07:29,519
但是如果你在右边是有腐值的

210
00:07:30,019 --> 00:07:32,360
是要去产生一些结果的

211
00:07:32,360 --> 00:07:36,199
那么右边的这个计算就不会做了

212
00:07:36,339 --> 00:07:38,470
他不会把两边都做完以后

213
00:07:38,470 --> 00:07:39,879
再来做这个and运算

214
00:07:39,879 --> 00:07:41,379
它一定是先做左边

215
00:07:41,379 --> 00:07:42,370
发现不用做了

216
00:07:42,370 --> 00:07:43,480
右边就不会做了

217
00:07:43,480 --> 00:07:45,319
所以对于and and来说

218
00:07:45,319 --> 00:07:47,548
如果左边是force不做右边

219
00:07:47,548 --> 00:07:48,569
对于二来说

220
00:07:48,569 --> 00:07:49,588
如果左边是true

221
00:07:49,588 --> 00:07:51,209
那么它也不做右边了

222
00:07:51,209 --> 00:07:53,399
这件事情叫做短路

223
00:07:53,978 --> 00:07:55,689
我们来试一下这件事情

224
00:07:55,689 --> 00:07:58,629
我们说如果a大于零

225
00:07:58,629 --> 00:08:02,939
并且a加加大于一

226
00:08:03,660 --> 00:08:05,660
那我们现在知道a是-1

227
00:08:05,660 --> 00:08:07,500
所以a大于零是不成立的

228
00:08:08,000 --> 00:08:09,620
如果这个条件是成立的

229
00:08:09,620 --> 00:08:13,220
我们会输出o然后不管怎么样

230
00:08:13,220 --> 00:08:15,560
我们都去输出这个a的值

231
00:08:15,560 --> 00:08:18,139
我们看看a到底是-1还是a加

232
00:08:18,139 --> 00:08:19,920
加以后的结果也就是零

233
00:08:20,899 --> 00:08:23,480
我们运行的结果说a是-1

234
00:08:23,480 --> 00:08:26,360
这个-1就表明说在这个运行的过程当中

235
00:08:26,360 --> 00:08:28,709
a加加根本就没有被执行

236
00:08:28,709 --> 00:08:30,689
因为a大于零就是不成立的

237
00:08:30,689 --> 00:08:33,500
所以后面的这个这一部分是不会去做的

238
00:08:33,519 --> 00:08:36,159
我们希望你不要把赋值

239
00:08:36,159 --> 00:08:39,320
包括复合赋值组合进表达式

240
00:08:39,320 --> 00:08:40,789
如果你记住了这一条

241
00:08:40,789 --> 00:08:42,519
你就不会写出这样的代码来

242
00:08:42,519 --> 00:08:44,200
你不写出这样的代码来短路

243
00:08:44,200 --> 00:08:46,059
对你来说就是没有意义的

244
00:08:46,059 --> 00:08:47,279
就是不会起作用的事情

