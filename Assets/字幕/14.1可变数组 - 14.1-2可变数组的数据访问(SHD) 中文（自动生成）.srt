1
00:00:04,320 --> 00:00:05,359
啥意思呢

2
00:00:06,799 --> 00:00:07,900
size要得到

3
00:00:07,900 --> 00:00:10,359
说我现在这个数组里头有多少个单元

4
00:00:10,359 --> 00:00:11,199
这事儿很简单

5
00:00:11,199 --> 00:00:14,320
我们直接就return这个a所指的那个size

6
00:00:14,320 --> 00:00:15,300
就可以了

7
00:00:16,439 --> 00:00:17,928
ok肯定有同学会问

8
00:00:17,928 --> 00:00:20,658
既然这个size这个函数所做的事情

9
00:00:20,658 --> 00:00:22,189
不过是给你a的size

10
00:00:22,189 --> 00:00:23,059
换句话说

11
00:00:23,059 --> 00:00:24,228
如果我在这个面里头

12
00:00:24,228 --> 00:00:25,489
想要知道现在a有多大

13
00:00:25,489 --> 00:00:26,928
我想princess print下

14
00:00:26,928 --> 00:00:29,268
说这个a有多a里头有多少大

15
00:00:29,268 --> 00:00:33,170
我需要做的事情是array size

16
00:00:33,170 --> 00:00:36,390
那个a给他为什么这么复杂

17
00:00:36,390 --> 00:00:37,649
为什么你不这么做

18
00:00:37,649 --> 00:00:40,350
说诶我在这里直接反正那个a在这里嘛

19
00:00:40,350 --> 00:00:42,969
那a.size不就是那个东西吗

20
00:00:42,969 --> 00:00:44,200
为什么不这么做

21
00:00:44,200 --> 00:00:47,058
这两种做法有什么区别

22
00:00:49,320 --> 00:00:53,338
这种做法我们给它一个名词叫做

23
00:00:56,500 --> 00:00:57,240
分装

24
00:00:59,340 --> 00:01:02,878
我们以这种做法把a的size给保护起来

25
00:01:03,060 --> 00:01:05,819
我现在当然我的现在的这个版本

26
00:01:05,819 --> 00:01:08,129
我做到现在这个程度我非常简单

27
00:01:08,129 --> 00:01:09,819
我return in size就够了

28
00:01:09,819 --> 00:01:13,569
也许今后随着我的版本的升级

29
00:01:13,569 --> 00:01:16,799
随着我的这些内部的算法的改进

30
00:01:16,799 --> 00:01:19,599
不是简单的a size就可以给你的

31
00:01:19,900 --> 00:01:24,310
那个时候你如果你的代码是直接拿a size的

32
00:01:24,310 --> 00:01:25,659
就完蛋了

33
00:01:25,920 --> 00:01:27,540
我给了你一个函数

34
00:01:27,540 --> 00:01:29,939
这个函数把我的内部的实现

35
00:01:29,939 --> 00:01:31,799
细节给保护起来了

36
00:01:31,799 --> 00:01:33,780
你不知道我里头是怎么做的

37
00:01:35,780 --> 00:01:37,180
所以好处在这儿

38
00:01:38,319 --> 00:01:44,359
然后这个呢rat要返回在这个a里面

39
00:01:44,359 --> 00:01:46,040
在index上的那个东西

40
00:01:46,040 --> 00:01:51,109
所以简单的做法也许就是return a所指的

41
00:01:51,109 --> 00:01:53,399
array index

42
00:01:53,599 --> 00:01:55,340
但是好像有哪里不对

43
00:01:55,340 --> 00:01:58,340
因为我们的返回类型是int的指针

44
00:01:58,340 --> 00:01:59,679
而非int

45
00:02:00,000 --> 00:02:02,640
我们这样得到的东西是一个int

46
00:02:02,640 --> 00:02:03,840
而不是int的指针

47
00:02:03,840 --> 00:02:07,920
所以我们需要返回的是它的指针

48
00:02:08,778 --> 00:02:11,139
如果你不太确定优先级

49
00:02:11,139 --> 00:02:13,088
加括号是最简单的办法

50
00:02:13,088 --> 00:02:15,159
在工程中我们通常就是这么干的

51
00:02:15,819 --> 00:02:17,500
为什么这个函数要返回指针

52
00:02:17,500 --> 00:02:18,879
而不是返回int

53
00:02:18,879 --> 00:02:27,689
假如说我们想要说这个输出一下这个raid at

54
00:02:27,689 --> 00:02:31,479
这个a这个a raid 0的那个位置上的东西

55
00:02:31,799 --> 00:02:32,998
如果他返回的int

56
00:02:32,998 --> 00:02:33,838
我们这么干就行了

57
00:02:33,838 --> 00:02:34,498
对不对

58
00:02:34,498 --> 00:02:36,058
如果他返回的是指针

59
00:02:36,058 --> 00:02:36,419
很麻烦

60
00:02:36,419 --> 00:02:38,039
我们前头还得加个星号

61
00:02:38,938 --> 00:02:41,269
为什么我们希望它返回是指针呢

62
00:02:41,269 --> 00:02:43,998
因为如果它返回是指针

63
00:02:43,998 --> 00:02:45,378
我们就可以这么做

64
00:02:45,378 --> 00:02:46,878
你想现在其实在这个时刻

65
00:02:46,878 --> 00:02:47,800
在这句话

66
00:02:47,800 --> 00:02:50,620
你去看它在零那个位置上的值

67
00:02:50,620 --> 00:02:51,580
是没有任何意义的

68
00:02:51,580 --> 00:02:53,349
因为我们没有给它赋过值

69
00:02:53,349 --> 00:02:54,939
所以我们需要有个方法给它赋值

70
00:02:54,939 --> 00:02:55,599
对不对

71
00:02:55,599 --> 00:02:58,939
所以我们可以这么来做赋值

72
00:03:03,879 --> 00:03:06,338
为什么这可以哇

73
00:03:06,338 --> 00:03:09,998
这个复制号的左边看上去好奇妙的东西

74
00:03:09,998 --> 00:03:14,289
一个函数调用前头加了个星号

75
00:03:14,289 --> 00:03:15,129
没错啊

76
00:03:15,129 --> 00:03:17,169
这个函数调用返回的是一个什么

77
00:03:17,169 --> 00:03:18,159
是一个指针

78
00:03:18,159 --> 00:03:19,150
然后加了星号

79
00:03:19,150 --> 00:03:21,340
就是这个指针所指的那个东西

80
00:03:21,639 --> 00:03:23,469
当然它是个变量

81
00:03:23,469 --> 00:03:24,879
所以它可以做左值

82
00:03:24,879 --> 00:03:27,800
我们让它等于十嗯

83
00:03:27,800 --> 00:03:28,819
我我们跑到现在

84
00:03:28,819 --> 00:03:30,919
我们应该来运行一下这个代码了

85
00:03:30,919 --> 00:03:31,819
但是在运行之前

86
00:03:31,819 --> 00:03:33,800
我们还得在前面加上两句include啊

87
00:03:33,800 --> 00:03:35,120
我们里头用到了pina

88
00:03:35,120 --> 00:03:35,780
用到了malik

89
00:03:35,780 --> 00:03:38,319
所以这两句啊标准头文件也要加上去

90
00:03:38,319 --> 00:03:39,539
然后我们来运行它

91
00:03:39,780 --> 00:03:42,539
我们看到它说它的size呢是100

92
00:03:42,539 --> 00:03:43,319
这当然就这样子

93
00:03:43,319 --> 00:03:46,860
然后他说在零那个位置上呢是十

94
00:03:48,058 --> 00:03:52,068
所以这句话就可以把一个值

95
00:03:52,068 --> 00:03:54,259
写到那个数组里头去了

96
00:03:54,539 --> 00:03:58,338
嗯哼但是如果你觉得你很难

97
00:03:58,338 --> 00:04:00,919
心理上很难去接受这样的东西啊

98
00:04:00,919 --> 00:04:05,900
新一个函数调用浑身起鸡皮疙瘩

99
00:04:05,959 --> 00:04:07,699
如果你觉得你接受不了

100
00:04:07,699 --> 00:04:09,739
ok我们不是没有办法

101
00:04:09,739 --> 00:04:12,739
我们可以提供另外一对函数

102
00:04:12,739 --> 00:04:17,098
我们可以有这样一对函数叫做ari get

103
00:04:17,098 --> 00:04:20,129
然后我们需要有一个array的指针

104
00:04:20,129 --> 00:04:23,899
我们还需要有一个index啊

105
00:04:23,899 --> 00:04:25,100
当然其实这个时候呢

106
00:04:25,100 --> 00:04:26,720
这个array的指针完全是一个const

107
00:04:26,720 --> 00:04:28,490
因为我们不会去修改它任何东西

108
00:04:28,490 --> 00:04:32,759
然后我们return就是这个了

109
00:04:32,759 --> 00:04:38,250
然后我们还可以有一个arread set函数

110
00:04:38,250 --> 00:04:40,439
当然这时候它不能是cost了

111
00:04:40,439 --> 00:04:41,939
因为我们要去做修改

112
00:04:42,800 --> 00:04:44,360
然后有一个value

113
00:04:46,360 --> 00:04:49,829
然后呢我们就会让a所指的array

114
00:04:49,829 --> 00:04:52,839
index呢等于那个value

115
00:04:53,759 --> 00:04:55,278
然后我们下面这两句

116
00:04:55,278 --> 00:04:58,800
就可以依次依照那个样子就改成get和set

117
00:04:59,740 --> 00:05:01,079
看你喜欢啊

118
00:05:01,079 --> 00:05:02,899
你喜欢那样的话就可以写成那个样子

