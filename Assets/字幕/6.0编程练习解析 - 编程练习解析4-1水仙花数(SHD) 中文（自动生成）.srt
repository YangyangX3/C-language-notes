1
00:00:04,519 --> 00:00:07,160
好我们来看这个水仙花树该怎么做哈

2
00:00:07,160 --> 00:00:11,300
呃题目说呢水仙花数是n位的正整数

3
00:00:11,300 --> 00:00:13,009
那么这个n是大于等于三

4
00:00:13,009 --> 00:00:14,150
实际上后面还有个条件

5
00:00:14,150 --> 00:00:16,370
那实际上这个m那就34567啊

6
00:00:16,370 --> 00:00:17,449
就这四种数

7
00:00:17,449 --> 00:00:20,750
它的每个位上的数字的n次幂啊

8
00:00:20,750 --> 00:00:21,710
比如说对于153来说

9
00:00:21,710 --> 00:00:22,489
这是个三位数

10
00:00:22,489 --> 00:00:24,640
所以呢一的三次方加五的三次方

11
00:00:24,640 --> 00:00:26,649
加三的三次方正好等于153

12
00:00:26,649 --> 00:00:27,850
如果是个四位数

13
00:00:27,850 --> 00:00:29,320
那么这个就要变成四次方

14
00:00:29,320 --> 00:00:29,859
四次方

15
00:00:29,859 --> 00:00:30,850
四次方啊

16
00:00:30,850 --> 00:00:32,378
四个四次方的加起来

17
00:00:32,378 --> 00:00:36,759
那么写个程序要求计算所有的mv的正整数

18
00:00:36,759 --> 00:00:38,979
所以这个程序呢要读入一个n

19
00:00:38,979 --> 00:00:41,259
然后输出比如说读到三

20
00:00:41,259 --> 00:00:44,140
那我要输出所有的三位数的这个

21
00:00:44,140 --> 00:00:46,179
水仙花数啊

22
00:00:46,179 --> 00:00:47,418
这个题目怎么做呢

23
00:00:48,539 --> 00:00:51,259
我们把题目的正文部分拷贝

24
00:00:51,259 --> 00:00:51,920
然后呢

25
00:00:51,920 --> 00:00:54,679
我们就不妨把它粘贴到程序这儿来

26
00:00:54,679 --> 00:00:56,338
加上注释的符号

27
00:00:56,439 --> 00:00:57,100
这样呢

28
00:00:57,100 --> 00:01:00,689
随时我们不就就不需要翻回那个网页去啊

29
00:01:00,689 --> 00:01:02,579
我们随时可以在程序这边就可以来看

30
00:01:02,579 --> 00:01:04,409
到底这些程序题目要求是怎么样的

31
00:01:04,409 --> 00:01:05,849
那当然既然他有个n

32
00:01:05,849 --> 00:01:08,000
那我们第一件事情肯定是有个an

33
00:01:08,000 --> 00:01:10,129
然后呢我们要去读入这个n

34
00:01:10,129 --> 00:01:11,750
读这个n以后怎么做

35
00:01:11,750 --> 00:01:16,159
我们需要去找出所有的三位数

36
00:01:16,159 --> 00:01:21,129
那么显然我们应该要去走遍所有的三位数

37
00:01:21,129 --> 00:01:22,269
我们这个时候呢

38
00:01:22,269 --> 00:01:24,790
有一个计算机的术语叫做便利

39
00:01:24,790 --> 00:01:27,370
我们要去遍历所有的三位数

40
00:01:27,370 --> 00:01:29,170
所有的三位数如果是三的话啊

41
00:01:29,170 --> 00:01:30,259
如果n等于三

42
00:01:30,259 --> 00:01:31,399
那三位数是什么呢

43
00:01:31,399 --> 00:01:34,698
那就是100~999对吧

44
00:01:34,698 --> 00:01:36,078
那如果是四位数的话

45
00:01:36,078 --> 00:01:38,379
就是1000~9999

46
00:01:38,439 --> 00:01:40,780
所以我们要去便利这个东西

47
00:01:40,780 --> 00:01:44,909
那么假如说我们已经有了一个i

48
00:01:44,909 --> 00:01:46,739
我们说让那个i等于100

49
00:01:46,739 --> 00:01:48,959
然后我们可以我们可以做个循环说

50
00:01:48,959 --> 00:01:51,000
while i小于1000

51
00:01:51,000 --> 00:01:53,049
然后我们要怎么样怎么样

52
00:01:53,049 --> 00:01:56,109
那么每一个i我们去测试它是不是

53
00:01:56,109 --> 00:01:57,340
首先画树对吧

54
00:01:57,340 --> 00:01:58,870
因此在这个之前

55
00:01:58,870 --> 00:02:00,129
首先第一件事情是

56
00:02:00,129 --> 00:02:03,250
我们怎么从从这个三能够得到这个100

57
00:02:03,250 --> 00:02:03,819
对吧

58
00:02:03,819 --> 00:02:06,129
根据输入的是三位数

59
00:02:06,129 --> 00:02:08,099
我们能够得到一个100

60
00:02:09,419 --> 00:02:10,939
那就做惩罚了

61
00:02:11,539 --> 00:02:14,289
从三要得到100是要乘两次

62
00:02:14,289 --> 00:02:16,039
拿10x2次

63
00:02:16,079 --> 00:02:17,729
而不是乘三次

64
00:02:17,729 --> 00:02:18,658
所以一开始呢

65
00:02:18,658 --> 00:02:21,778
比如说啊我们说我们有一个变量叫做first

66
00:02:21,778 --> 00:02:22,558
它等于一

67
00:02:22,558 --> 00:02:26,520
也就是说将来呢这个i呢是要从first开始

68
00:02:26,520 --> 00:02:29,280
那么然后我们要想一个办法去构建出

69
00:02:29,280 --> 00:02:30,000
这个first time

70
00:02:30,000 --> 00:02:30,599
对不对啊

71
00:02:30,599 --> 00:02:31,919
比如说我们做一个循环

72
00:02:31,919 --> 00:02:35,460
说while这个如果我们直接拿来做

73
00:02:35,460 --> 00:02:36,539
因为我们要做的形式

74
00:02:36,539 --> 00:02:38,099
这就是拿n减减减

75
00:02:38,099 --> 00:02:39,360
但是我们就把i啊

76
00:02:39,360 --> 00:02:40,620
这个n给用掉了对吧

77
00:02:40,620 --> 00:02:42,300
所以呢我们不妨说我们有变量

78
00:02:42,300 --> 00:02:45,379
就是i我们我们一开始呢i等于一

79
00:02:45,379 --> 00:02:47,960
然后呢while这个i呢还是小于n的

80
00:02:47,960 --> 00:02:52,539
那我们要做的事情呢就是让first呢乘等于十

81
00:02:52,539 --> 00:02:54,819
first乘等于first乘十啊

82
00:02:54,819 --> 00:02:56,919
然后当然别忘了在每一轮里面呢

83
00:02:56,919 --> 00:02:58,998
i要加加啊

84
00:02:58,998 --> 00:03:02,899
我们要用这个i来逐渐走到n来算

85
00:03:02,899 --> 00:03:04,139
帮我们算出这个first

86
00:03:04,139 --> 00:03:08,180
可对于这个神循环来说还会走几遍呢

87
00:03:08,659 --> 00:03:10,370
当n等于三的时候

88
00:03:10,370 --> 00:03:12,599
i走的是三遍还是两遍呢

89
00:03:12,979 --> 00:03:14,990
如果你跟我算数一样的差

90
00:03:14,990 --> 00:03:16,699
ok我还有另外一个办法

91
00:03:16,699 --> 00:03:18,409
我们可以在这里写个pinf

92
00:03:18,409 --> 00:03:19,280
我们来输出一下

93
00:03:19,280 --> 00:03:22,060
说这个first我们算出来的是多少

94
00:03:22,919 --> 00:03:25,219
然后根据它给我们的结果

95
00:03:25,219 --> 00:03:27,139
我们再来看我们的这个i小于n

96
00:03:27,139 --> 00:03:28,039
是不是写对了

97
00:03:28,039 --> 00:03:28,400
好

98
00:03:28,400 --> 00:03:31,879
我们先来把下面的这一部分代码注释掉啊

99
00:03:31,879 --> 00:03:33,199
我们这还没写完呢

100
00:03:33,199 --> 00:03:33,860
先不管了

101
00:03:33,860 --> 00:03:35,379
我们先来调试前面那一半

102
00:03:35,379 --> 00:03:37,330
我们来编译运行它一下

103
00:03:37,330 --> 00:03:40,180
它告诉我们现在的first等于100

104
00:03:40,180 --> 00:03:41,740
这刚好就是我们要的那个结果

105
00:03:41,740 --> 00:03:42,099
对不对

106
00:03:42,099 --> 00:03:42,430
好

107
00:03:42,430 --> 00:03:46,360
那说明我们让i从一走到正好是走了两遍

108
00:03:46,360 --> 00:03:47,560
而不是走了三遍

109
00:03:47,560 --> 00:03:48,699
其实如果你还记得

110
00:03:48,699 --> 00:03:51,340
我们在讲到循环的那个计数次数的时候

111
00:03:51,340 --> 00:03:51,969
提到过

112
00:03:51,969 --> 00:03:54,639
如果你让i从零走到小于n

113
00:03:54,639 --> 00:03:55,719
它会走n变

114
00:03:55,719 --> 00:03:56,860
但是从一开始走的话

115
00:03:56,860 --> 00:03:57,819
那就走n减一变

116
00:03:57,819 --> 00:03:59,759
而我们现在正好需要他走a减一变

117
00:03:59,759 --> 00:04:01,650
所以通过这个循环

118
00:04:01,650 --> 00:04:03,539
我们得到了我们要的那个first

119
00:04:03,539 --> 00:04:05,069
那接下来的事情呢

120
00:04:05,069 --> 00:04:08,718
我们需要让那个first从从

121
00:04:08,718 --> 00:04:12,408
让另外让那个i从first走到什么呢

122
00:04:12,408 --> 00:04:13,938
这个1000是怎么出来的

123
00:04:13,938 --> 00:04:16,519
这个1000其实就是first乘以十

124
00:04:16,519 --> 00:04:17,220
对不对

125
00:04:17,538 --> 00:04:20,779
好当然这个i因为前面已经定义过了

126
00:04:20,779 --> 00:04:22,579
所以我们不需要再来定义第二遍的i

127
00:04:22,579 --> 00:04:23,779
如果你再定一遍

128
00:04:23,779 --> 00:04:25,550
第二遍的i其实还是会有错的

129
00:04:25,550 --> 00:04:26,839
在一个函数里头

130
00:04:26,839 --> 00:04:28,730
你不能定义两个同名的变量

131
00:04:28,730 --> 00:04:30,740
现在我们重新使用这个i

132
00:04:30,740 --> 00:04:31,910
我们让i等于first

133
00:04:31,910 --> 00:04:37,680
让i在这个while循环里面从first走到小

134
00:04:37,680 --> 00:04:39,449
于是小于还是小于等于呢

135
00:04:39,449 --> 00:04:43,319
因为first乘以十是如果是三位数的分数

136
00:04:43,319 --> 00:04:45,230
乘以十就是就是四位数了

137
00:04:45,230 --> 00:04:46,550
所以小于就可以了

138
00:04:46,550 --> 00:04:48,110
小鱼刚好就可以走到999

139
00:04:48,110 --> 00:04:48,889
对三位数来说

140
00:04:48,889 --> 00:04:49,670
走到999

141
00:04:49,670 --> 00:04:50,509
当然别忘了

142
00:04:50,509 --> 00:04:51,170
在这个里头

143
00:04:51,170 --> 00:04:53,129
我们每一个人当然i加加

144
00:04:53,129 --> 00:04:54,209
接下来要做的事情

145
00:04:54,209 --> 00:04:58,199
就是我们要去分解这个i的每一位数

146
00:04:58,519 --> 00:05:00,110
算出它的n次幂

147
00:05:00,110 --> 00:05:02,639
然后在求和求起来

148
00:05:02,639 --> 00:05:03,779
所以在这个时候呢

149
00:05:03,779 --> 00:05:07,189
我们需要有一个临时的变量去记录这个i

150
00:05:07,189 --> 00:05:08,870
因为我们要去分解这个i

151
00:05:08,870 --> 00:05:10,069
在这个分解的过程当中

152
00:05:10,069 --> 00:05:11,329
我们一定会破坏这个i的

153
00:05:11,329 --> 00:05:12,949
所以我们要有一个临时的变量去记录

154
00:05:12,949 --> 00:05:13,449
这个i

155
00:05:13,449 --> 00:05:15,970
我们还需要有一个和来记录

156
00:05:15,970 --> 00:05:19,389
说它的每一位数的n次幂的呃

157
00:05:19,389 --> 00:05:21,490
这个累加的那个结果

158
00:05:21,490 --> 00:05:23,990
然后我们需要有个循环

159
00:05:23,990 --> 00:05:26,930
但这个时候用do还是while关系不大

160
00:05:26,930 --> 00:05:28,910
我们之前在做这个数的分解的时候

161
00:05:28,910 --> 00:05:30,589
我们已经做过很多次了

162
00:05:30,589 --> 00:05:34,050
我们知道说如果你做读循环

163
00:05:34,050 --> 00:05:36,220
它可以有效的帮你处理零的问题

164
00:05:36,220 --> 00:05:37,240
你做完要循环

165
00:05:37,240 --> 00:05:38,439
它处理不了零的问题

166
00:05:38,439 --> 00:05:39,459
但对我们现在来说

167
00:05:39,459 --> 00:05:40,600
这个t不可能是零

168
00:05:40,600 --> 00:05:41,379
所以没关系

169
00:05:41,379 --> 00:05:43,009
我们用任何一种循环就可以

170
00:05:43,009 --> 00:05:44,449
如果我们还是习惯于说

171
00:05:44,449 --> 00:05:45,589
在做数的分解的时候

172
00:05:45,589 --> 00:05:47,389
我们就用do循环说

173
00:05:47,389 --> 00:05:49,720
while呢这个t是大于零的

174
00:05:50,620 --> 00:05:52,139
那在循环的每一步

175
00:05:52,139 --> 00:05:56,178
我们的那个d呢就是t的最低位

176
00:05:56,178 --> 00:05:57,288
t的那个个位

177
00:05:57,288 --> 00:06:00,199
然后呢t每一次都要除等于十

178
00:06:00,699 --> 00:06:02,379
那拿到了那个d以后

179
00:06:02,379 --> 00:06:03,850
我们要做的一件事情是

180
00:06:03,850 --> 00:06:06,879
我们需要算d的n次幂

181
00:06:07,240 --> 00:06:10,240
怎么算一个数的n次幂呢

182
00:06:11,319 --> 00:06:14,060
所以其实最简单的方案是

183
00:06:14,060 --> 00:06:15,740
我们在上一个循环好了

184
00:06:15,740 --> 00:06:19,100
我们做一个循环去跑n变啊

185
00:06:19,100 --> 00:06:22,680
我们现在已经知道这个an是34567

186
00:06:22,680 --> 00:06:27,360
所以我们需要让这个d呢称自己多少遍呢

187
00:06:27,360 --> 00:06:29,180
当我们在说d的

188
00:06:29,420 --> 00:06:30,920
如果我们借用一下啊

189
00:06:30,920 --> 00:06:33,160
虽然这个符号在c语言里面不存在啊

190
00:06:33,160 --> 00:06:34,029
我们借用一下

191
00:06:34,029 --> 00:06:36,100
我们经常在算术当中会写的这样的符号

192
00:06:36,100 --> 00:06:39,428
说d的二次方其实它是等于d乘以d

193
00:06:39,428 --> 00:06:42,759
所以是d和自己成了一遍

194
00:06:42,759 --> 00:06:44,500
做了一次低成d的操作

195
00:06:44,500 --> 00:06:45,519
就得到了二次方

196
00:06:45,519 --> 00:06:47,319
因此如果是三次方的话

197
00:06:47,319 --> 00:06:50,560
它是d乘敌再乘底是乘了两遍

198
00:06:50,560 --> 00:06:52,329
而不是乘了三遍

199
00:06:52,329 --> 00:06:53,949
这是很容易搞错的一个地方

200
00:06:53,949 --> 00:06:56,290
所以当我们要去算这个幂次的时候

201
00:06:56,290 --> 00:07:01,300
我们需要让一个让这个底层自己n减一变

202
00:07:01,300 --> 00:07:03,240
而不是称自己n变

203
00:07:03,240 --> 00:07:05,459
我们需要有一个呃变量

204
00:07:05,459 --> 00:07:07,279
用来表达这个幂次的结果

205
00:07:07,279 --> 00:07:09,319
我们让它等于一从一开始

206
00:07:09,319 --> 00:07:11,899
然后我们需要有一个计数的变量结尾

207
00:07:11,899 --> 00:07:13,759
我们让它一开始从零开始

208
00:07:13,759 --> 00:07:17,420
我们需要那个j呢小于n

209
00:07:17,500 --> 00:07:18,670
这样的话呢

210
00:07:18,670 --> 00:07:20,560
我们这个循环进行的是多少次呢

211
00:07:20,560 --> 00:07:23,000
是从零到n进行了n次

212
00:07:23,000 --> 00:07:23,509
对不对

213
00:07:23,509 --> 00:07:26,180
我们再让他每一次做的事情是p乘

214
00:07:26,180 --> 00:07:27,110
等于那个d

215
00:07:27,110 --> 00:07:29,360
然后呢当然别忘了每一轮啊

216
00:07:29,360 --> 00:07:30,389
解要加价

217
00:07:30,389 --> 00:07:32,730
要不然这循环就结束不了了对吧

218
00:07:32,730 --> 00:07:34,180
那这样子的话呢

219
00:07:34,180 --> 00:07:35,319
实际上在循环的第一轮

220
00:07:35,319 --> 00:07:36,160
我们做的是什么呢

221
00:07:36,160 --> 00:07:37,389
做的是一乘以d

222
00:07:37,389 --> 00:07:38,800
我们并没有去做d乘以d

223
00:07:38,800 --> 00:07:40,350
我们刚才在解释了嘛

224
00:07:40,350 --> 00:07:42,089
你要做d的n次方的时候

225
00:07:42,089 --> 00:07:42,750
d乘d啊

226
00:07:42,750 --> 00:07:43,889
乘n减一次变

227
00:07:43,889 --> 00:07:46,389
但我们现在循环的是走m变了

228
00:07:46,389 --> 00:07:47,410
但是循环的第一轮

229
00:07:47,410 --> 00:07:50,129
其实是做的是一层d的操作

230
00:07:50,129 --> 00:07:51,779
所以呢也有的人喜欢这样写

231
00:07:51,779 --> 00:07:53,639
说一开始的时候呢p不是等于一

232
00:07:53,639 --> 00:07:54,329
p等于d

233
00:07:54,329 --> 00:07:56,139
然后呢j呢从一开始

234
00:07:56,139 --> 00:07:58,959
直接从一开始的时候循环只要做n减一变

235
00:07:58,959 --> 00:08:00,468
那循环的呃

236
00:08:00,468 --> 00:08:02,928
第一轮的时候就已经是做地成d了啊

237
00:08:02,928 --> 00:08:04,668
这样两个写法其实都是可以的

238
00:08:04,668 --> 00:08:05,928
如果你还是不确定的话呢

239
00:08:05,928 --> 00:08:08,199
你也可以在这里写一句输出啊

240
00:08:08,199 --> 00:08:10,540
看一下现在我们的d是多少

241
00:08:10,540 --> 00:08:12,100
我们算下来的这个p是多少

242
00:08:12,100 --> 00:08:14,649
也就是这个啊这个这个幂次是多少

243
00:08:14,649 --> 00:08:16,379
看看他们是不是对的啊

244
00:08:16,379 --> 00:08:18,939
啊或者debug的时候去跟踪一下

245
00:08:18,939 --> 00:08:19,839
看看运行到这里

246
00:08:19,839 --> 00:08:21,439
这个p算出来是不是对的

247
00:08:21,500 --> 00:08:24,319
现在我们在通过这个循环

248
00:08:24,319 --> 00:08:26,600
把这个呃p给算出来之后呢

249
00:08:26,600 --> 00:08:27,259
我们要做的事情

250
00:08:27,259 --> 00:08:30,360
就是要把它加到这个some里头去啊

251
00:08:30,360 --> 00:08:32,220
那么然后再下来呢

252
00:08:32,220 --> 00:08:35,409
我们在这个循环结束以后

253
00:08:35,409 --> 00:08:37,090
我们得到了这一个数

254
00:08:37,090 --> 00:08:39,909
这个i这个数每一位的幂次的和

255
00:08:39,909 --> 00:08:41,049
然后我们就来判断一下

256
00:08:41,049 --> 00:08:43,448
说如果上和i是相等的

257
00:08:43,448 --> 00:08:45,470
那我们就要输出这个数

258
00:08:45,470 --> 00:08:47,210
所以现在就我们得到了这个结果

259
00:08:47,210 --> 00:08:49,979
我们可以先在3n等于三的基础上试一下

260
00:08:50,419 --> 00:08:52,820
我们看到它和我们的题目的呃

261
00:08:52,820 --> 00:08:54,458
这个结果是一样的

262
00:08:54,700 --> 00:08:55,840
这就是我们这道题目

263
00:08:55,840 --> 00:08:57,220
首先画树的这个做法

