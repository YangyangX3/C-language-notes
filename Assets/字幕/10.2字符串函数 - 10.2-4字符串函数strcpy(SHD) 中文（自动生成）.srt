1
00:00:04,240 --> 00:00:06,190
这个函数叫做s t r c p y

2
00:00:06,190 --> 00:00:08,230
c p y的意思是copy

3
00:00:08,230 --> 00:00:13,560
所以他做的事情是第二个参数里头

4
00:00:13,560 --> 00:00:15,570
所表达的那个字符串

5
00:00:15,570 --> 00:00:18,179
拷贝到第一个参数所表达的

6
00:00:18,179 --> 00:00:20,000
那个空间里头去

7
00:00:20,099 --> 00:00:21,300
也就是说

8
00:00:21,620 --> 00:00:25,460
如果呢我们的src所指向的那块地方

9
00:00:25,460 --> 00:00:27,559
有一些字符串的内容

10
00:00:27,559 --> 00:00:29,199
比如说hello

11
00:00:29,460 --> 00:00:31,710
当然我们知道结尾会有一个零

12
00:00:31,710 --> 00:00:34,109
这儿有那么多个字符

13
00:00:34,109 --> 00:00:38,600
然后呢d s t那儿呢它会指向一块空间

14
00:00:38,600 --> 00:00:40,219
我不管它原来里面有什么

15
00:00:40,219 --> 00:00:43,439
然后我们要做的事情是每一个字符

16
00:00:43,439 --> 00:00:45,929
每一个字符的考过去

17
00:00:48,359 --> 00:00:49,590
所以考完以后

18
00:00:49,590 --> 00:00:51,959
dst那边也是hello了

19
00:00:51,960 --> 00:00:54,539
在这个函数的原型声明里面

20
00:00:54,539 --> 00:00:56,520
出现了我们之前没见过的关键词

21
00:00:56,520 --> 00:00:57,359
restrict

22
00:00:57,359 --> 00:00:59,878
这是c99 的新的关键词

23
00:00:59,878 --> 00:01:01,829
这个关键字的意思是说

24
00:01:01,829 --> 00:01:04,978
你的ssr c和d s t不能重叠

25
00:01:04,978 --> 00:01:06,439
什么叫做重叠

26
00:01:06,439 --> 00:01:07,400
我们现在这样

27
00:01:07,400 --> 00:01:08,629
当然它是不重叠的

28
00:01:08,629 --> 00:01:13,939
如果你说ok这是我的d s t

29
00:01:14,599 --> 00:01:16,299
我的d s t呢可能有

30
00:01:16,299 --> 00:01:19,390
比如说啊那么多个字符

31
00:01:19,390 --> 00:01:22,159
可是呢这是我的r c

32
00:01:23,640 --> 00:01:24,500
这是我的

33
00:01:24,500 --> 00:01:25,219
hello

34
00:01:28,459 --> 00:01:33,340
我希望把hello从这个位置拷贝到这个位置

35
00:01:33,340 --> 00:01:37,420
我希望最后的结果是它出现的是hello

36
00:01:37,859 --> 00:01:38,939
其实这是什么

37
00:01:38,939 --> 00:01:42,599
这是把一段内存从这儿往前移一点是吧

38
00:01:42,599 --> 00:01:43,739
也可能是往后移一点

39
00:01:43,739 --> 00:01:44,819
也就是在这种情况下

40
00:01:44,819 --> 00:01:47,620
你的d s t和s r c是重叠的

41
00:01:47,620 --> 00:01:51,519
这个时候你不能使用我们的str c py

42
00:01:51,519 --> 00:01:53,939
来做拷贝复制的事情

43
00:01:54,780 --> 00:01:56,310
原因是什么呢

44
00:01:56,310 --> 00:01:59,879
原因是现代的这些函数的设计

45
00:01:59,879 --> 00:02:02,539
实际上比我们想象的要复杂得很多

46
00:02:02,539 --> 00:02:07,530
s t r c p y是字符串处理当中极其广泛

47
00:02:07,530 --> 00:02:09,240
大量被使用的一个函数

48
00:02:09,240 --> 00:02:10,860
在这个函数上面

49
00:02:10,860 --> 00:02:13,860
如果它的性能有一点点的小改进

50
00:02:13,860 --> 00:02:15,539
可能对整个程序

51
00:02:15,539 --> 00:02:16,650
对整个系统

52
00:02:16,650 --> 00:02:19,199
甚至可能对整个互联网的运行效率

53
00:02:19,199 --> 00:02:20,460
都有巨大的提升

54
00:02:20,460 --> 00:02:22,449
因此在这个上面

55
00:02:22,449 --> 00:02:23,830
人们用了很多的努力

56
00:02:23,830 --> 00:02:26,590
做了很多的努力来使得它的效率提高

57
00:02:26,590 --> 00:02:28,629
其中一个努力就是

58
00:02:28,629 --> 00:02:31,229
当你的计算机是多核的时候

59
00:02:31,229 --> 00:02:34,469
大家可能都听说过你现在计算机是什么啊

60
00:02:34,469 --> 00:02:35,669
两核四线程

61
00:02:35,669 --> 00:02:36,930
四核八线程等等

62
00:02:36,930 --> 00:02:39,250
当你的计算机是多核的时候

63
00:02:39,250 --> 00:02:42,250
他可能会把你的这个拷贝的工作

64
00:02:42,250 --> 00:02:43,810
分成好几段

65
00:02:43,810 --> 00:02:47,149
让每一个和替你去做其中的一段

66
00:02:47,149 --> 00:02:48,348
因此在这种时候

67
00:02:48,348 --> 00:02:50,149
他希望他必须要求

68
00:02:50,149 --> 00:02:53,269
你的d s t和ssr c是不重叠的

69
00:02:53,269 --> 00:02:54,280
如果重叠

70
00:02:54,539 --> 00:02:57,240
这些拷贝互相之间分开来的

71
00:02:57,240 --> 00:03:00,060
那一段的拷贝互相之间就会有冲突

72
00:03:00,239 --> 00:03:01,679
另外这个函数要小心的

73
00:03:01,679 --> 00:03:05,399
就是它的参数表里面第一个参数是目的

74
00:03:05,399 --> 00:03:07,050
而第二个参数是圆

75
00:03:07,050 --> 00:03:09,330
我们中国人在思考这些问题的时候

76
00:03:09,330 --> 00:03:12,210
通常会觉得说我要把a拷贝到b

77
00:03:12,210 --> 00:03:15,270
所以我会先说出来原再说出来目的

78
00:03:15,270 --> 00:03:17,780
可是在这个函数里头

79
00:03:17,780 --> 00:03:19,639
它就是把墓地放在前面

80
00:03:19,639 --> 00:03:21,199
把圆放在后面的

81
00:03:21,199 --> 00:03:24,159
和我们平时的这个思维方式会有些不一样

82
00:03:24,159 --> 00:03:26,780
然后这个函数呢还会有一个返回

83
00:03:27,079 --> 00:03:28,399
我们通常可能会觉得

84
00:03:28,399 --> 00:03:29,778
这东西就不需要返回了吧

85
00:03:29,778 --> 00:03:31,038
反正我就做个事情嘛

86
00:03:31,038 --> 00:03:33,840
可是呢它会返回那个d s t

87
00:03:33,840 --> 00:03:34,740
它的返回就是d s

88
00:03:34,740 --> 00:03:37,539
你传给他什么d s t他就返回那个d s t

89
00:03:37,899 --> 00:03:38,739
为什么呢

90
00:03:38,739 --> 00:03:41,318
因为他需要用这种方式

91
00:03:41,318 --> 00:03:43,389
让s t r c p y的结果

92
00:03:43,389 --> 00:03:45,788
能够再参与其他运算

93
00:03:45,788 --> 00:03:49,009
能够在投入给其他函数的参数

94
00:03:49,009 --> 00:03:52,000
所以传统上我们就做成了这样的形式

95
00:03:52,019 --> 00:03:54,989
我们拿s t i c p y经常要做的一件事情

96
00:03:54,989 --> 00:03:56,459
是复制一个字符串

97
00:03:56,459 --> 00:03:58,139
比如说我们从函数的参数

98
00:03:58,139 --> 00:03:59,270
得到了一个字符串

99
00:03:59,270 --> 00:04:00,650
但实际上我们得到的是什么

100
00:04:00,650 --> 00:04:01,340
是个指针

101
00:04:01,340 --> 00:04:02,449
它指向什么地方

102
00:04:02,449 --> 00:04:04,280
外面的某个地方的那么一个字符串

103
00:04:04,280 --> 00:04:06,710
那个字符串不是我这里的

104
00:04:06,710 --> 00:04:09,439
我不能保证那个字符串始终有始终在

105
00:04:09,439 --> 00:04:11,960
所以也许我需要把它复制在我这里

106
00:04:12,778 --> 00:04:14,989
因此我们经常做的是这样的一个操作

107
00:04:14,989 --> 00:04:17,040
我们要去做malloc

108
00:04:17,278 --> 00:04:19,319
我们要去动态分配一块内存

109
00:04:19,319 --> 00:04:20,819
因为我在程序静态的时候

110
00:04:20,819 --> 00:04:22,408
我不知道这块内存有多大

111
00:04:22,408 --> 00:04:25,410
所以我要用malloc去动态的申请一块内存

112
00:04:25,410 --> 00:04:27,660
可是这块内存的大小是多少呢

113
00:04:27,899 --> 00:04:29,819
我们可以用s t r l e

114
00:04:29,819 --> 00:04:31,800
来得到那个字符串的长度

115
00:04:31,800 --> 00:04:35,759
可是我们知道那个长度指的是纯内容的长

116
00:04:35,759 --> 00:04:36,029
度

117
00:04:37,620 --> 00:04:39,230
所以我们需要加一

118
00:04:39,230 --> 00:04:40,220
加一以后

119
00:04:42,829 --> 00:04:44,779
就能放得下那个结尾的零了

120
00:04:44,779 --> 00:04:46,730
然后meloc法国的void star

121
00:04:46,730 --> 00:04:49,629
把它类型转换为trust st

122
00:04:49,629 --> 00:04:51,939
接着我们做s t r c p y

123
00:04:51,939 --> 00:04:54,769
把s r c的东西靠背到d s t

124
00:04:54,769 --> 00:04:56,269
这是一个套路

125
00:04:56,269 --> 00:04:58,339
我们复制字符串就是这么干的

126
00:04:58,339 --> 00:04:59,389
在这个套路当中

127
00:04:59,389 --> 00:05:03,860
很多初学者会犯的毛病是忘了加一

128
00:05:03,860 --> 00:05:06,000
这点要特别小心

129
00:05:06,620 --> 00:05:08,560
那接下来我们要继续研究

130
00:05:08,560 --> 00:05:11,769
说这个s t r cp y函数

131
00:05:11,769 --> 00:05:14,259
我们自己写的话会怎么写

132
00:05:14,259 --> 00:05:16,189
当然我们肯定现在还写不出来

133
00:05:16,189 --> 00:05:17,209
那么高级的什么

134
00:05:17,209 --> 00:05:19,670
还要分分到多个盒里面去做啊什么的

135
00:05:19,670 --> 00:05:20,870
我们先做一个最简单的

136
00:05:20,870 --> 00:05:23,560
真的就只能把ssr c拷贝到d s t

137
00:05:23,560 --> 00:05:24,779
我们怎么写呢

138
00:05:24,800 --> 00:05:26,930
这个函数的两个参数是不一样的

139
00:05:26,930 --> 00:05:28,279
第二个参数是const

140
00:05:28,279 --> 00:05:29,540
第一个参数不是const

141
00:05:29,540 --> 00:05:33,199
因为我们去读第二个参数所指的那块地方

142
00:05:33,199 --> 00:05:35,420
然后把它写到第一个参数作者那块地方

143
00:05:35,420 --> 00:05:37,550
所以第一个参数它不能是cost

144
00:05:37,550 --> 00:05:40,660
然后我们要怎么做拷贝

145
00:05:40,939 --> 00:05:41,899
根据这张图

146
00:05:41,899 --> 00:05:43,040
我们知道我们要做拷贝

147
00:05:43,040 --> 00:05:43,639
其实做的事情

148
00:05:43,639 --> 00:05:47,660
就是逐一从s r c往d s t写写写

149
00:05:47,660 --> 00:05:50,360
写到sr c是零为止

150
00:05:50,500 --> 00:05:53,740
ok那么我们自己怎么做这个啊

151
00:05:53,740 --> 00:05:54,459
copy函数呢

152
00:05:54,459 --> 00:05:56,589
我们先从数组的版本开始

153
00:05:56,589 --> 00:05:58,720
所以我们当然需要有一个index

154
00:05:58,720 --> 00:05:59,920
我们让它等于零

155
00:05:59,920 --> 00:06:03,899
我们需要让这个index表达两件事情

156
00:06:03,899 --> 00:06:06,240
一方面他是在ssr c那里

157
00:06:06,240 --> 00:06:07,920
我要去走第几个

158
00:06:07,920 --> 00:06:09,810
一方面也是在d s t那边

159
00:06:09,810 --> 00:06:11,370
我要拷贝到第几个

160
00:06:11,370 --> 00:06:12,689
因为在过程当中

161
00:06:12,689 --> 00:06:13,459
我们会说

162
00:06:13,459 --> 00:06:16,418
d s t的那个i d x

163
00:06:16,418 --> 00:06:19,629
要等于ssr c的那个i d x

164
00:06:19,629 --> 00:06:21,779
然后当然i d x要加加

165
00:06:21,779 --> 00:06:24,899
接着我们要把这个事情放在一个循环里头

166
00:06:24,899 --> 00:06:27,180
我们会说哇某种条件成立的时候

167
00:06:27,180 --> 00:06:28,980
我们要去做这个事情

168
00:06:28,980 --> 00:06:30,930
那这个条件是什么呢

169
00:06:30,930 --> 00:06:34,360
条件是说ssr c的那个i d x

170
00:06:34,939 --> 00:06:36,920
不等于这个零

171
00:06:38,779 --> 00:06:40,779
但这样做完够不够呢

172
00:06:43,459 --> 00:06:44,800
我们这么做

173
00:06:44,800 --> 00:06:47,699
当这个循环结束的时候

174
00:06:48,319 --> 00:06:49,899
当循环结束的时候

175
00:06:49,899 --> 00:06:51,420
dx在哪里

176
00:06:51,639 --> 00:06:55,060
最后拷贝到d s t里面的是什么

177
00:06:57,379 --> 00:07:02,290
就说我们的src里面有一些东西

178
00:07:02,290 --> 00:07:04,480
最后会有一个零

179
00:07:04,480 --> 00:07:09,389
我们的d s t里面逐渐地拷贝了一些东西

180
00:07:09,389 --> 00:07:12,689
最后一个时刻当i d x在这里的时候

181
00:07:12,689 --> 00:07:15,509
他会把最后的这个东西拷贝过来

182
00:07:15,509 --> 00:07:16,589
所以这有了

183
00:07:16,589 --> 00:07:19,370
比如说这是a这有了那个a

184
00:07:19,370 --> 00:07:24,019
然后当i dx指向他的时候

185
00:07:24,199 --> 00:07:25,550
我们的代码说

186
00:07:25,550 --> 00:07:29,180
这个时候s r c的i d x已经等于零了

187
00:07:29,180 --> 00:07:32,199
于是我们的循环要出去

188
00:07:32,519 --> 00:07:33,689
也就是说

189
00:07:33,689 --> 00:07:41,499
那句d s t的i d x等于src的dx

190
00:07:41,499 --> 00:07:43,119
还没有做的时候

191
00:07:43,119 --> 00:07:44,160
我们就离开了

192
00:07:44,459 --> 00:07:47,040
因此当那个循环结束的时候

193
00:07:47,040 --> 00:07:48,600
i d x停留在这里

194
00:07:48,600 --> 00:07:52,798
而d s t最后的那个零还没有写进去

195
00:07:55,259 --> 00:07:58,300
所以我们需要做一件事情

196
00:07:58,300 --> 00:08:01,240
在这个循环结束以后再做一个复制

197
00:08:01,240 --> 00:08:04,298
说d s t的i d x等于等于什么呢

198
00:08:04,298 --> 00:08:06,779
当然你可以让它等于s r c的i d x

199
00:08:06,779 --> 00:08:11,168
你也可以让它等于就是那个零嘛

200
00:08:11,168 --> 00:08:12,959
所以可以等于这个

201
00:08:15,019 --> 00:08:17,439
当然有很多可以做小优化的地方

202
00:08:17,439 --> 00:08:19,658
比如说这个不等于零呢

203
00:08:19,658 --> 00:08:20,978
可以直接没有

204
00:08:20,978 --> 00:08:24,430
因为不等于零就意味着不是零嘛

205
00:08:24,430 --> 00:08:26,019
所以不是零

206
00:08:26,019 --> 00:08:30,300
正好就是对于y来说是个能够满足的条件

207
00:08:31,319 --> 00:08:33,078
这是我们的数组版本

208
00:08:33,078 --> 00:08:35,058
我们的指针版本可以怎么写呢

209
00:08:36,078 --> 00:08:38,340
我们的指针版本可以这样做

210
00:08:38,340 --> 00:08:40,500
你看其实我们要做的是d s t

211
00:08:40,500 --> 00:08:43,179
新dc等于新ssr c

212
00:08:43,179 --> 00:08:45,039
然后d s t加加

213
00:08:45,039 --> 00:08:47,120
然后sc加加

214
00:08:48,220 --> 00:08:49,019
对不对

215
00:08:49,019 --> 00:08:54,139
那我们的条件是说这个新ssr c呢不等于

216
00:08:56,340 --> 00:08:59,179
循环里面呢去做这样三件事情

217
00:08:59,179 --> 00:09:01,700
当然一样的问题

218
00:09:01,700 --> 00:09:02,539
做完之后

219
00:09:02,539 --> 00:09:05,438
新d s t要等于那个零

220
00:09:07,279 --> 00:09:10,360
所以这是我们的指针版本

221
00:09:10,360 --> 00:09:12,399
但是指针版本这个时候还有一个问题

222
00:09:12,399 --> 00:09:13,779
你不能return这个d s t了

223
00:09:13,779 --> 00:09:15,340
因为d s t被我们加加加加加

224
00:09:15,340 --> 00:09:16,360
加到后面去了

225
00:09:16,360 --> 00:09:18,539
所以我们还得用另外一个指针

226
00:09:18,539 --> 00:09:21,779
比如说r e t呢等于d s t先记录一下

227
00:09:21,779 --> 00:09:24,539
最后return的时候要return这个i e t

228
00:09:25,460 --> 00:09:29,049
当然这个指针版本就会很有意思了

229
00:09:33,009 --> 00:09:34,078
对不对

230
00:09:34,519 --> 00:09:37,019
我们不需要有这两行了

231
00:09:38,559 --> 00:09:41,580
然后这个不等于零

232
00:09:41,580 --> 00:09:43,200
也可以拿掉条件

233
00:09:43,200 --> 00:09:45,438
只要是新sc就可以了

234
00:09:46,139 --> 00:09:47,179
对不对

235
00:09:47,179 --> 00:09:49,159
那既然这样

236
00:09:49,159 --> 00:09:52,078
你看这一行的结果是什么

237
00:09:52,840 --> 00:09:53,940
这一行赋值

238
00:09:53,940 --> 00:09:54,779
这是腐值运算

239
00:09:54,779 --> 00:09:55,740
符值运算是个表达式

240
00:09:55,740 --> 00:09:58,379
这个表达式的结果不就是新s r c吗

241
00:09:58,379 --> 00:10:02,139
所以我们也可以把它移到这里去

242
00:10:03,559 --> 00:10:08,659
然后这个while就只剩下一个空循环了

243
00:10:11,659 --> 00:10:14,399
这么做没有别的意思

244
00:10:15,299 --> 00:10:19,580
只是我们在通过这个函数在表达说哦

245
00:10:19,580 --> 00:10:20,899
你看c语言可以这么干

246
00:10:20,899 --> 00:10:22,580
可以把代码写成这个样子哇

247
00:10:22,580 --> 00:10:24,259
这个娃娃循环啥也没有了

248
00:10:25,460 --> 00:10:26,740
其实你写成这个样子

249
00:10:26,740 --> 00:10:29,470
和我们最开始的那个指针版本编译器

250
00:10:29,470 --> 00:10:31,269
产生的最终的代码是一样的

251
00:10:31,269 --> 00:10:32,590
运行的效率是一样的

252
00:10:32,590 --> 00:10:35,110
我相信好的现代的好的编译器

253
00:10:35,110 --> 00:10:38,830
一定也会给你做出最后一样的编译效果来

254
00:10:38,830 --> 00:10:40,750
所以你不在乎自己

255
00:10:40,750 --> 00:10:42,220
是不是一定要把它做成这个样子

