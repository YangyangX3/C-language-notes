1
00:00:04,200 --> 00:00:05,759
如果函数是有参数的

2
00:00:05,759 --> 00:00:07,500
那么我们在调用它的时候

3
00:00:07,500 --> 00:00:08,580
就必须传递给它的

4
00:00:08,580 --> 00:00:12,460
数量和类型都完全匹配的值

5
00:00:13,160 --> 00:00:15,019
我们可以传递给函数的值呢

6
00:00:15,019 --> 00:00:16,460
是表达式的结果

7
00:00:16,460 --> 00:00:18,050
我们在表达式里边学过

8
00:00:18,050 --> 00:00:19,339
其实对于c语言来说

9
00:00:19,339 --> 00:00:22,780
表达式是一个非常非常宽的术语

10
00:00:22,780 --> 00:00:24,879
很多东西都可以看作是表达式

11
00:00:24,879 --> 00:00:27,280
单一的字面量是表达式

12
00:00:27,280 --> 00:00:31,059
单一的变量是表达式进行计算的结果

13
00:00:31,059 --> 00:00:32,200
也是表达式

14
00:00:32,200 --> 00:00:34,488
连赋值都是表达式

15
00:00:34,488 --> 00:00:38,579
那么函数调用本身其实它也是一个表达式

16
00:00:39,539 --> 00:00:41,000
好函数调用本身也是表达

17
00:00:41,000 --> 00:00:42,740
是这个函数调用的结果

18
00:00:42,740 --> 00:00:44,539
如果这个函数有返回值的话

19
00:00:44,539 --> 00:00:46,820
它可以作为一个值

20
00:00:46,820 --> 00:00:48,518
作为一种表达式

21
00:00:48,518 --> 00:00:51,548
也可以用来给其他函数提供值

22
00:00:51,548 --> 00:00:53,418
我们看到在我们这个代码里面

23
00:00:53,520 --> 00:00:55,380
给他两个字面量

24
00:00:55,380 --> 00:00:56,429
给它两个变量

25
00:00:56,429 --> 00:00:57,119
给它一个变量

26
00:00:57,119 --> 00:01:01,149
一个字面量给它一个函数返回的结果

27
00:01:01,149 --> 00:01:03,070
甚至可能就是自己这种函数

28
00:01:03,070 --> 00:01:04,500
注意在这儿

29
00:01:04,500 --> 00:01:06,989
我们的max会被调用两次

30
00:01:06,989 --> 00:01:07,569
对不对

31
00:01:07,569 --> 00:01:10,480
第一次做了max 23和四五

32
00:01:10,480 --> 00:01:11,829
它会得到一个结果四五

33
00:01:11,829 --> 00:01:15,719
然后那个四五和a再用来去做一次max

34
00:01:16,060 --> 00:01:20,930
同一个函数在这一行里头被调用了两次

35
00:01:20,930 --> 00:01:22,609
我们也可以是一个计算的结果

36
00:01:22,609 --> 00:01:25,129
23+45是一个表达式

37
00:01:25,129 --> 00:01:28,790
它的结果不会被存放在任何的变量里头

38
00:01:28,790 --> 00:01:29,959
但是它的结果

39
00:01:29,959 --> 00:01:33,819
这个值会被传递进入那个max函数

40
00:01:33,819 --> 00:01:36,368
然后和b一起去做那个max的运算

41
00:01:36,368 --> 00:01:38,528
如果你调用函数的时候

42
00:01:38,528 --> 00:01:42,650
给的值和参数的类型不匹配会怎么样

43
00:01:42,650 --> 00:01:43,730
我们来试一下

44
00:01:43,730 --> 00:01:45,709
我们现在让我们的这个char函数

45
00:01:45,709 --> 00:01:48,500
会得到一个整数的一个参数

46
00:01:48,500 --> 00:01:49,010
然后呢

47
00:01:49,010 --> 00:01:51,599
我们会把这个整数整形的参数给打印出来

48
00:01:51,879 --> 00:01:53,379
如果我们调用它的时候

49
00:01:53,379 --> 00:01:55,120
给他的是二胆子

50
00:01:55,120 --> 00:01:56,109
肯定没有问题

51
00:01:56,109 --> 00:01:58,200
他会输出那个缺二

52
00:01:58,719 --> 00:02:01,450
如果我们给他的是2.4

53
00:02:01,450 --> 00:02:05,140
那我们在编译的时候会得到一个亡灵

54
00:02:05,159 --> 00:02:06,239
他会说呢

55
00:02:06,239 --> 00:02:10,740
在这里出现了隐含的从double到int的转换

56
00:02:10,740 --> 00:02:16,058
这个转换呢会把值从2.4变到二啊

57
00:02:16,058 --> 00:02:17,258
从2.40变到二

58
00:02:17,258 --> 00:02:18,729
所以呢你会有损失

59
00:02:18,729 --> 00:02:19,959
他认为是这样子的

60
00:02:19,959 --> 00:02:21,098
但是这只是一个网瘾

61
00:02:21,098 --> 00:02:22,479
所以我们仍然能够得到结果

62
00:02:22,479 --> 00:02:24,699
而这个结果确实就是二

63
00:02:25,079 --> 00:02:28,079
我还得说在你的编译器上

64
00:02:28,079 --> 00:02:30,460
这句亡灵不一定会出现的

65
00:02:30,780 --> 00:02:32,340
我们还可以再试一个

66
00:02:32,340 --> 00:02:34,479
如果我说的是二点

67
00:02:35,218 --> 00:02:37,848
现在他连这句亡灵都没有了

68
00:02:37,848 --> 00:02:38,899
他觉得没关系吗

69
00:02:38,899 --> 00:02:39,438
二点吗

70
00:02:39,438 --> 00:02:41,989
二点就是二码那边反正是个int嘛

71
00:02:41,989 --> 00:02:43,259
给了你二

72
00:02:43,699 --> 00:02:46,819
如果我现在是个double的一个变量

73
00:02:46,819 --> 00:02:48,960
就是f等于2.4

74
00:02:49,199 --> 00:02:50,280
然后好

75
00:02:50,280 --> 00:02:51,780
我们先来试这个二点的问题

76
00:02:51,780 --> 00:02:54,219
然后我们让它做缺

77
00:02:55,659 --> 00:02:56,580
没有抱怨

78
00:02:56,580 --> 00:02:57,360
没有warning

79
00:02:57,360 --> 00:02:59,400
如果这是f等于2.4

80
00:03:01,419 --> 00:03:02,819
也没有抱怨

81
00:03:02,819 --> 00:03:04,319
当然结果是二

82
00:03:04,319 --> 00:03:08,389
所以这是c语言在传统上最大的漏洞

83
00:03:08,389 --> 00:03:09,680
就调用函数的时候

84
00:03:09,680 --> 00:03:13,900
你给的值和参数的类型可以不那么的匹配

85
00:03:14,159 --> 00:03:17,550
编译器会悄悄地替你把类型转换好

86
00:03:17,550 --> 00:03:18,599
他反正知道了

87
00:03:18,599 --> 00:03:19,740
那头是int

88
00:03:19,740 --> 00:03:20,699
你这边给个double

89
00:03:20,699 --> 00:03:21,460
ok我帮你转

90
00:03:21,460 --> 00:03:22,300
那边是double

91
00:03:22,300 --> 00:03:23,020
你给了int

92
00:03:23,020 --> 00:03:24,259
ok我帮你转

93
00:03:24,899 --> 00:03:26,838
表面上看起来这很好

94
00:03:26,838 --> 00:03:27,139
对不对

95
00:03:27,139 --> 00:03:28,579
你看有个田螺姑娘

96
00:03:28,579 --> 00:03:30,318
她帮你把事情都做好了

97
00:03:30,318 --> 00:03:32,960
可是也许有的时候

98
00:03:32,960 --> 00:03:36,449
这正是我们犯了错误的地方

99
00:03:36,449 --> 00:03:40,919
我本来呢应该要让那个切函数

100
00:03:40,919 --> 00:03:42,239
接受一个double的

101
00:03:42,239 --> 00:03:43,620
我写成了int

102
00:03:43,659 --> 00:03:46,569
我以为我写的确函数是double的

103
00:03:46,569 --> 00:03:49,539
所以呢我给了他一个double的值

104
00:03:49,560 --> 00:03:52,439
然后编译器没有替我查出来

105
00:03:52,439 --> 00:03:52,979
我给了他

106
00:03:52,979 --> 00:03:53,699
2.4

107
00:03:53,699 --> 00:03:56,080
到了券那边只剩下二了

108
00:03:58,139 --> 00:04:00,439
所以可能这本来是编译器能替我

109
00:04:00,439 --> 00:04:01,219
查出来的事情

110
00:04:02,240 --> 00:04:03,379
c语言做不到

111
00:04:04,020 --> 00:04:05,719
c语言后面的一些语言

112
00:04:05,719 --> 00:04:06,560
像c加加

113
00:04:06,560 --> 00:04:08,840
java在这方面非常的严格

114
00:04:08,840 --> 00:04:11,900
那么它会对这种调用函数的时候

115
00:04:11,900 --> 00:04:14,000
值和参数的匹配类型的匹配

116
00:04:14,000 --> 00:04:16,259
检查的比c语言要严格得多

117
00:04:17,999 --> 00:04:20,538
我们还得再考虑另外一个问题

118
00:04:20,538 --> 00:04:22,879
我们调用函数的时候

119
00:04:22,879 --> 00:04:25,220
传过去的到底是什么

120
00:04:26,560 --> 00:04:29,079
比如说我们写了这样一个swap函数

121
00:04:29,079 --> 00:04:30,399
我们之前知道说

122
00:04:30,399 --> 00:04:32,110
如果我们要交换两个变量的值

123
00:04:32,110 --> 00:04:33,790
我们需要利用第三方

124
00:04:33,790 --> 00:04:36,839
第三个变量来做一下中间的每一介

125
00:04:36,839 --> 00:04:38,040
我们让它等于a

126
00:04:38,040 --> 00:04:38,699
然后a等于b

127
00:04:38,699 --> 00:04:39,060
b等于t

128
00:04:39,060 --> 00:04:41,100
这样我们就可以交换a和b的值

129
00:04:41,779 --> 00:04:43,180
可能我们我们在程序里面

130
00:04:43,180 --> 00:04:45,160
经常要去交换a和b的值

131
00:04:45,160 --> 00:04:47,420
所以我觉得我们应该写出一个函数来

132
00:04:47,420 --> 00:04:50,899
用这个函数去交换a的a和b的值

133
00:04:50,899 --> 00:04:52,829
这样呢我们在程序里面以后呃

134
00:04:52,829 --> 00:04:54,029
每次要交换a和b的值

135
00:04:54,029 --> 00:04:54,870
调个函数就可以了

136
00:04:54,870 --> 00:04:57,029
所以呢我们有了sp函数以后

137
00:04:57,029 --> 00:04:58,410
我们做了a和b两个变量

138
00:04:58,410 --> 00:04:59,920
然后我们说sp a和b

139
00:05:00,120 --> 00:05:02,399
可是这样的代码

140
00:05:02,399 --> 00:05:04,259
真的能够交换a和b的值吗

141
00:05:04,860 --> 00:05:08,019
进入现在在这儿

142
00:05:08,639 --> 00:05:12,240
我们的x和y原来是五和六

143
00:05:12,240 --> 00:05:15,649
然后经过这一轮交换

144
00:05:15,649 --> 00:05:17,040
它变成了六和五

145
00:05:17,319 --> 00:05:18,910
它变成了六和五

146
00:05:18,910 --> 00:05:22,800
但是和main里面的a和b没有任何关系

147
00:05:23,399 --> 00:05:27,120
顺便如果我们这个时候要去刷a和b的值

148
00:05:27,120 --> 00:05:31,459
会看到说not found in current context

149
00:05:31,459 --> 00:05:34,519
在当前的上下文找不到

150
00:05:36,279 --> 00:05:38,040
在当前的上下文找不到

151
00:05:39,300 --> 00:05:43,629
也就是说现在我们的这个

152
00:05:43,629 --> 00:05:46,269
在我们现在在这个sp函数里头的时候

153
00:05:46,269 --> 00:05:48,819
a和b是不存在的

154
00:05:48,819 --> 00:05:50,600
这件事情我们一会儿来讲

155
00:05:52,339 --> 00:05:54,079
现在我们都swap回去了

156
00:05:55,540 --> 00:06:00,819
当然回到这a和b的值没有丝毫的影响

157
00:06:01,319 --> 00:06:04,740
不过这个时候如果你想去看x和y

158
00:06:04,740 --> 00:06:07,470
他们也是not found in current context

159
00:06:07,470 --> 00:06:09,199
这事儿我们一会儿来解释

160
00:06:09,658 --> 00:06:13,000
所以我们看到说c语言在调用函数的时候

161
00:06:13,060 --> 00:06:15,160
只能传只给那个函数

162
00:06:15,160 --> 00:06:17,680
当我们在这儿做sp a b的时候

163
00:06:17,680 --> 00:06:21,589
我们是把a的值五交给了swap里头的a

164
00:06:21,589 --> 00:06:24,079
把b的值六交给了swap里头的b

165
00:06:24,079 --> 00:06:26,300
这两个a b和命令的a b

166
00:06:26,300 --> 00:06:28,399
是完全没有任何关系的

167
00:06:28,399 --> 00:06:29,360
虽然他们同名

168
00:06:29,360 --> 00:06:31,009
但是他们处在不同的地方

169
00:06:31,009 --> 00:06:32,959
它们是没有任何联系的变量

170
00:06:32,959 --> 00:06:34,759
它们之间的联系

171
00:06:34,759 --> 00:06:37,910
仅仅是在调用的时候传递了值

172
00:06:37,910 --> 00:06:41,459
过去a的值给了swap里的a

173
00:06:41,459 --> 00:06:43,529
b的值给了swap里的b

174
00:06:43,529 --> 00:06:44,819
除此以外

175
00:06:44,819 --> 00:06:48,569
这两个变量和这两个参数没有别的联系

176
00:06:48,569 --> 00:06:51,329
所以我们在sp里面对a和b做的任何事情

177
00:06:51,329 --> 00:06:53,920
是swap自己的参数

178
00:06:53,920 --> 00:06:58,139
a和b的事情和命的a和b没有任何关系

179
00:06:58,360 --> 00:07:01,420
这样的代码不能交换a和b的值

180
00:07:02,319 --> 00:07:05,040
到目前我们没有办法可以去做出

181
00:07:05,040 --> 00:07:07,800
我们想要的那种swap函数的效果

182
00:07:07,800 --> 00:07:11,160
所以每个函数呢有它自己的变量

183
00:07:11,160 --> 00:07:15,050
空间参数也是在这个独立的空间当中

184
00:07:15,050 --> 00:07:16,430
和其他函数没有关系

185
00:07:16,430 --> 00:07:18,199
你还记不记得我们前面看的

186
00:07:18,199 --> 00:07:21,240
not found in current context

187
00:07:21,240 --> 00:07:22,680
在main里头

188
00:07:22,680 --> 00:07:26,079
swap里头的xy不存在了

189
00:07:26,180 --> 00:07:27,680
当我们在sp里头的时候

190
00:07:27,680 --> 00:07:31,100
当时a和b也是not found in current contest

191
00:07:31,100 --> 00:07:32,550
它们不存在了

192
00:07:32,550 --> 00:07:36,750
每一个变量都只在他自己那个函数所在的

193
00:07:36,750 --> 00:07:37,980
那个空间里头

194
00:07:38,019 --> 00:07:40,540
所以每一个函数有自己的变量空间

195
00:07:40,540 --> 00:07:42,660
和其他函数是没有关系的

196
00:07:43,060 --> 00:07:43,569
呃

197
00:07:43,569 --> 00:07:45,399
其实到后面我们再讲到

198
00:07:45,399 --> 00:07:46,930
递归这件事情的时候

199
00:07:46,930 --> 00:07:50,139
我们还会把这个事情这个这个概念再展开

200
00:07:50,139 --> 00:07:51,560
这还是动态的

201
00:07:51,680 --> 00:07:54,139
这一次的运行和下一次的运行

202
00:07:54,139 --> 00:07:55,399
也是没有关系的

203
00:07:55,399 --> 00:07:57,379
但这件事情我们到后面再来讲

204
00:07:58,399 --> 00:07:59,800
那过去呢

205
00:07:59,800 --> 00:08:02,980
传统的教科书会对于函数参数表当中

206
00:08:02,980 --> 00:08:05,860
参数把它们叫做形式参数

207
00:08:06,459 --> 00:08:08,160
在函数的参数表里面

208
00:08:08,160 --> 00:08:09,839
包括原型声明

209
00:08:09,839 --> 00:08:10,889
包括函数定义

210
00:08:10,889 --> 00:08:13,319
在参数表里面呢叫做形式参数

211
00:08:13,319 --> 00:08:14,730
formal parameter

212
00:08:14,730 --> 00:08:16,740
然后我们调用函数的时候

213
00:08:16,740 --> 00:08:20,139
给的值呢叫做实际参数食材

214
00:08:20,139 --> 00:08:21,459
当我们去调用函数的时候

215
00:08:21,459 --> 00:08:22,360
给他的a和b

216
00:08:22,360 --> 00:08:23,620
这是实际参数

217
00:08:23,620 --> 00:08:26,350
real parameter或者actual parameter

218
00:08:26,350 --> 00:08:28,610
然后他会说哦

219
00:08:28,610 --> 00:08:32,330
那呃食餐呢和行餐要去怎么做匹配啊

220
00:08:32,330 --> 00:08:35,818
食餐呢呃要怎么把值传给形参等等

221
00:08:36,200 --> 00:08:40,960
但是因为容易让初学者呢误会

222
00:08:40,960 --> 00:08:42,700
所谓的实际参数

223
00:08:42,700 --> 00:08:46,029
就是实际在函数中进行计算的参数

224
00:08:46,029 --> 00:08:48,269
初学者看到说哦这叫做real

225
00:08:48,269 --> 00:08:48,870
这是real的

226
00:08:48,870 --> 00:08:49,590
这是formal的

227
00:08:49,590 --> 00:08:51,690
所以呢哦但实际上呢就是real的意思

228
00:08:51,690 --> 00:08:52,919
就是我的这个a呢

229
00:08:52,919 --> 00:08:54,679
实际会在那个swap里面

230
00:08:54,679 --> 00:08:56,629
作为实际的参数去参与运算

231
00:08:56,629 --> 00:08:58,639
会误会调用函数的时候

232
00:08:58,639 --> 00:09:01,438
把变量而不是直传进去了

233
00:09:01,600 --> 00:09:04,360
所以我们不建议继续用这种古老的方式

234
00:09:04,360 --> 00:09:05,289
来称呼他们

235
00:09:05,289 --> 00:09:06,940
形参和实参的概念

236
00:09:06,940 --> 00:09:11,049
来自于人类第一个高级编程语言for权

237
00:09:13,029 --> 00:09:14,299
但是实际上

238
00:09:14,600 --> 00:09:17,360
现在在现代的这些编程语言上面

239
00:09:17,360 --> 00:09:20,068
他们的概念已经不太适用了

240
00:09:20,068 --> 00:09:21,389
因为在fortune里面

241
00:09:21,389 --> 00:09:22,828
我们还有另外一种

242
00:09:22,828 --> 00:09:24,839
可以把变量传进去的方式

243
00:09:24,839 --> 00:09:28,379
c语言没有c语言都是传值

244
00:09:28,379 --> 00:09:30,779
我们认为这个就叫做参数题

245
00:09:30,779 --> 00:09:31,799
我们就把它叫做参数

246
00:09:31,799 --> 00:09:32,938
这是parameter

247
00:09:33,100 --> 00:09:34,990
而调用函数的时候

248
00:09:34,990 --> 00:09:38,379
这是值参数和值的关系

249
00:09:38,919 --> 00:09:41,539
用这种方式来解释这个事情

250
00:09:41,740 --> 00:09:43,419
更容易让初学者理解

251
00:09:43,419 --> 00:09:45,220
这中间到底发生了什么

252
00:09:45,220 --> 00:09:47,529
这中间发生的就只有一件事情

253
00:09:47,529 --> 00:09:48,399
传直

