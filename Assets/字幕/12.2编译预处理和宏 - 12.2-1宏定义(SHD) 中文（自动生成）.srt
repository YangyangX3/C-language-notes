1
00:00:04,540 --> 00:00:07,000
这个编译预处理指令啊

2
00:00:07,000 --> 00:00:08,679
其实我们很早就见过了

3
00:00:09,519 --> 00:00:11,999
我们的第一个c语言的程序

4
00:00:11,999 --> 00:00:12,939
那个hello world

5
00:00:13,339 --> 00:00:14,900
它的第一行

6
00:00:14,900 --> 00:00:18,239
他的第一个字符那个井号

7
00:00:19,500 --> 00:00:22,140
就说明它是一条便预处理指令

8
00:00:24,339 --> 00:00:26,820
就说明它是一条变异预处理指令

9
00:00:26,820 --> 00:00:29,429
所有的c语言的编译预处理指令呢

10
00:00:29,429 --> 00:00:31,300
都是以井号开头的

11
00:00:32,399 --> 00:00:35,060
实际上这些井号开头的东西

12
00:00:35,060 --> 00:00:37,039
它并不是c语言的成分

13
00:00:37,039 --> 00:00:40,520
但是呢任何一个c语言的程序都离不开他

14
00:00:40,520 --> 00:00:40,918
们

15
00:00:41,039 --> 00:00:43,079
之所以说它不是c语言的成分

16
00:00:43,079 --> 00:00:45,000
是因为这些东西

17
00:00:45,000 --> 00:00:46,020
你看比如说include

18
00:00:46,020 --> 00:00:47,779
它不是c语言的关键字啊

19
00:00:47,960 --> 00:00:49,700
也不是只有c语言在使用

20
00:00:49,700 --> 00:00:51,109
这些编译预处理指令

21
00:00:51,109 --> 00:00:53,039
其他语言也可以去使用

22
00:00:53,740 --> 00:00:57,969
那么我们之前看到的都是井号include啊

23
00:00:57,969 --> 00:01:00,250
当然这个井号在英文里头怎么念啊

24
00:01:00,250 --> 00:01:01,630
这个我们小的时候

25
00:01:01,630 --> 00:01:03,619
这个这个符号是念做punch啊

26
00:01:03,659 --> 00:01:04,859
打个挫啊

27
00:01:04,859 --> 00:01:06,899
这个意思呃

28
00:01:07,540 --> 00:01:09,810
这个井号include呢

29
00:01:09,810 --> 00:01:13,840
它是这个用来呃引入一个头文件的啊

30
00:01:13,840 --> 00:01:16,000
这是我们到后面讲大程序结构的时候

31
00:01:16,000 --> 00:01:16,689
我们再来说

32
00:01:16,689 --> 00:01:18,579
我们先来看另外一个小东西

33
00:01:18,579 --> 00:01:20,299
叫做井号define

34
00:01:21,060 --> 00:01:21,420
呃

35
00:01:21,420 --> 00:01:22,980
这是我们之前没做过啊

36
00:01:22,980 --> 00:01:24,000
呃我们来做一下

37
00:01:24,000 --> 00:01:27,560
看原本呢我们可能写程序是这样写啊

38
00:01:27,560 --> 00:01:29,840
我们我们要用到一个叫做pie的东西

39
00:01:29,840 --> 00:01:31,849
然后呢我们之前提到过说

40
00:01:31,849 --> 00:01:34,989
那你如果呃程序里面直接写

41
00:01:34,989 --> 00:01:38,769
比如说我这句prinni直接写成说二乘以

42
00:01:38,769 --> 00:01:42,409
这个3.14159啊

43
00:01:42,409 --> 00:01:44,840
那这个3.14159是个什么样的东西

44
00:01:44,840 --> 00:01:47,120
别人可能会有各种各样的想法

45
00:01:47,120 --> 00:01:49,849
所以呢我们更好的方式是把这个常数呢

46
00:01:49,849 --> 00:01:52,549
3.14159呢做成一个constant double啊

47
00:01:52,549 --> 00:01:55,618
做成一个不可变的w的变量

48
00:01:56,079 --> 00:01:57,730
这是c99 的做法

49
00:01:57,730 --> 00:01:59,620
如果你在用ecc

50
00:01:59,620 --> 00:02:00,849
你在用更老的版本

51
00:02:00,849 --> 00:02:02,829
它没有cost这样的东西可以用

52
00:02:02,829 --> 00:02:04,900
那个时候人们就要用这样的方法说

53
00:02:04,900 --> 00:02:09,310
我们要define一个叫做pie的东西

54
00:02:09,310 --> 00:02:13,020
它是3.14159啊

55
00:02:13,020 --> 00:02:13,800
如果这样子

56
00:02:13,800 --> 00:02:15,960
当然这程序还是一样的

57
00:02:15,960 --> 00:02:18,419
所以这一行这行define

58
00:02:18,419 --> 00:02:21,030
我们就在定义一个符号

59
00:02:21,030 --> 00:02:22,830
我们把这样的定义出来的符号呢

60
00:02:22,830 --> 00:02:25,118
叫做一个红派

61
00:02:25,118 --> 00:02:26,199
是这个红的名字

62
00:02:26,199 --> 00:02:28,419
而3.14159是这个红的

63
00:02:28,419 --> 00:02:31,699
直c语言的程序在编译的时候呢

64
00:02:31,699 --> 00:02:33,859
准确的说在编译之前

65
00:02:33,859 --> 00:02:36,199
因为它叫做编译预处理指令对吧

66
00:02:36,199 --> 00:02:40,289
所以在编译之前会先做一次编译预处理

67
00:02:40,289 --> 00:02:41,879
在那次预处理里头呢

68
00:02:41,879 --> 00:02:44,939
会把所有的你的程序里头的这种派

69
00:02:44,939 --> 00:02:49,400
都替换成后面的这个3.14159呃

70
00:02:49,400 --> 00:02:51,439
我们有一个办法可以去看到

71
00:02:51,439 --> 00:02:55,340
在编译过程当中留下来的那些临时文件

72
00:02:55,340 --> 00:02:56,780
是需要这么做的

73
00:02:56,780 --> 00:02:58,180
如果是g c c的话

74
00:02:58,399 --> 00:03:00,139
现在呢在我们这个目录底下

75
00:03:00,139 --> 00:03:02,039
只有我们的这个源代码文件啊

76
00:03:02,039 --> 00:03:03,419
本来呢我们编译的时候

77
00:03:03,419 --> 00:03:05,639
只要说g c c这个什么点c就行了

78
00:03:05,639 --> 00:03:07,169
给我们生成a.l o u t

79
00:03:07,169 --> 00:03:08,849
现在呢我们加一个选项

80
00:03:08,849 --> 00:03:12,270
两个减号save tt

81
00:03:12,270 --> 00:03:16,199
保存编译过程当中的这些临时文件

82
00:03:16,259 --> 00:03:18,990
然后我们来看一下给我们生成了什么

83
00:03:18,990 --> 00:03:21,240
除了我们最终要用来运行的那个a点

84
00:03:21,240 --> 00:03:22,300
out之外

85
00:03:22,338 --> 00:03:26,718
我们源代码幺二点c.c.12.3

86
00:03:26,718 --> 00:03:27,438
点c之外

87
00:03:27,438 --> 00:03:28,788
我们还多了一个点i

88
00:03:28,788 --> 00:03:30,599
一个点o和一个点s

89
00:03:31,699 --> 00:03:33,620
当然这三个文件

90
00:03:33,620 --> 00:03:35,539
现在它这个排列是按照字母顺序啊

91
00:03:35,539 --> 00:03:38,000
但它并不是真正程序

92
00:03:38,000 --> 00:03:39,979
编译过程当中产生的那个顺序

93
00:03:39,979 --> 00:03:41,430
首先产生的是点i

94
00:03:41,430 --> 00:03:44,870
或者说我们从点c呢可以得到那个点点i

95
00:03:44,870 --> 00:03:47,449
然后从点i呢得到了那个点s

96
00:03:47,449 --> 00:03:49,370
再从点s呢得到了那个点o

97
00:03:49,370 --> 00:03:52,120
再从点o呢得到了那个a.o u t

98
00:03:52,899 --> 00:03:55,019
这个点c是我们的源代码啊

99
00:03:55,019 --> 00:03:58,679
那么源代码的经过编译预处理做完以后呢

100
00:03:58,679 --> 00:04:02,590
产生了编译预处理以后的一个呃临时呃

101
00:04:02,590 --> 00:04:04,060
这个中间结果文件

102
00:04:04,060 --> 00:04:06,849
就是把当中所有的编译预处理指令

103
00:04:06,849 --> 00:04:07,829
都执行完

104
00:04:07,829 --> 00:04:10,769
比如说define那个红要去做替换的

105
00:04:10,769 --> 00:04:12,189
把它替换掉啊

106
00:04:12,189 --> 00:04:15,909
然后对点i才真正真正是由c的编译起来

107
00:04:15,909 --> 00:04:18,009
做编译去产生了一个点s

108
00:04:18,009 --> 00:04:19,829
这是汇编代码文件

109
00:04:19,829 --> 00:04:23,279
然后汇编代码文件呢去做汇编

110
00:04:23,279 --> 00:04:25,360
变成了一个目标代码文件

111
00:04:25,360 --> 00:04:26,620
这个目标代码文件

112
00:04:26,620 --> 00:04:28,660
在经过链接和其他东西链接在一起

113
00:04:28,660 --> 00:04:30,639
最后就形成了一个可执行的东西啊

114
00:04:30,639 --> 00:04:32,980
所以是有这么一系列复杂的过程的

115
00:04:32,980 --> 00:04:35,620
那我们来看一下那个点i里头有什么

116
00:04:35,620 --> 00:04:36,699
这个点i其实挺大的

117
00:04:36,699 --> 00:04:39,490
你看我们的点c才186个字节

118
00:04:39,490 --> 00:04:42,550
而点i呢有18k那么大

119
00:04:42,550 --> 00:04:43,060
好

120
00:04:43,060 --> 00:04:44,379
那呃

121
00:04:44,379 --> 00:04:48,069
我们可以用一个这个方式来看这个点i哈

122
00:04:48,069 --> 00:04:50,480
我们看它的尾巴上的几行

123
00:04:51,240 --> 00:04:54,139
我们看到我们的点i的尾巴上的几行

124
00:04:54,139 --> 00:04:54,920
这几行大家很熟悉

125
00:04:54,920 --> 00:04:56,060
就是我们刚才那个源代码

126
00:04:56,060 --> 00:04:56,610
对不对

127
00:04:56,610 --> 00:04:59,129
但是不一样的是我们源代码里面

128
00:04:59,129 --> 00:05:01,279
ok如果我们看一下我们源代码

129
00:05:02,959 --> 00:05:05,740
我们的源代码里面这是二乘以派

130
00:05:05,740 --> 00:05:07,420
因为这一行已经被我们注释掉了对吧

131
00:05:07,420 --> 00:05:09,129
所以呢我们写的是二乘以派

132
00:05:09,129 --> 00:05:10,660
派是我们的这个红

133
00:05:10,660 --> 00:05:13,540
可是呢经过编译预处理以后

134
00:05:13,540 --> 00:05:15,579
他把那个派替换掉了

135
00:05:15,579 --> 00:05:19,620
替换成了3.14159呃

136
00:05:19,620 --> 00:05:21,540
在这种替换当中呢

137
00:05:21,540 --> 00:05:25,548
它的编译其实做的是一种非常简单的

138
00:05:25,548 --> 00:05:27,439
原始的文本替换

139
00:05:27,439 --> 00:05:30,060
也就是说你的这个这个名字

140
00:05:30,060 --> 00:05:31,709
这个红的名字后面有什么

141
00:05:31,709 --> 00:05:33,839
就会被替换到那个地方去

142
00:05:33,839 --> 00:05:37,310
假如说如果呢我们做一个define

143
00:05:37,310 --> 00:05:40,160
说这个format呢是这个

144
00:05:41,879 --> 00:05:44,660
百分号f杠n啊

145
00:05:44,660 --> 00:05:46,459
也就是我们在这儿的这个东西对吧

146
00:05:46,459 --> 00:05:49,360
然后我们把这个字符串替换成了format

147
00:05:49,718 --> 00:05:50,259
好

148
00:05:50,259 --> 00:05:50,978
如果这样做

149
00:05:50,978 --> 00:05:52,598
我们看看他给我们编译过程当中

150
00:05:52,598 --> 00:05:53,798
切换成什么样子了

151
00:05:53,798 --> 00:05:57,098
我们看到他成功的把这个format给替换成了

152
00:05:57,098 --> 00:05:58,060
这个字符串了

153
00:05:58,740 --> 00:06:01,730
所以他做的这个替换非常的简单

154
00:06:01,730 --> 00:06:03,680
就是原始的文本的替换

155
00:06:03,680 --> 00:06:04,370
当然了

156
00:06:04,370 --> 00:06:05,509
如果你说啊

157
00:06:05,509 --> 00:06:08,839
你把这个format放到双引号里头去了

158
00:06:10,019 --> 00:06:12,139
那肯定不会被替换啊

159
00:06:12,139 --> 00:06:14,598
编译器不会管字符串的东西

160
00:06:14,598 --> 00:06:16,500
不会管双引号里面的东西

161
00:06:16,579 --> 00:06:19,009
所以define这个东西呢

162
00:06:19,009 --> 00:06:20,899
它是一个编译处理指令啊

163
00:06:20,899 --> 00:06:24,439
它会在编译器开始去编译之前

164
00:06:24,740 --> 00:06:27,079
先把你的源代码作为一遍预处理

165
00:06:27,079 --> 00:06:29,439
把里面的所有的红都替换掉

166
00:06:30,220 --> 00:06:32,579
出现了你定义的那些红的

167
00:06:32,579 --> 00:06:33,779
名字的那个地方啊

168
00:06:33,779 --> 00:06:36,959
都替换成那些后面的那个值

169
00:06:36,959 --> 00:06:38,579
后面的那个值可以很复杂

170
00:06:38,579 --> 00:06:39,600
也可以带空格

171
00:06:39,600 --> 00:06:41,040
带带带各种标点符号

172
00:06:41,040 --> 00:06:41,399
没关系

173
00:06:41,399 --> 00:06:42,180
他不管他

174
00:06:42,180 --> 00:06:44,259
反正就是第一个是单词

175
00:06:44,259 --> 00:06:45,699
后面所有东西都是值

176
00:06:45,699 --> 00:06:48,129
然后原封不动的做文本的替换

177
00:06:48,129 --> 00:06:49,980
因此呢特别要小心的

178
00:06:49,980 --> 00:06:52,490
就是在那个define后面不能加分号

179
00:06:52,490 --> 00:06:53,930
因为这不是一句c的语句

180
00:06:53,930 --> 00:06:55,490
c的语句才需要加分号对吧

181
00:06:55,490 --> 00:06:57,560
用分号来表明说这句结束了

182
00:06:57,560 --> 00:06:59,420
现在这个define不是c的语句

183
00:06:59,420 --> 00:07:01,069
所以在那儿不能加分号

184
00:07:01,069 --> 00:07:02,540
所以这样定义出来的东西呢

185
00:07:02,540 --> 00:07:03,680
呃我们叫做红

186
00:07:03,680 --> 00:07:04,920
这是c语言的红

187
00:07:04,920 --> 00:07:08,519
如果一个红的当中有其他行的名字

188
00:07:08,519 --> 00:07:10,620
还会再一次的被替换

189
00:07:11,540 --> 00:07:12,069
呃

190
00:07:12,069 --> 00:07:14,560
如果一红的值呢要超过一行的最后一行

191
00:07:14,560 --> 00:07:14,920
之前呢

192
00:07:14,920 --> 00:07:16,629
航墨需要加一个反斜杠

193
00:07:16,629 --> 00:07:18,759
另外呢在红里面可以有注释啊

194
00:07:18,759 --> 00:07:20,699
我们把这三条东西都来试一下

195
00:07:20,800 --> 00:07:22,569
我们再定义一个

196
00:07:22,569 --> 00:07:29,980
我们说这个呃派two呢是叫做二乘以派

197
00:07:30,399 --> 00:07:33,100
这个派就是这里的3.14159了

198
00:07:33,100 --> 00:07:33,579
对不对

199
00:07:33,579 --> 00:07:33,939
好

200
00:07:33,939 --> 00:07:36,120
我们把代码稍微清理一下啊

201
00:07:36,120 --> 00:07:36,990
然后呢

202
00:07:36,990 --> 00:07:39,720
我们这儿呢就不是用派去乘三点了

203
00:07:39,720 --> 00:07:41,339
而是派to去乘三点

204
00:07:41,339 --> 00:07:44,759
当然我们还得把这个fmt给他呃

205
00:07:44,779 --> 00:07:45,800
找回来哈

206
00:07:45,800 --> 00:07:48,259
要不然他变它它会有问题的

207
00:07:48,259 --> 00:07:50,660
现在这个执行的结果表明

208
00:07:50,660 --> 00:07:53,860
这个派two确实是二层排呃

209
00:07:53,860 --> 00:07:56,680
我们不需要回到这个命令行去看一下

210
00:07:56,680 --> 00:07:58,579
他那个解析出来的结果啊

211
00:07:58,779 --> 00:08:00,160
假如说我们现在想呢

212
00:08:00,160 --> 00:08:01,839
呃给这个东西来个注释哈

213
00:08:01,839 --> 00:08:07,060
说这个呢是呃派乘以二啊

214
00:08:07,060 --> 00:08:09,060
这这这算是一个简单的注释了

215
00:08:09,740 --> 00:08:10,779
别人也没问题

216
00:08:10,779 --> 00:08:14,869
这证明了这个部分并没有被替换进去是吧

217
00:08:14,869 --> 00:08:17,389
如果这个部分被当做是派出的值

218
00:08:17,389 --> 00:08:19,930
是说这个整个要被替换进去的

219
00:08:19,930 --> 00:08:23,230
那是那我们就应该会看到它变成这个样子

220
00:08:23,230 --> 00:08:24,959
而如果变成这个样子呢

221
00:08:25,000 --> 00:08:27,660
他不应该得到18点的结果

222
00:08:27,740 --> 00:08:28,459
对不对

223
00:08:28,459 --> 00:08:29,480
实际上编译就会过不了

224
00:08:29,480 --> 00:08:31,819
因为这还没有结尾的那个圆括号啊

225
00:08:31,819 --> 00:08:36,889
所以注释c语言的注释确实也是他的注释

226
00:08:36,889 --> 00:08:39,740
这种注释或者呃多行的注释都可以啊

227
00:08:39,740 --> 00:08:40,899
都是他的注释

228
00:08:42,379 --> 00:08:44,379
当然也有同学会怀疑说

229
00:08:44,379 --> 00:08:47,320
诶是不是因为这个地方空格是不起作用的

230
00:08:47,320 --> 00:08:48,580
ok如果我们这样子好了

231
00:08:48,580 --> 00:08:50,299
我们看看它编译会不会出错

232
00:08:51,019 --> 00:08:52,570
你看编译就出错了

233
00:08:52,570 --> 00:08:56,830
这个时候因为他发现是这个这个时候啊

234
00:08:56,830 --> 00:08:58,870
他的这个地方变成什么呢

235
00:08:58,870 --> 00:09:00,740
我们可以把这个替换进去看一下

236
00:09:00,759 --> 00:09:02,679
他呢变成了这样

237
00:09:02,679 --> 00:09:03,580
变成这样之后呢

238
00:09:03,580 --> 00:09:06,100
这个空格是他无法理解的东西是吧

239
00:09:06,100 --> 00:09:08,620
所以他会说哦这里需要有一个圆括号了

240
00:09:08,620 --> 00:09:11,000
因为他觉得呢你这个地方该结束了嘛

241
00:09:11,259 --> 00:09:14,578
所以空格

242
00:09:15,120 --> 00:09:16,429
其他的标点符号

243
00:09:16,429 --> 00:09:20,419
都会被当做是这个宏定义的值的一部分

244
00:09:20,419 --> 00:09:22,860
但是呢一旦出现注释符号

245
00:09:22,860 --> 00:09:23,700
ok没关系

246
00:09:23,700 --> 00:09:25,458
那就只是普通的注释了

247
00:09:25,799 --> 00:09:27,870
我们可以再看一个多行的例子哈

248
00:09:27,870 --> 00:09:29,580
比如说我们现在定义这样一个东西啊

249
00:09:29,580 --> 00:09:31,980
我们说有个叫做p r t啊

250
00:09:31,980 --> 00:09:33,080
意思就print对吧

251
00:09:33,080 --> 00:09:34,759
然后呢这个第一行呢

252
00:09:34,759 --> 00:09:40,620
我们来输出说这个pad是多少

253
00:09:40,720 --> 00:09:43,210
然后接一个反斜杠

254
00:09:43,210 --> 00:09:46,419
等于说这个红的定义还没结束啊

255
00:09:46,419 --> 00:09:49,919
然后呢我们第二个再来第二个

256
00:09:49,919 --> 00:09:52,350
第二行我们还有一个print print f

257
00:09:52,350 --> 00:09:56,419
说呢这个呢是呃继续呢我们要输出啊

258
00:09:56,419 --> 00:09:59,279
比如说排除的结果啊

259
00:09:59,419 --> 00:10:01,070
我们定义到这好了

260
00:10:01,070 --> 00:10:02,600
然后我们用的时候呢

261
00:10:02,600 --> 00:10:04,159
就可以说p r t

262
00:10:04,159 --> 00:10:07,200
我们看一下编译运行的结果

263
00:10:07,200 --> 00:10:08,159
第一个是派

264
00:10:08,159 --> 00:10:09,419
第二个是派two

265
00:10:09,419 --> 00:10:10,799
那么这个反斜杠呢

266
00:10:10,799 --> 00:10:12,799
就表明说哎我这个p r t啊

267
00:10:12,980 --> 00:10:14,779
到这儿这一行结束的时候

268
00:10:14,779 --> 00:10:15,559
他还没结束啊

269
00:10:15,559 --> 00:10:16,799
如果你没有这一行

270
00:10:16,799 --> 00:10:18,240
那编译的时候就不对了

271
00:10:18,240 --> 00:10:20,580
他不知道你这句print f到底是什么意思

272
00:10:20,580 --> 00:10:23,690
你的这一句c的这个函数调用

273
00:10:23,690 --> 00:10:25,309
出现在任何函数之外了对吧

274
00:10:25,309 --> 00:10:27,529
他他无法理解这个c加上这个反斜杠

275
00:10:27,529 --> 00:10:28,340
它就到了哦

276
00:10:28,340 --> 00:10:32,000
下面这行呢是上面那一行红定义的一部分

277
00:10:32,100 --> 00:10:35,009
除了可以定义有值的红以外呢

278
00:10:35,009 --> 00:10:37,019
呃我们其实还会在程序里面看到

279
00:10:37,019 --> 00:10:38,549
我们会定义没有值的红

280
00:10:38,549 --> 00:10:39,299
比如说像这里

281
00:10:39,299 --> 00:10:41,159
我们就就define一个debug

282
00:10:41,159 --> 00:10:42,299
它有一个名字

283
00:10:42,299 --> 00:10:43,620
可是后面没有值了

284
00:10:43,620 --> 00:10:44,789
ok可以的

285
00:10:44,789 --> 00:10:45,960
这种情况下呢

286
00:10:45,960 --> 00:10:49,169
我们是告诉编译器说我们有了这个红了

287
00:10:49,169 --> 00:10:51,929
可是呢我们不需要它有什么样的值

288
00:10:51,929 --> 00:10:53,909
因为我们在后面可能会去检查

289
00:10:53,909 --> 00:10:55,980
说这个红存在还是不存在

290
00:10:55,980 --> 00:10:57,059
它如果存在

291
00:10:57,059 --> 00:10:59,320
我们编译这部分代码

292
00:10:59,320 --> 00:11:00,429
它如果不存在

293
00:11:00,429 --> 00:11:01,929
可能编译另外一部分代码

294
00:11:01,929 --> 00:11:04,500
这是用来做条件条件编译的

295
00:11:04,559 --> 00:11:06,539
另外还有一些有意思的东西啊

296
00:11:06,539 --> 00:11:08,159
这个c的编译器里头呢

297
00:11:08,159 --> 00:11:10,859
有一些预先定义的红呃

298
00:11:11,299 --> 00:11:13,039
他们都是带着翅膀的

299
00:11:13,039 --> 00:11:13,279
红

300
00:11:13,279 --> 00:11:14,840
就是前面有两个下划线

301
00:11:14,840 --> 00:11:16,159
后面有两个下划线啊

302
00:11:16,159 --> 00:11:17,440
好像带着翅膀一样

303
00:11:17,440 --> 00:11:18,519
那么这些红的

304
00:11:18,519 --> 00:11:21,759
一般是用来表达一些特殊的东西的啊

305
00:11:21,759 --> 00:11:23,740
可以让编译器替你插入一些特殊的值

306
00:11:23,740 --> 00:11:24,720
比如说line呢

307
00:11:24,720 --> 00:11:28,350
是表达说这个源代码文件的行号

308
00:11:28,350 --> 00:11:30,720
当前所在的那个行的行号

309
00:11:30,720 --> 00:11:33,970
file呢表达的是这个源代码文件的文件名

310
00:11:33,970 --> 00:11:37,840
data和time呢是它编译时候的日期和时间

311
00:11:37,840 --> 00:11:40,919
我们可以来试一下这些有意思的预定与红

312
00:11:41,220 --> 00:11:41,700
好

313
00:11:41,700 --> 00:11:43,080
我们现在这个程序非常简单啊

314
00:11:43,080 --> 00:11:46,019
就是让他去输出了far ldtime

315
00:11:46,019 --> 00:11:47,200
那么当然这里头呢

316
00:11:47,200 --> 00:11:49,779
data time和file呢都是字符串啊

317
00:11:49,779 --> 00:11:51,129
而line呢是一个整数

318
00:11:51,129 --> 00:11:52,610
我们看结果是什么

319
00:11:52,610 --> 00:11:53,809
这就是结果啊

320
00:11:53,809 --> 00:11:56,450
他说这个文件名的全路径啊

321
00:11:56,450 --> 00:12:00,200
从根开始一直到这个文件名五呢

322
00:12:00,200 --> 00:12:02,299
这是在第五行啊

323
00:12:02,299 --> 00:12:05,419
date就是今天呢现在的这个时间啊

324
00:12:06,580 --> 00:12:08,940
但我可能改过我的系统时间了哈

