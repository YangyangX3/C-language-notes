1
00:00:04,280 --> 00:00:06,110
这种事情我们之前已经遇到过了啊

2
00:00:06,110 --> 00:00:08,580
如果说呃程序要输入数据

3
00:00:08,958 --> 00:00:11,239
先告诉你个数啊

4
00:00:11,239 --> 00:00:12,589
我有多少个数据要进来

5
00:00:12,589 --> 00:00:14,400
然后呢再输入

6
00:00:14,718 --> 00:00:17,539
那么在这个输入处理的过程当中呢

7
00:00:17,539 --> 00:00:20,028
如果我们是需要记录每一个数据的

8
00:00:20,028 --> 00:00:22,260
那么这个事情应该怎么做呢

9
00:00:23,280 --> 00:00:25,429
如果你有c99 可以用

10
00:00:25,429 --> 00:00:29,359
那么c99 是可以用变量来做数组

11
00:00:29,359 --> 00:00:30,500
定义的大小

12
00:00:30,500 --> 00:00:32,298
如果在c9 之前

13
00:00:32,659 --> 00:00:35,780
比如说你在准备这个二级考试是吧

14
00:00:35,780 --> 00:00:37,459
他必须用ssc的

15
00:00:38,179 --> 00:00:39,460
这时候你不能用c

16
00:00:39,460 --> 00:00:40,240
像c9 那样

17
00:00:40,240 --> 00:00:41,140
你程序里写说啊

18
00:00:41,140 --> 00:00:43,479
我这个方框里头来个n叉叉

19
00:00:43,479 --> 00:00:44,378
那就错

20
00:00:44,859 --> 00:00:46,640
所以在c99 之前

21
00:00:46,979 --> 00:00:48,600
人们是怎么解决这个问题的

22
00:00:48,600 --> 00:00:49,619
人是怎么

23
00:00:49,619 --> 00:00:50,880
人们是怎么做的呢

24
00:00:50,880 --> 00:00:55,799
那个时候就必须使用动态内存分配

25
00:00:57,119 --> 00:00:58,579
就像这样写

26
00:00:58,579 --> 00:01:01,259
用一个malloc函数

27
00:01:02,619 --> 00:01:06,599
这个mc函数呢给他一个参数

28
00:01:06,599 --> 00:01:10,000
说我要多少大的内存

29
00:01:10,799 --> 00:01:13,459
这这这个完全讲的是非常底层的东西了

30
00:01:13,459 --> 00:01:14,109
是吧

31
00:01:14,109 --> 00:01:16,450
我我就明明白白告诉你

32
00:01:16,450 --> 00:01:20,069
函数说我现在呢要比如说120个字节

33
00:01:20,069 --> 00:01:21,150
什么意思呢

34
00:01:21,150 --> 00:01:22,409
你拿到除以四的话

35
00:01:22,409 --> 00:01:23,069
120个字节

36
00:01:23,069 --> 00:01:25,060
也就是我要30个int

37
00:01:25,420 --> 00:01:27,159
我就告诉他说我要30个int

38
00:01:27,159 --> 00:01:29,260
所以30乘以size of int

39
00:01:29,260 --> 00:01:32,299
30个int malloc给了你一块空间

40
00:01:32,299 --> 00:01:33,859
你得到的是一个什么呢

41
00:01:33,859 --> 00:01:34,459
void star

42
00:01:34,459 --> 00:01:37,379
所以你还要把它类型转换成industar

43
00:01:37,379 --> 00:01:39,420
最后呢你得到了那玩意儿

44
00:01:39,420 --> 00:01:40,980
所以以前得要这么改啊

45
00:01:40,980 --> 00:01:42,939
我们来写写看这代码该怎么写

46
00:01:42,939 --> 00:01:45,250
首先呢要用malloc

47
00:01:45,250 --> 00:01:48,420
你需要include另外一个头文件

48
00:01:48,579 --> 00:01:50,560
我们讲过在unix你可以卖

49
00:01:50,560 --> 00:01:52,480
我们来慢慢一下这个mc

50
00:01:52,620 --> 00:01:54,900
如果我们man一下mlock

51
00:01:54,900 --> 00:01:56,250
那他会说呢

52
00:01:56,250 --> 00:01:59,640
这是一个需要include s t d l

53
00:01:59,640 --> 00:02:02,280
s t d lib.h的东西啊

54
00:02:02,280 --> 00:02:05,370
s t d lib标准库点h

55
00:02:05,370 --> 00:02:11,599
那melock呢在这它的参数的类型呢是size

56
00:02:11,599 --> 00:02:12,560
size t是什么

57
00:02:12,560 --> 00:02:13,599
没见过是吧

58
00:02:14,060 --> 00:02:16,639
暂时我不想告诉你们很多细节

59
00:02:16,639 --> 00:02:18,740
你就当做是个整数

60
00:02:18,939 --> 00:02:20,439
我只能说当做啊

61
00:02:20,439 --> 00:02:23,289
他并不真的是是是和int一样的

62
00:02:23,289 --> 00:02:25,379
然后他返回的是boy的心

63
00:02:25,639 --> 00:02:27,740
我们刚刚讲过void的心是什么

64
00:02:27,740 --> 00:02:30,289
表示说我有一个指针

65
00:02:30,289 --> 00:02:31,669
它指向一块内存

66
00:02:31,669 --> 00:02:34,620
但是呢我也不知道它指向的到底是什么

67
00:02:34,620 --> 00:02:36,300
因为我们现在要什么

68
00:02:36,300 --> 00:02:37,379
我们现在要一个数组

69
00:02:37,379 --> 00:02:38,520
比如我要一个int数组

70
00:02:38,520 --> 00:02:40,650
我们要30个int的数组

71
00:02:40,650 --> 00:02:42,300
但是对于mc来说

72
00:02:42,799 --> 00:02:44,620
不知道这是int

73
00:02:45,259 --> 00:02:46,219
对于c语言来说

74
00:02:46,219 --> 00:02:47,960
我们没有办法传一个说唉

75
00:02:47,960 --> 00:02:50,659
我要一个int给你这个类型是不能传递的

76
00:02:50,659 --> 00:02:52,939
所以你只能告诉他说我要120个字节

77
00:02:52,939 --> 00:02:56,280
完了以后你自己把它当作int就好了

78
00:02:57,020 --> 00:02:59,409
所以我们来看怎么用这个block

79
00:02:59,409 --> 00:03:02,860
我们扣这个s t d lib.h

80
00:03:08,860 --> 00:03:09,960
做到这

81
00:03:09,960 --> 00:03:11,490
我们现在有了number

82
00:03:11,490 --> 00:03:14,550
我们知道我们需要那么多的一个数组了

83
00:03:14,550 --> 00:03:15,539
如果是c99 

84
00:03:15,539 --> 00:03:16,560
我们就可以这么写啊

85
00:03:16,560 --> 00:03:19,020
我们有个比如说就叫a好了

86
00:03:19,020 --> 00:03:22,080
a然后呢他就是number k c9 

87
00:03:22,080 --> 00:03:23,099
这么这么干就可以了

88
00:03:23,099 --> 00:03:24,870
可是我们现在是

89
00:03:24,870 --> 00:03:27,000
如果在c9 之前不能这么干

90
00:03:27,379 --> 00:03:28,370
不能这么干

91
00:03:28,370 --> 00:03:29,449
我们得这么干

92
00:03:29,449 --> 00:03:34,098
我们说我们有一个当然不是c99 

93
00:03:34,098 --> 00:03:35,778
我们变量也得写到前两句是吧

94
00:03:35,778 --> 00:03:37,158
我们有个in的新的指针

95
00:03:37,158 --> 00:03:38,359
我们也把它叫做a好了

96
00:03:38,359 --> 00:03:41,118
然后说呢这个a呢等于什么呢

97
00:03:41,118 --> 00:03:44,500
等于block什么呢

98
00:03:44,500 --> 00:03:48,500
我们要这个number去乘以size of int

99
00:03:48,560 --> 00:03:53,060
因为my lock要的参数不是有多少个int

100
00:03:53,060 --> 00:03:55,520
不是你这个数组有多多少个单元

101
00:03:55,520 --> 00:03:58,419
而是这个数组占据多少个空间

102
00:03:58,419 --> 00:04:00,579
就跟size of那个数组得到的结果是一样的

103
00:04:00,579 --> 00:04:02,789
所以是以字节为单位的

104
00:04:02,789 --> 00:04:04,050
因此我们知道number之后

105
00:04:04,050 --> 00:04:06,319
我们要去乘以size的int

106
00:04:06,319 --> 00:04:07,340
当然怎么还不够

107
00:04:07,340 --> 00:04:09,800
因为malloc返回的结果是void star

108
00:04:09,800 --> 00:04:10,639
而a是什么

109
00:04:10,639 --> 00:04:11,300
是in the star

110
00:04:11,300 --> 00:04:13,479
所以我们还要类型转换一下

111
00:04:14,860 --> 00:04:20,069
完了以后我们讲过指针和数组是一样的

112
00:04:20,069 --> 00:04:21,930
所以你就当他们是一样的

113
00:04:21,930 --> 00:04:22,649
好了之后

114
00:04:22,649 --> 00:04:24,579
接下来该做的所有的事情

115
00:04:24,579 --> 00:04:27,310
你都拿a当数组来用

116
00:04:27,310 --> 00:04:29,079
比如说我们要输入那么多个数字了

117
00:04:29,079 --> 00:04:29,589
对不对

118
00:04:29,589 --> 00:04:29,949
好

119
00:04:29,949 --> 00:04:33,180
那我们需要有个i哎

120
00:04:33,180 --> 00:04:35,610
过去那个年代我们真的就这么写程序的啊

121
00:04:35,610 --> 00:04:36,899
当你要用到的变量了

122
00:04:36,899 --> 00:04:38,519
好跑回去跑到头上

123
00:04:38,519 --> 00:04:40,399
把那个变量给定义下来

124
00:04:40,459 --> 00:04:42,980
不能像现在一样想要用个变量了

125
00:04:42,980 --> 00:04:43,819
随便去啊

126
00:04:43,819 --> 00:04:44,600
产生一个新变量

127
00:04:44,600 --> 00:04:45,199
那不行哈

128
00:04:45,199 --> 00:04:46,288
以前不行的

129
00:04:46,288 --> 00:04:48,509
for这个i呢等于零

130
00:04:48,509 --> 00:04:51,149
i呢小于这个number i呢

131
00:04:51,149 --> 00:04:53,249
加加循环的每一轮里面呢

132
00:04:53,249 --> 00:04:55,639
我们就来kf说啊

133
00:04:55,639 --> 00:04:57,589
我们要这个什么呢

134
00:04:57,589 --> 00:04:58,759
拿一张数组嘛

135
00:04:58,759 --> 00:05:01,250
那就是a的i对吧

136
00:05:01,250 --> 00:05:03,649
a这个数组的第i个单元a取地址出来

137
00:05:03,649 --> 00:05:05,100
我们就caf一下

138
00:05:05,199 --> 00:05:05,740
好

139
00:05:05,740 --> 00:05:08,199
skin f都做进多都做完了啊

140
00:05:08,199 --> 00:05:10,240
比如说我们现在想要逆序输出

141
00:05:10,240 --> 00:05:12,310
这个这这些所有所有的数字

142
00:05:12,310 --> 00:05:13,720
ok那我们再来一遍

143
00:05:13,720 --> 00:05:16,689
说i呢等于number啊

144
00:05:16,689 --> 00:05:17,769
减一对吧

145
00:05:19,180 --> 00:05:20,740
i呢大于等于零

146
00:05:20,740 --> 00:05:22,110
i呢减减

147
00:05:22,110 --> 00:05:25,170
然后呢循环的每一轮我们来print

148
00:05:25,170 --> 00:05:28,459
说我们要输出这个所有的数字啊

149
00:05:28,459 --> 00:05:30,050
当然可能空格分割是吧

150
00:05:30,050 --> 00:05:31,730
然后呢输出的是什么呢

151
00:05:31,730 --> 00:05:37,879
a的那个i我们一旦用麦克去得到了

152
00:05:37,879 --> 00:05:40,149
那么那么一块空间把它交给了a

153
00:05:40,149 --> 00:05:41,350
剩下来之后

154
00:05:41,350 --> 00:05:42,910
我们所有对a的操作

155
00:05:42,910 --> 00:05:46,379
完全可以把它当做一个数组来用

156
00:05:46,519 --> 00:05:49,699
这完全就是一个数组

157
00:05:49,699 --> 00:05:50,980
没任何问题

158
00:05:51,800 --> 00:05:55,660
这就是过去我们用动态内存分配啊

159
00:05:55,660 --> 00:05:58,269
malloc做动态内存分配来实现

160
00:05:58,269 --> 00:06:01,220
这种数组的大小是可变的

161
00:06:01,220 --> 00:06:04,000
这种形式事实上也不叫做可变是吧

162
00:06:04,000 --> 00:06:07,240
是运行时候才确定的那种速度大小啊

163
00:06:07,240 --> 00:06:09,639
过去我们就必须用mlock这个方式来做

164
00:06:09,639 --> 00:06:13,579
当然这个代码写到这是不是ok不ok

165
00:06:13,759 --> 00:06:15,379
还有一件小事情

166
00:06:15,379 --> 00:06:18,680
我们mlock跟系统去要了一块空间

167
00:06:18,680 --> 00:06:22,899
用完了之后走之前我们还得做一件事情

168
00:06:22,899 --> 00:06:23,889
还给人家

169
00:06:25,629 --> 00:06:26,740
有借有还嘛

170
00:06:26,740 --> 00:06:27,470
对不对

171
00:06:27,470 --> 00:06:29,300
以后再借才不难嘛

172
00:06:29,300 --> 00:06:31,100
你要是总是借了不还

173
00:06:31,100 --> 00:06:32,029
总是借了不还

174
00:06:32,029 --> 00:06:33,199
谁还借东西给你的

175
00:06:33,199 --> 00:06:35,180
所以malik借来之后

176
00:06:35,180 --> 00:06:37,759
你要free把它还掉

177
00:06:38,779 --> 00:06:40,110
动态内存分配

178
00:06:40,110 --> 00:06:42,629
说到底主要就是这两个函数

179
00:06:42,629 --> 00:06:43,529
当然我们还有其他的

180
00:06:43,529 --> 00:06:45,000
但是那些不重要

181
00:06:45,000 --> 00:06:46,139
我们就看这两个

182
00:06:46,139 --> 00:06:47,819
所以我们总结一下我们刚才man的时候

183
00:06:47,819 --> 00:06:49,860
我们看到说ma函数

184
00:06:51,600 --> 00:06:53,730
叫做s t d lib.h

185
00:06:53,730 --> 00:06:57,149
它的原型呢参数是size t

186
00:06:57,149 --> 00:06:59,180
返回类型是void the star

187
00:06:59,319 --> 00:07:01,930
你向matic申请的空间的大小

188
00:07:01,930 --> 00:07:03,279
是以字节为单位的

189
00:07:03,279 --> 00:07:05,680
所以如果你要的是很多个int

190
00:07:05,680 --> 00:07:08,189
那么你要数量乘以size of int

191
00:07:08,189 --> 00:07:09,658
你如果要很多个shot

192
00:07:09,658 --> 00:07:11,488
数量乘以size of shot

193
00:07:11,488 --> 00:07:12,778
你要很多个double

194
00:07:12,778 --> 00:07:14,610
数量乘以size of double

195
00:07:14,610 --> 00:07:15,870
为什么可以这样

196
00:07:15,870 --> 00:07:18,990
因为在内存里头计算机采不care说哦

197
00:07:18,990 --> 00:07:20,310
你这个是int

198
00:07:20,310 --> 00:07:21,120
那个是double

199
00:07:21,120 --> 00:07:24,379
对他来说内存就是一片连续的空间

200
00:07:25,240 --> 00:07:28,560
是我们自己在说这个地方是double

201
00:07:28,560 --> 00:07:30,029
这个地方是int

202
00:07:30,029 --> 00:07:31,339
是我们自己说的

203
00:07:31,899 --> 00:07:34,629
所以你跟计算机要一块内存

204
00:07:34,629 --> 00:07:40,838
拿来以后用类型转换说我要拿它当int

205
00:07:40,838 --> 00:07:42,369
我要拿它当double

206
00:07:42,369 --> 00:07:44,600
我要拿它当shot都可以

207
00:07:44,779 --> 00:07:46,370
以后我们学了structure

208
00:07:46,370 --> 00:07:47,120
我们也可以说唉

209
00:07:47,120 --> 00:07:50,800
我要拿他当我的这个结构体没问题

210
00:07:51,098 --> 00:07:53,379
所以melock其实做的事情很简单

211
00:07:53,379 --> 00:07:54,158
就是跟系统要快

212
00:07:54,158 --> 00:07:54,939
没存在

213
00:07:54,939 --> 00:07:57,899
那macc是去跟系统要空间

214
00:07:58,959 --> 00:08:00,540
空间总是有限

215
00:08:01,620 --> 00:08:03,680
如果空间用完了

216
00:08:03,680 --> 00:08:05,509
马拉克会给你什么呢

217
00:08:05,509 --> 00:08:07,379
它会返回一个零

218
00:08:07,839 --> 00:08:08,920
或者就是now

219
00:08:08,920 --> 00:08:10,120
我们前面解释过的

220
00:08:10,120 --> 00:08:10,720
对不对

221
00:08:10,720 --> 00:08:13,060
零空间我们给它一个特殊的名字

222
00:08:13,060 --> 00:08:13,899
就是now

223
00:08:13,899 --> 00:08:17,360
那么你的系统能够给你多大的空间呢

224
00:08:17,800 --> 00:08:19,240
我们不妨来试一下

225
00:08:19,240 --> 00:08:21,699
看什么时候他会给你返回

226
00:08:21,699 --> 00:08:23,589
闹的这个代码什么意思呢

227
00:08:23,589 --> 00:08:26,680
我们在这儿用malloc去申请一块空间

228
00:08:26,680 --> 00:08:28,509
这个空间的大小是多少呢

229
00:08:28,509 --> 00:08:31,040
1024是1k

230
00:08:31,478 --> 00:08:35,979
1024x1024是1k的1k

231
00:08:35,979 --> 00:08:37,089
那就是一兆

232
00:08:37,089 --> 00:08:38,889
然后再乘以100

233
00:08:38,889 --> 00:08:40,379
那就是100兆

234
00:08:40,460 --> 00:08:44,000
所以我们每次去申请100兆的空间

235
00:08:44,000 --> 00:08:46,519
然后把申请到的空间呢交给p

236
00:08:46,779 --> 00:08:49,240
那这个括号什么意思呢

237
00:08:51,000 --> 00:08:52,909
现在我高亮起来的这一部分

238
00:08:52,909 --> 00:08:54,529
对p做了一个赋值

239
00:08:54,529 --> 00:08:57,100
然后赋值也是一个表达式

240
00:08:57,100 --> 00:08:57,730
对不对

241
00:08:57,730 --> 00:08:58,570
它有个结果

242
00:08:58,570 --> 00:09:02,110
结果就是p得到的malloc的那个结果

243
00:09:02,110 --> 00:09:06,399
我们在程序当中会经常看到这样的写法

244
00:09:06,399 --> 00:09:08,259
在这样的做法当中呢

245
00:09:08,259 --> 00:09:10,360
我们同时做了两件事情

246
00:09:10,360 --> 00:09:11,169
一件事情

247
00:09:11,169 --> 00:09:14,120
我们把malloc的结果付给了p这个变量

248
00:09:14,120 --> 00:09:15,409
那第二件事情呢

249
00:09:15,409 --> 00:09:19,220
我们要让这个p得到的这个值拿来做

250
00:09:19,220 --> 00:09:20,440
while的条件

251
00:09:20,440 --> 00:09:23,178
如果p得到的地址不是零

252
00:09:23,178 --> 00:09:26,119
那就意味着他得到了一个有效的地址

253
00:09:26,119 --> 00:09:30,120
那么我们循环要继续要让cnt去加加

254
00:09:30,120 --> 00:09:33,269
如果他得到的地址是零

255
00:09:35,860 --> 00:09:36,940
一旦往往退出来

256
00:09:36,940 --> 00:09:41,259
那我们就会来说分配了多少个百兆的空间

257
00:09:41,259 --> 00:09:42,460
我们来试一下这个代码

258
00:09:42,460 --> 00:09:44,259
现在我在32位底下运行

259
00:09:45,399 --> 00:09:49,169
它的结果呢告诉我3300兆

260
00:09:49,169 --> 00:09:51,259
大概3.3g的样子

261
00:09:52,100 --> 00:09:54,549
我相信你在你的电脑上运行

262
00:09:54,549 --> 00:09:56,049
一定不是这个结果

263
00:09:56,049 --> 00:09:57,779
除非你跟我电脑一模一样啊

264
00:09:57,980 --> 00:10:00,980
当然我现在的这个运行环境呢

265
00:10:00,980 --> 00:10:02,480
在返回零之前

266
00:10:02,480 --> 00:10:03,379
他肯定返回零了

267
00:10:03,379 --> 00:10:04,460
如果没返回零

268
00:10:04,460 --> 00:10:06,929
它不会出现这句话对吧

269
00:10:06,929 --> 00:10:09,299
不会print f分配了多少兆的空间

270
00:10:09,299 --> 00:10:10,649
他一定返回零了

271
00:10:10,649 --> 00:10:12,000
但是呢在返回零之前

272
00:10:12,000 --> 00:10:13,269
他输出了一个信息

273
00:10:13,269 --> 00:10:15,009
这个信息告诉我们说呢

274
00:10:15,009 --> 00:10:17,360
啊他分配空间已经失败了

275
00:10:17,360 --> 00:10:19,580
但是他没有这个信息出来了

276
00:10:19,580 --> 00:10:21,500
他并没有把程序给终止掉

277
00:10:21,500 --> 00:10:23,059
我们程序还是正常的运行了

278
00:10:23,059 --> 00:10:24,700
所以下面这句话我们还是看到了

279
00:10:24,700 --> 00:10:27,059
如果是在64位的架构底下

280
00:10:27,059 --> 00:10:28,649
你会得到什么样的结果

281
00:10:28,649 --> 00:10:31,799
所以我们这回在讨论区又又又得玩了是吧

282
00:10:31,799 --> 00:10:33,779
我们来看一下在你的电脑上面

283
00:10:33,779 --> 00:10:36,279
你可以分配到多大的空间

284
00:10:36,279 --> 00:10:37,720
我们在前面那个例子

285
00:10:37,720 --> 00:10:41,090
就说你申请来的东西

286
00:10:46,460 --> 00:10:48,839
是和malloc配套的一个函数

287
00:10:48,839 --> 00:10:50,938
一旦你ma得到了一个空间

288
00:10:50,938 --> 00:10:51,899
用完之后

289
00:10:51,899 --> 00:10:55,739
你就应该把那个空间的地址交给free

290
00:10:55,739 --> 00:10:57,279
让它还给系统

291
00:10:57,720 --> 00:10:58,919
有借有还嘛

292
00:10:58,919 --> 00:10:59,639
对不对

293
00:11:01,360 --> 00:11:05,219
申请过的空间最终都应该要还

294
00:11:06,220 --> 00:11:07,950
那你在还的时候呢

295
00:11:07,950 --> 00:11:11,809
只能还申请来的地址的空间的那个首地址

296
00:11:11,809 --> 00:11:13,309
也就是原始的那个地址

297
00:11:13,309 --> 00:11:15,289
你不能说我p原来等于那个

298
00:11:15,289 --> 00:11:17,570
然后p加p加加加加了好多遍以后

299
00:11:17,570 --> 00:11:18,350
我也记不清了

300
00:11:18,350 --> 00:11:19,129
原来是什么拉

301
00:11:19,129 --> 00:11:23,230
倒反正p在那我就我就free那个p不行了

302
00:11:23,230 --> 00:11:24,250
我们试试看

303
00:11:24,250 --> 00:11:25,840
我们做非常简单的一件事情啊

304
00:11:25,840 --> 00:11:27,700
我们melo可以点一点点哈哈

305
00:11:27,700 --> 00:11:28,299
不是一点点

306
00:11:28,299 --> 00:11:31,019
我们ma可能100兆的空间呃

307
00:11:31,019 --> 00:11:32,250
得到的东西交给p

308
00:11:32,250 --> 00:11:35,970
然后呢我们就做了个p加加p加加嘛

309
00:11:35,970 --> 00:11:36,659
加完之后呢

310
00:11:36,659 --> 00:11:38,159
我就直接拿这个p去做free了

311
00:11:38,159 --> 00:11:39,120
我们看看运行都要什么

312
00:11:39,120 --> 00:11:39,839
结果

313
00:11:40,200 --> 00:11:44,250
他说这个pointer being freed

314
00:11:44,250 --> 00:11:47,159
要释放的那个指针啊

315
00:11:47,159 --> 00:11:48,629
was not allocating

316
00:11:48,629 --> 00:11:50,539
不是申请来的

317
00:11:55,720 --> 00:11:57,070
所以这个不行

318
00:11:57,070 --> 00:11:58,240
还有什么是不可以的

319
00:11:58,240 --> 00:12:01,279
比如说如果我们有个int i

320
00:12:02,460 --> 00:12:04,490
然后呢我们说p呢

321
00:12:04,490 --> 00:12:08,710
等于and i p不是malloc来的

322
00:12:08,710 --> 00:12:09,820
p是个指针没错

323
00:12:09,820 --> 00:12:11,169
但它不是mlock来的

324
00:12:11,169 --> 00:12:13,000
是另外变量的地址

325
00:12:13,000 --> 00:12:14,320
然后我们试试图去free

326
00:12:14,320 --> 00:12:16,539
我们看运行结果一样

327
00:12:16,539 --> 00:12:18,159
他说point being free

328
00:12:18,159 --> 00:12:19,990
was not allocated

329
00:12:19,990 --> 00:12:23,230
看起来呢这个系统啊

330
00:12:23,230 --> 00:12:26,509
他会记住他给过你什么

331
00:12:26,509 --> 00:12:31,240
然后你还的时候必须原封不动地还给人家

332
00:12:32,419 --> 00:12:34,009
他给你的地址是什么

333
00:12:34,009 --> 00:12:37,029
你就拿那个地址去还给人家才是对的

334
00:12:37,029 --> 00:12:39,250
那假如一不小心

335
00:12:39,250 --> 00:12:42,458
你说我服了一个now行不行呢

336
00:12:43,419 --> 00:12:44,740
没问题

337
00:12:46,320 --> 00:12:48,860
为什么free now反而没问题

338
00:12:48,860 --> 00:12:51,479
ok这故事是这样的

339
00:12:52,220 --> 00:12:54,399
反正零不可能是一个有效的地址

340
00:12:54,399 --> 00:12:55,139
对不对

341
00:12:55,480 --> 00:12:58,570
零不可能是一个你ma得到的地址

342
00:12:58,570 --> 00:13:01,850
所以我干脆在free里面呢

343
00:13:01,850 --> 00:13:03,259
free也就是个函数吗

344
00:13:03,259 --> 00:13:04,879
free函数就先判断一下

345
00:13:04,879 --> 00:13:05,899
如果你给我一个闹

346
00:13:06,919 --> 00:13:08,399
那我就不做事情好了

347
00:13:08,899 --> 00:13:11,240
可是有什么必要

348
00:13:11,240 --> 00:13:13,490
我们去做这个这样的事情呢

349
00:13:17,480 --> 00:13:19,070
有一个指针出来了

350
00:13:19,070 --> 00:13:21,259
我就先促使它为零

351
00:13:24,620 --> 00:13:26,720
任何的指针一旦定义就促使它为零

352
00:13:26,720 --> 00:13:28,340
那么在这个之后

353
00:13:28,340 --> 00:13:31,500
如果你没有去malloc

354
00:13:32,460 --> 00:13:33,679
由于某些原因

355
00:13:33,679 --> 00:13:34,669
你没有malloc

356
00:13:34,669 --> 00:13:37,789
或者你mlock得到一个失败的结果

357
00:13:37,789 --> 00:13:40,490
然后你在这儿想要去free那个p

358
00:13:40,490 --> 00:13:44,840
这没有问题啊

359
00:13:48,049 --> 00:13:50,059
在指针定变量定义的时候

360
00:13:50,059 --> 00:13:51,740
就付给他一个零值

361
00:13:51,740 --> 00:13:55,719
free说让我free 0不会出错的

362
00:13:56,179 --> 00:13:57,440
如果free的不是零

363
00:13:57,440 --> 00:13:58,818
你说free 1

364
00:14:00,659 --> 00:14:02,029
当然不行了

365
00:14:02,029 --> 00:14:03,980
一这个地址不能被free

366
00:14:03,980 --> 00:14:04,490
对不对

367
00:14:04,490 --> 00:14:08,479
好这个mlock和free这件事情啊

368
00:14:08,860 --> 00:14:10,269
肯定要学

369
00:14:10,269 --> 00:14:11,799
很重要

370
00:14:11,799 --> 00:14:13,389
也很有用

371
00:14:13,389 --> 00:14:19,198
但是呢我们也怕教学生也怕学怕用

372
00:14:19,460 --> 00:14:22,519
因为一不小心就出问题

373
00:14:22,519 --> 00:14:23,899
常见的问题是什么呢

374
00:14:23,899 --> 00:14:25,759
就是申请了may free

375
00:14:26,159 --> 00:14:29,190
申请了没福瑞会造成什么后果呢

376
00:14:29,190 --> 00:14:30,659
坦率地说

377
00:14:30,659 --> 00:14:32,759
如果你只是写个小东西哈

378
00:14:32,759 --> 00:14:36,289
好像呃我要读个number

379
00:14:36,289 --> 00:14:38,570
然后呢根据这个number申请一个数组

380
00:14:38,570 --> 00:14:39,289
多点东西

381
00:14:39,289 --> 00:14:39,769
做点运算

382
00:14:39,769 --> 00:14:40,740
然后走掉了

383
00:14:41,360 --> 00:14:42,159
坦率地说

384
00:14:42,159 --> 00:14:43,179
如果在这样的程序里头

385
00:14:43,179 --> 00:14:45,220
你ma了没有

386
00:14:45,220 --> 00:14:48,730
free不会对任何人造成伤害的

387
00:14:48,730 --> 00:14:52,879
因为你的程序运行过程当中

388
00:14:52,879 --> 00:14:55,409
所造成的任何不好的东西

389
00:14:55,409 --> 00:14:58,169
我们说如果你mlock了没有free

390
00:14:58,169 --> 00:14:59,250
你会留下的是什么呢

391
00:14:59,250 --> 00:15:01,860
我们把它叫做内存漏洞啊

392
00:15:01,860 --> 00:15:05,659
或者叫做内存垃圾这种东西没关系

393
00:15:05,659 --> 00:15:07,740
当你的程序运行结束的时候

394
00:15:07,960 --> 00:15:09,490
哗啦一下子全没了

395
00:15:09,490 --> 00:15:11,409
操作系统有它的机制去保证

396
00:15:11,409 --> 00:15:12,759
当这个程序运行完成以后

397
00:15:12,759 --> 00:15:14,590
他曾经使用过的所有的内存

398
00:15:14,590 --> 00:15:16,279
都会被清除干净的

399
00:15:16,600 --> 00:15:18,820
所以留下没有free的东西

400
00:15:18,820 --> 00:15:21,639
对于小程序没有问题

401
00:15:24,120 --> 00:15:25,799
有一天你去做大程序的时候

402
00:15:25,799 --> 00:15:26,759
我们就会遭殃

403
00:15:26,759 --> 00:15:27,779
我们见识过

404
00:15:27,779 --> 00:15:30,059
我们程序能够申请的内存是有限

405
00:15:31,139 --> 00:15:33,320
如果你总是申请内存不释放

406
00:15:33,320 --> 00:15:35,578
如果你的程序一直在运行

407
00:15:36,100 --> 00:15:40,129
比如说一个服务器程序他一直在运行

408
00:15:40,129 --> 00:15:41,330
接受各种请求

409
00:15:41,330 --> 00:15:42,649
给出各种计算结果

410
00:15:42,649 --> 00:15:46,318
可是呢你写的程序malloc没有free

411
00:15:46,419 --> 00:15:49,090
那么第一个请求来了

412
00:15:49,090 --> 00:15:50,590
你多占用了

413
00:15:50,590 --> 00:15:52,479
比方说一兆的空间

414
00:15:53,460 --> 00:15:54,440
第二个请求来了

415
00:15:54,440 --> 00:15:58,789
又一张3300个请求来过之后

416
00:15:58,789 --> 00:16:00,620
你的空间就没有了

417
00:16:00,620 --> 00:16:05,460
那为什么会造成写程序申请了没free呢

418
00:16:05,460 --> 00:16:07,139
对于新手来说

419
00:16:07,139 --> 00:16:10,360
往往是因为忘了就这么简单

420
00:16:12,340 --> 00:16:13,840
我要我就要了

421
00:16:13,840 --> 00:16:16,940
要完了跟我没啥关系不管

422
00:16:18,799 --> 00:16:20,479
而对于老手来说

423
00:16:21,840 --> 00:16:23,629
往往并不是他忘了

424
00:16:23,629 --> 00:16:27,769
而是会找不到合适的时机

425
00:16:32,220 --> 00:16:34,830
这和他经验有关

426
00:16:34,830 --> 00:16:37,659
当然我们说的老手是不够老的老手哈

427
00:16:39,639 --> 00:16:44,320
它的代码的结构会导致它某个地方产生的

428
00:16:44,320 --> 00:16:45,820
melog出来的那个内存

429
00:16:45,820 --> 00:16:48,370
它没有什么合适的地方去把它给free掉

430
00:16:48,370 --> 00:16:50,169
还有一种可能的问题是

431
00:16:50,169 --> 00:16:52,210
你已经把它free过了

432
00:16:55,059 --> 00:16:56,490
那个系统会记住的

433
00:16:56,490 --> 00:16:58,379
你free过来还掉了好了

434
00:16:58,379 --> 00:17:00,000
他就已经不在那个名单里头了

435
00:17:00,000 --> 00:17:03,059
你再去free他一样会崩溃

436
00:17:04,440 --> 00:17:06,578
直接如果地址变过了

437
00:17:06,578 --> 00:17:07,239
你直接去free

438
00:17:07,239 --> 00:17:08,318
我们已经试过这个事情了

439
00:17:08,318 --> 00:17:09,338
p加战就不行了

440
00:17:09,338 --> 00:17:10,009
对不对

441
00:17:12,470 --> 00:17:13,369
常见的问题

442
00:17:13,369 --> 00:17:15,220
那对于这些问题呢

443
00:17:16,579 --> 00:17:18,579
解决的办法只有两条

444
00:17:18,579 --> 00:17:20,829
第一条牢牢记住free

445
00:17:20,829 --> 00:17:24,039
在你的程序里头一旦有mlock

446
00:17:24,039 --> 00:17:25,809
就给他对上一个free

447
00:17:25,809 --> 00:17:27,878
有mlock就对上一个free

448
00:17:28,619 --> 00:17:29,960
写malloc的程序

449
00:17:29,960 --> 00:17:31,640
就一定要去记住

450
00:17:31,640 --> 00:17:33,138
把那个free给加上

451
00:17:34,119 --> 00:17:35,130
第二呢

452
00:17:35,130 --> 00:17:37,589
你需要对你程序的整体架构

453
00:17:37,589 --> 00:17:39,869
有一些比较良好的设计

454
00:17:39,869 --> 00:17:43,539
保证你的程序能够有恰当的时机去free他们

455
00:17:43,559 --> 00:17:46,839
那第三当然这需要经验

456
00:17:47,480 --> 00:17:48,430
需要经验

457
00:17:48,430 --> 00:17:50,079
需要多阅读别人的代码

458
00:17:50,079 --> 00:17:51,609
需要多写自己的代码

459
00:17:51,609 --> 00:17:54,160
需要多在失败当中总结教训

460
00:17:54,160 --> 00:17:56,099
然后不断的成长

461
00:17:57,299 --> 00:17:59,960
光是读书是没有用的

462
00:17:59,960 --> 00:18:01,670
编程是实践

463
00:18:01,670 --> 00:18:04,759
所以纸上得来终觉浅

464
00:18:04,759 --> 00:18:08,000
绝知此事需躬行

