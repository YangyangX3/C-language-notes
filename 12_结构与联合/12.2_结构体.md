---
title: 结构体
tags:
  - C语言
  - 结构体
  - 复合数据类型
related_code:
  - "[[结构体.c]]"
  - "[[结构体和函数.c]]"
  - "[[结构中的结构.c]]"
---

# 结构体[^1]

## 基本概念

结构体(structure)是C语言中的一种**复合数据类型**，用于将不同类型的数据组合成一个单独的实体。与数组不同，结构体可以存储不同数据类型的元素，每个元素称为"成员(member)"。

结构体的主要特点：
- 由若干**不同类型**的数据成员组成
- 适合表示现实世界中复杂的数据实体（如日期、时间、学生信息等）
- 可以像基本数据类型一样使用（作为变量、参数、返回值等）

## 结构体类型与结构体变量

在C语言中，需要区分两个重要概念：
- **结构体类型**：只是一种模板，定义了数据的组织方式，不占用内存
- **结构体变量**：根据结构体类型创建的实际存储空间，占用内存

### 结构体类型的声明

```c
struct 结构体名称 {
    类型1 成员1;
    类型2 成员2;
    ...
    类型n 成员n;
};
```

例如，定义一个表示日期的结构体类型：

```c
struct date {
    int month;
    int day;
    int year;
};
```

### 结构体变量的定义与使用

在声明结构体类型后，可以定义该类型的变量：

```c
struct date today;  // 定义一个date类型的变量today
```

## 结构体的声明方式

C语言提供了多种声明结构体的方式：

### 1. 单独声明结构体类型

```c
struct date {
    int month;
    int day;
    int year;
};

// 稍后使用该类型定义变量
struct date today;
struct date tomorrow;
```

### 2. 声明类型的同时定义变量

```c
struct date {
    int month;
    int day;
    int year;
} today, tomorrow;  // 直接定义today和tomorrow两个变量
```

### 3. 匿名结构体（无名称）

```c
struct {  // 没有结构体名称
    int x;
    int y;
} point1, point2;  // 只能直接定义变量，后续不能基于此类型创建新变量
```

## 结构体变量的初始化[^3]

### 1. 定义时初始化（类似数组）

```c
struct date today = {7, 31, 2023};  // 按照成员声明顺序初始化
```

### 2. 指定成员初始化（C99起）

```c
struct date today = {.month = 7, .year = 2023};  // day默认为0
```

### 3. 定义后成员赋值

```c
struct date today;
today.month = 7;
today.day = 31;
today.year = 2023;
```

## 访问结构体成员

使用点运算符(`.`)访问结构体变量的成员：

```c
struct date today;
today.month = 7;
printf("month: %d\n", today.day);
```

## 结构体变量的赋值[^4]

与数组不同，结构体变量之间可以直接赋值，这将复制所有成员值：

```c
struct date day;
day = today;  // 复制today的所有成员到day变量
day.year = 2026;  // 修改day的year成员不会影响today
```

示例：
```c
// 结构体之间可以整体赋值
struct date today = {04, 23, 2025};
struct date day;
day = today;  // 将today的所有成员值复制给day
day.year = 2026;  // 只修改day的year值，不影响today

printf("today: %i-%i-%i\n", today.year, today.month, today.day);
printf("day: %i-%i-%i\n", day.year, day.month, day.day);
// 输出：today: 2025-4-23, day: 2026-4-23
```

## 结构体与函数

结构体可以与函数结合使用的三种主要方式：

### 1. 结构体作为函数参数

直接将结构体变量作为参数传递给函数：

```c
void printDate(struct date d) {
    printf("%d-%d-%d\n", d.year, d.month, d.day);
}

// 调用
printDate(today);
```

> **注意**：这种方式会**复制整个结构体**，对于大型结构体可能效率较低。结构体中的任何修改都不会影响原始结构体变量。

### 2. 结构体指针作为函数参数（推荐方式）

```c
void modifyDate(struct date *d) {
    d->month = 12;  // 使用箭头运算符修改原结构体
}

// 调用
modifyDate(&today);
```

> **K&R建议**：在《C程序设计语言》第131页，Kernighan 和 Ritchie 建议优先使用结构体指针作为参数，因为这样更高效（避免复制整个结构）。

### 3. 函数返回结构体

```c
struct date createDate(int m, int d, int y) {
    struct date temp;
    temp.month = m;
    temp.day = d;
    temp.year = y;
    return temp;
}

// 使用
today = createDate(7, 31, 2023);
```

> 这种方式也涉及结构体的复制，但有时很有用，特别是创建新结构体实例时。

### 4. 使用结构体指针优化输入/输出

可以设计函数，通过结构体指针参数读取输入并直接修改实参：

```c
struct date* getStruct(struct date *p) {
    scanf("%d", &p->month);
    scanf("%d", &p->day);
    scanf("%d", &p->year);
    return p;  // 返回指针便于链式调用
}
```

这种模式的好处：
1. 避免复制整个结构体
2. 可以实现链式调用（如：`printDate(getStruct(&today));`）
3. 直接修改原结构体变量的内容

## 结构体指针

### 声明结构体指针

```c
struct date *pDate;  // 声明一个指向date结构体的指针
pDate = &today;      // 指向today变量
```

### 通过结构体指针访问成员

有两种等价的方式：

1. **箭头运算符** `->` （推荐，更简洁）
   ```c
   pDate->month = 12;  // 设置指针所指结构体的month成员
   ```

2. **解引用+点运算符**
   ```c
   (*pDate).month = 12;  // 等同于pDate->month = 12
   ```

### 箭头运算符与点运算符的关系

- `结构体变量.成员名` - 直接访问结构体变量的成员
- `结构体指针->成员名` - 访问指针所指结构体的成员
- `结构体指针->成员名` 等价于 `(*结构体指针).成员名`

## 嵌套结构体

结构体的成员可以是另一个结构体，实现更复杂的数据组织。

### 定义嵌套结构体

```c
struct point {
    int x;
    int y;
};

struct rectangle {
    struct point p1;  // 左上角点
    struct point p2;  // 右下角点
};
```

### 访问嵌套结构体成员

```c
struct rectangle rect;
rect.p1.x = 0;        // 通过点运算符逐层访问
rect.p1.y = 0;
rect.p2.x = 100;
rect.p2.y = 100;

// 使用指针时
struct rectangle *pRect = &rect;
pRect->p1.x = 10;     // 指针和点运算符组合
```

### 嵌套结构体的初始化

```c
struct rectangle rect = {
    {0, 0},  // p1的初始值
    {100, 100}  // p2的初始值
};
```

## 结构体数组

结构体可以组成数组，每个数组元素是一个完整的结构体。

```c
struct date holidays[10];  // 包含10个date结构的数组
```

### 初始化结构体数组

```c
struct rectangle rects[] = {
    {{1, 2}, {3, 4}},  // 第一个矩形
    {{5, 6}, {7, 8}}   // 第二个矩形
};
```

### 访问结构体数组元素

```c
rects[0].p1.x = 10;  // 访问第一个矩形的p1的x成员
for (int i = 0; i < 2; i++) {
    printRect(rects[i]);  // 遍历并处理每个结构体
}
```

## 结构体与数组对比

**数组**被设计为"元素类型一致的、连续分布的内存块"，重在高效访问与指针算术，对整体赋值或动态扩展并不支持；
**结构体**则被设计为复合的、可整体操作的数据实体，更注重数据的组织和抽象。

| 特性 | 结构体 | 数组 |
|-----|------|-----|
| **成员类型** | 可以包含不同类型的成员 | 只能存储相同类型的元素 |
| **内存布局** | 成员连续存储（可能有对齐填充） | 元素连续存储 |
| **整体赋值** | 支持直接赋值：`struct1 = struct2;` | 不支持整体赋值（设计决策） |
| **变量名** | 指代整个结构体实体 | 作为右值时退化为指针 |
| **取地址** | 需要使用&运算符：`&struct1` | 数组名直接表示数组首地址 |
| **函数传递** | 默认按值传递（复制整个结构体） | 默认按引用传递（传递指针） |
| **适用场景** | 表示复合实体（人、日期、坐标等） | 表示同类元素集合 |
| **设计理念** | 组织异构数据，提供整体操作 | 高效访问同类元素，优化指针运算 |

[^1]: 结构体是C语言中最强大的数据类型之一，它允许程序员创建自定义的复合数据类型，表示现实世界中的复杂实体。通过结构体，可以将相关性强但类型不同的数据组织在一起，使程序更加模块化和易于理解。

[^2]: 复合数据类型指的是由多个基本数据类型或其他复合数据类型组合而成的数据类型。在C语言中，除了结构体外，数组和联合体也属于复合数据类型。

[^3]: C标准规定，在**声明**处可以使用大括号初始化结构体，但在普通赋值语句中，右侧必须是一个值（expression）。

[^4]: 结构体被视为值类型，可以整体复制。结构体没有自动退化规则，直接 `=` 即按成员复制。从 ANSI C 开始支持，方便对聚合数据整体操作

 