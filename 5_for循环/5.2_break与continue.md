---
title: break 与 continue
tags: [C语言, 控制流, 循环控制, break, continue, 嵌套循环, goto, 素数判断]
---

# 5.2 break 与 continue

有时我们不希望循环正常执行到结束，而是想在满足特定条件时提前跳出循环或跳过当前迭代的剩余部分。`break` 和 `continue` 语句提供了这种控制能力。

## `break`：跳出循环

`break` 语句用于**立即终止**其所在的**最内层**循环（`for`, `while`, `do-while`）或 `switch` 语句的执行。程序控制将跳转到循环或 `switch` 之后的下一条语句。

-   **作用**: 完全结束循环，不再执行后续迭代。
-   **示例：判断素数 (优化)**
    判断一个数 `x` 是否为素数，需要测试从 2 到 `x-1` 的数是否能整除 `x`。一旦找到一个能整除 `x` 的因子 `i`，就可以确定 `x` 不是素数，无需再继续测试更大的 `i`。
    ```c
    #include <stdio.h>
    #include <stdbool.h> // 为了使用 bool 类型 (C99 及以后)

    int main() {
        int x = 12; // 示例输入
        bool is_prime = true; // 假设 x 是素数

        if (x <= 1) { // 1 和负数不是素数
            is_prime = false;
        } else {
            for (int i = 2; i < x; i++) {
                if (x % i == 0) { // 找到了一个因子
                    is_prime = false; // 证明 x 不是素数
                    printf("%d 能被 %d 整除。\n", x, i);
                    break; // *** 立即跳出 for 循环，无需再测试后续的 i ***
                }
            }
        }

        if (is_prime) {
            printf("%d 是素数。\n", x);
        } else {
            printf("%d 不是素数。\n", x);
        }

        return 0;
    }
    ```
    在这个例子中，当 `x=12`, `i=2` 时，`12 % 2 == 0` 条件满足，`is_prime` 设为 `false`，然后 `break` 语句执行，直接跳出 `for` 循环，执行后续的 `if (is_prime)` 判断。后续的 `i=3, 4, 5...` 的测试都被跳过了，提高了效率。

## `continue`：跳过本次迭代

`continue` 语句用于**跳过**当前循环迭代中 `continue` 语句**之后**的剩余语句，并**立即开始下一次迭代**。

-   **作用**: 提前结束**本次**循环迭代，进入下一次迭代的判断和执行。
-   **对于 `for` 循环**: 执行 `continue` 后，会先执行 `for` 语句头部的**步进表达式**，然后再判断**循环条件**。
-   **对于 `while` 和 `do-while` 循环**: 执行 `continue` 后，会直接跳转到**循环条件**的判断处。
-   **示例：只输出奇数**
    ```c
    #include <stdio.h>

    int main() {
        printf("10以内的奇数: ");
        for (int i = 1; i <= 10; i++) {
            if (i % 2 == 0) { // 如果 i 是偶数
                continue; // *** 跳过本次循环的剩余部分 (printf)，进入下一次迭代 (i++) ***
            }
            // 只有当 i 是奇数时，才会执行到这里
            printf("%d ", i); 
        }
        printf("\n");
        // 输出: 10以内的奇数: 1 3 5 7 9 
        return 0;
    }
    ```
    当 `i` 为偶数时，`if` 条件满足，执行 `continue`，直接跳到 `i++`，然后判断 `i <= 10`；`printf` 语句被跳过。

## 循环嵌套 (Nested Loops)

一个循环的循环体内部可以包含另一个完整的循环结构。

-   **示例：打印九九乘法表**
    ```c
    #include <stdio.h>

    int main() {
        for (int i = 1; i <= 9; i++) { // 外层循环控制行 (乘数1)
            for (int j = 1; j <= i; j++) { // 内层循环控制列 (乘数2 <= 乘数1)
                printf("%d*%d=%-2d ", j, i, i * j); // %-2d 表示左对齐，占2位
            }
            printf("\n"); // 每行结束后换行
        }
        return 0;
    }
    ```
    -   外层循环变量 `i` 从 1 变化到 9。
    -   对于外层循环的**每一次**迭代，内层循环变量 `j` 都会从 1 变化到当前的 `i` 值，完整地执行一遍。
-   **注意**:
    -   内外层循环的控制变量通常应该使用不同的名称（如 `i` 和 `j`），除非有特殊设计意图。
    -   内层循环的完整执行是作为外层循环体的一部分。

## 从嵌套循环中跳出

`break` 语句只能跳出它所在的**最内层**循环。如果想从内层循环直接跳出多层循环，需要使用其他方法。

-   **问题场景：** 假设在一个三层嵌套循环中搜索某个条件，一旦在最内层找到，希望立即结束所有三层循环。
    ```c
    for (...) { // level 1
        for (...) { // level 2
            for (...) { // level 3
                if (condition_met) {
                    // 如何跳出所有三层循环?
                    // break; // 只会跳出 level 3 的循环
                }
            }
            // break 跳到这里
        }
        // break 跳到这里
    }
    // 希望直接跳到这里
    ```

-   **方法一：使用标志变量 (Flag)**
    1.  定义一个标志变量（如 `int exit_flag = 0;` 或 `bool found = false;`）。
    2.  在内层找到条件时，设置标志变量 (`exit_flag = 1;` 或 `found = true;`)，然后 `break` 跳出内层循环。
    3.  在外层循环的循环体末尾（或条件中）检查标志变量。如果已设置，则也执行 `break` 跳出该层循环。
    ```c
    int exit_flag = 0;
    for (...) { 
        for (...) { 
            for (...) { 
                if (condition_met) {
                    exit_flag = 1; 
                    break; // 跳出 level 3
                }
            }
            if (exit_flag) { // 检查标志
                break; // 跳出 level 2
            }
        }
        if (exit_flag) { // 检查标志
            break; // 跳出 level 1
        }
    }
    // 跳到这里
    ```
    这种方法称为"接力 break"。缺点是代码稍显繁琐，需要在每一层都添加检查和 `break`。

-   **方法二：使用 `goto` 语句**
    1.  在希望跳到的目标位置（所有循环之外）设置一个**标签 (Label)**，标签以冒号结尾（如 `OUTER_LOOP_EXIT:`）。
    2.  在内层找到条件时，使用 `goto` 语句直接跳转到该标签。
    ```c
    for (...) { 
        for (...) { 
            for (...) { 
                if (condition_met) {
                    goto OUTER_LOOP_EXIT; // 直接跳转
                }
            }
        }
    }
    OUTER_LOOP_EXIT: // 标签位置
    // 程序执行流跳转到这里
    printf("已跳出所有循环。\n"); 
    ```
    -   **优点**: 代码简洁，意图明确（直接跳出）。
    -   **缺点/争议**: 过度或不恰当使用 `goto` 会破坏程序的结构化，使代码难以理解和维护（所谓的"面条代码"）。
    -   **建议**: **仅**在类似"从多层嵌套结构中跳出"这种 `goto` 能显著简化逻辑且不会造成混乱的特定场景下谨慎使用。避免在其他情况下随意使用 `goto` 进行流程跳转。

选择哪种方法取决于具体情况和团队的编码规范。在现代 C 编程中，通常优先考虑标志变量法，但 `goto` 在处理深度嵌套跳出时仍然是一个有效的（尽管需谨慎使用的）工具。
