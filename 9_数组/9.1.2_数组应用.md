---
title: 数组应用
tags:
  - C语言
  - 数组
  - 应用实例
related_code:
  - "[[Array_统计个数.c]]"
  - "[[Array_素数.c]]"
  - "[[Array_平均数.c]]"
---
---

# 数组应用

本节介绍几个数组的常见应用实例，从实际问题中学习如何使用数组解决问题。

## 🔢 统计数字出现次数

### 问题描述

输入一系列0~9范围内的整数，-1表示输入结束。统计每个数字出现的次数。

### 解题思路

1. 使用大小为10的数组，对应0~9十个数字
2. 数组的每个元素记录对应下标数字出现的次数
3. 读入数字时，将对应位置的计数器加1

### 代码实现

```c
#include <stdio.h>

int main()
{
    int number[10] = {0};  // 初始化为全0
    int x;

    scanf("%d", &x);
    while (x != -1)
    {
        if (x >= 0 && x <= 9)
        {
            number[x]++;  // 对应数字的计数加1
        }
        scanf("%d", &x);
    }
    
    // 输出结果
    for (int i = 0; i < sizeof(number) / sizeof(number[0]); i++)
    {
        printf("%d:%d\n", i, number[i]);
    }
    return 0;
}
```

> 📌 **### 技术要点**

1. 使用`number[10] = {0}`初始化数组的所有元素为0
2. 用输入的数字直接作为数组下标：`number[x]++`
3. 使用`sizeof(number) / sizeof(number[0])`计算数组长度

【相关文件：[../Assets/源代码/Array_统计个数.c](../Assets/源代码/Array_统计个数.c)】

## 🧮 素数筛选法

### 问题描述

使用埃拉托斯特尼筛法(Sieve of Eratosthenes)找出给定范围内的所有素数。

### 解题思路

1. 创建一个布尔数组，初始假设所有数都是素数
2. 从2开始，将每个素数的倍数标记为非素数
3. 只需检查到√n就可以找出所有不大于n的素数
4. 最终数组中标记为素数的位置对应的就是素数

### 代码实现

```c
#include <stdio.h>
#include <math.h>

// 判断一个数是否为素数的函数
int isPrimeNumber(int n) {
    if (n <= 1) return 0;  // 0和1不是素数
    if (n <= 3) return 1;  // 2和3是素数
    if (n % 2 == 0 || n % 3 == 0) return 0;  // 2和3的倍数不是素数
    
    // 只需要检查到sqrt(n)，以6为中心的奇数
    for (int i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0)
            return 0;
    }
    return 1;
}

int main()
{
    const int maxNumber = 100;  // 要筛选的范围是[2,99]
    int isPrime[maxNumber];
    
    // 初始化数组，假设所有数都是素数
    for (int i = 0; i < maxNumber; i++) {
        isPrime[i] = 1;
    }
    
    // 0和1特殊处理：它们不是素数
    isPrime[0] = isPrime[1] = 0;
    
    // 埃拉托斯特尼筛法：只需要检查到sqrt(maxNumber)
    for (int x = 2; x * x < maxNumber; x++) {
        if (isPrime[x]) {
            // 将x的倍数标记为非素数（从x*x开始，因为更小的倍数已被标记）
            for (int i = x * x; i < maxNumber; i += x) {
                isPrime[i] = 0;
            }
        }
    }
    
    // 输出所有素数
    printf("使用埃拉托斯特尼筛法找出的素数：\n");
    int count = 0;
    for (int i = 2; i < maxNumber; i++) {
        if (isPrime[i]) {
            printf("%d ", i);
            count++;
        }
    }
    printf("\n\n共找到%d个素数\n", count);
    
    return 0;
}
```

> 📌 **### 技术要点**

1. 添加了`isPrimeNumber`函数用于独立判断一个数是否为素数，采用了高效算法
2. 筛法优化：从`x*x`开始标记，因为小于`x*x`的`x`的倍数已被更小的素数标记
3. 只需检查到`√maxNumber`就能找出所有素数
4. 特别处理0和1不是素数的情况
5. 输出时按格式化呈现，便于阅读

【相关文件：[../Assets/源代码/Array_素数.c](../Assets/源代码/Array_素数.c)】

## ⚙️ isPrimeNumber函数优化详解

在上面的素数筛选代码中，我们使用了一个高效的`isPrimeNumber`函数来判断单个数字是否为素数。这个函数采用了几个重要的优化，值得深入理解：

```c
int isPrimeNumber(int n) {
    if (n <= 1) return 0;  // 0和1不是素数
    if (n <= 3) return 1;  // 2和3是素数
    if (n % 2 == 0 || n % 3 == 0) return 0;  // 2和3的倍数不是素数
    
    // 只需要检查到sqrt(n)，以6为中心的奇数
    for (int i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0)
            return 0;
    }
    return 1;
}
```

### 优化原理详解

#### 1. 为什么每次都+6？

对于大于3的数，按除以6的余数可分为六类：
- 6k：能被6整除，必然能被2整除，不是素数
- 6k+2：能被2整除，不是素数
- 6k+3：能被3整除，不是素数
- 6k+4：能被2整除，不是素数
- 只有6k+1和6k+5(也就是6k-1)形式的数才可能是素数

通过i+=6，我们直接从一个可能的素数形式(6k-1)跳到下一个，然后在循环体内同时检查i与i+2，大幅减少了判断次数。

#### 2. 为什么以5开头？

初始条件已经处理了n≤3的情况，并排除了能被2或3整除的数。接下来要检查的最小数是5，它恰好是第一个形式为6k-1的数(当k=1时)。以5开始，通过增量6和检查i与i+2，可以覆盖所有可能是素数的数。

#### 3. 为什么要判断 i * i <= n？

这是素数检测的重要优化。若一个数n有大于√n的因子p，则必然存在小于√n的因子q[^1]。因此，检查到√n就足够了，因为如果n有任何因子，必定有一个不大于√n。

判断条件i*i <= n等价于i ≤ √n，这样不用计算耗时的平方根，更高效。如果连最小的6k-1(i)的平方已经大于n了，那就代表这个数已经没有可用因子了，可以默认return 1(为素数)。


***tips***：循环内部的`if (n % i == 0 || n % (i + 2) == 0)`当进入循环后，同时检查两种可能的素数形式：6k-1(i)和6k+1(i+2)是否为n的因子。

## 🔍 数组搜索

### 问题描述

在一个数组中搜索特定值，如果找到则返回其位置，否则返回-1。

### 解题思路

1. 遍历数组的每个元素
2. 将每个元素与目标值比较
3. 找到匹配项则返回位置，否则返回-1

### 代码实现

```c
#include <stdio.h>

// 在数组中搜索一个值，返回其位置（找不到返回-1）
int search(int key, int a[], int length)
{
    int ret = -1;
    for (int i = 0; i < length; i++)
    {
        if (a[i] == key)
        {
            ret = i;
            break;
        }
    }
    return ret;
}

int main()
{
    int a[] = {2, 4, 6, 7, 1, 3, 5, 9, 11, 13, 23, 14, 32};
    int x;
    
    printf("请输入一个要搜索的数字：");
    scanf("%d", &x);
    
    int loc = search(x, a, sizeof(a) / sizeof(a[0]));
    
    if (loc != -1)
    {
        printf("%d在第%d个位置上\n", x, loc);
    }
    else
    {
        printf("%d不在数组中\n", x);
    }
    
    return 0;
}
```

> 📌 **### 技术要点**

1. 数组作为函数参数传递时，必须同时传递数组长度
2. 使用`sizeof(a) / sizeof(a[0])`计算数组长度，但这种方法仅适用于主函数中
3. 在找到目标值后使用`break`提前结束循环
4. 初始设置返回值为-1，表示未找到

## 📊 使用数组计算平均值及相关处理

### 问题描述

输入一系列整数，-1表示输入结束。计算它们的平均值，并输出所有大于平均值的数。

### 解题思路

1. 使用数组存储输入的所有数据
2. 同时计算总和和数据个数，用于计算平均值
3. 计算平均值后，再次遍历数组找出大于平均值的数

### 代码实现

```c
#include <stdio.h>

int main()
{
    int x;
    int sum = 0;
    int cnt = 0;
    int number[100];  // 假设最多100个数据
    
    scanf("%d", &x);
    while (x != -1)
    {
        number[cnt] = x;  // 存储数据
        sum += x;
        cnt++;
        scanf("%d", &x);
    }
    
    if (cnt > 0)
    {
        printf("%d %.1f\n", sum, (float)sum / cnt);
        
        // 输出大于平均值的数
        for (int i = 0; i < cnt; i++)
        {
            if (number[i] > sum / cnt)
            {
                printf("%d ", number[i]);
            }
        }
    }

    return 0;
}
```

> 📌 **### 技术要点**

1. 使用数组存储中间结果，便于后续处理
2. 记录实际存储的数据个数`cnt`，用于控制遍历范围
3. 使用类型转换`(float)sum / cnt`确保平均值计算的准确性

【相关文件：[../Assets/源代码/Array_平均数.c](../Assets/源代码/Array_平均数.c)】

> 🧠 **## 总结**

数组在解决各类问题时发挥着重要作用。通过以上实例，我们可以总结出几个使用数组的常见模式：

1. **计数器数组**：使用数组元素作为计数器，下标表示要计数的对象
2. **标记数组**：使用数组元素作为标记，记录某些状态或属性
3. **存储数组**：存储中间结果，便于后续多次处理
4. **查表数组**：预计算并存储结果，用于快速查找

掌握这些模式有助于我们更有效地使用数组解决各种编程问题。 

[^1]: 你想想看：
	
	- 如果两个“好朋友”都比 **6 小**，比如 5 和 5，它们乘起来 $(5 \times 5 = 25)$，就**不够** 36 大了。
	- 如果两个“好朋友”都比 **6 大**，比如 7 和 7，它们乘起来 $(7 \times 7 = 49)$，就**超过** 36 了，太大了。
	
	如果两个因子都比 $\sqrt{n}$ 小，它们乘积小于 $n$；  
	如果两个因子都比 $\sqrt{n}$ 大，它们乘积大于 $n$。
	
	因此对于任一一对因子 $a$ 和 $b$ 使得 $a \times b = n$：
	
	- 若 $a > \sqrt{n}$，则 $b < \sqrt{n}$；
	- 若 $a < \sqrt{n}$，则 $b > \sqrt{n}$；
	- 若 $a = \sqrt{n}$，则 $b = \sqrt{n}$。
	
	