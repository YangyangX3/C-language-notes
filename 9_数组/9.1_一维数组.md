---
title: 一维数组
tags:
  - C语言
  - 数组
  - 数据结构
related_code:
  - "[[Array_平均数.c]]"
---

# 一维数组

## 数组的基本概念

数组是一种**容器**，用于存储一组相同数据类型的元素。数组在内存中是连续存储的，可以通过下标快速访问任意位置的元素。

### 数组的特点

1. 所有元素具有相同的数据类型
2. 一旦创建，大小固定不能更改
3. 在内存中连续存储，元素之间紧密排列
4. 通过下标（索引）访问元素，下标从0开始

## 如何定义和使用数组

### 数组的定义

```c
// 类型 数组名[元素数量];
int grades[100];      // 定义一个可容纳100个整数的数组
double weight[20];    // 定义一个可容纳20个double的数组
```

### 元素数量的说明

- 元素数量必须是整数
- C89/C90标准中：元素数量必须是编译时确定的常量
- C99标准开始：允许使用变量定义数组大小（变长数组）

### 数组的初始化

数组可以在定义时使用**大括号**[^1]进行初始化：

```c
// 完整初始化
int a[5] = {1, 2, 3, 4, 5};

// 部分初始化（未指定的元素自动初始化为0）
int b[5] = {1, 2};  // b为 {1, 2, 0, 0, 0}

// 让编译器计算数组大小
int c[] = {1, 2, 3, 4, 5};  // c的大小为5

// 全部初始化为0的简写方式
int count[10] = {0};  // count全部为0

// C99支持的指定初始化器
int d[6] = {[1]=2, [4]=6};  // d为 {0, 2, 0, 0, 6, 0}
```

####  🧠 数组初始化 VS 赋值

> C语言中，初始化（Initialization）和赋值（Assignment）虽然表面相似，但含义、时机和底层处理完全不同，编译器必须严格区分。

---

##### 📌 核心区别速查表

| 特性         | 初始化                     | 赋值                |
| ---------- | ----------------------- | ----------------- |
| **执行时机**   | 变量**定义时**，只能执行一次        | 定义后任意位置，**可反复执行** |
| **语法示例**   | `int arr[3] = {1,2,3};` | `arr[0] = 1;`     |
| **处理方式**   | 编译期直接设值，可被优化            | 运行期逐条写入内存         |
| **支持整体操作** | ✅ `{}` 支持整体初始化          | ❌ 不支持整体赋值         |
| **适用范围**   | 仅限**变量定义阶段**            | 任意**已存在变量**       |

---

##### 🔍 编译器为何要区分二者？

- ✅ **更高效**
  - 初始化可静态生成数据，省去运行时赋值指令；
- ✅ **更清晰**
  - 初始化只在变量创建时出现，语义更明确；
- ✅ **能限制用法**
  - `const` 等变量**必须初始化**，不能后赋值；
- ✅ **支持语法约束**
  - 初始化语法支持数组、结构体等特殊形式（如 `{}`）；

---

##### 📝 极简总结

> 初始化是“一次性创建+赋值”，赋值是“运行中修改”。  
> 编译器区分它们，是为了生成**更快、更安全、更准确**的代码。


#### 为什么数组不能整体赋值？[^2]

❌ **常见错误**：
```c
// 正确：初始化
int arr[] = {1, 2, 3, 4, 5};

// 错误：尝试整体赋值
int a[3] = {1, 2, 3};
int b[3];
b = a;  // ❌ 错误：数组之间不能直接整体赋值
```


C语言中数组无法整体赋值的设计是深思熟虑的结果，涉及语言设计哲学、性能考量和类型系统的基本原则：

1. **数组不是"第一类对象"[^3]（First-Class Object）**
   - 在C语言类型系统中，数组缺乏完整的对象语义
   - 结构体和联合体等聚合类型拥有赋值语义，可直接互相赋值
   - 数组被视为内存区块的"视图"，而非可操作的整体实体
   - 当尝试 `array1 = array2` 时，编译器报错："incompatible types"或"lvalue required"

2. **数组衰变（Array Decay）机制**
   - 在大多数表达式中，数组名自动"衰变"为指向首元素的指针
   - 衰变后的数组丢失了大小信息，成为纯指针类型  
   - `int a[10]` 在表达式中变为 `int*`，不再是完整数组对象
   - 赋值语句 `a = b` 等价于将一个地址赋给数组名，而数组名不是可修改的地址容器

3. **设计哲学：简洁、可预测与高效**
   - C语言核心设计原则："显式优于隐式"，尤其对于潜在的大量资源操作
   - 避免语言隐藏"昂贵"操作，如大型数组的自动复制
   - 程序员应明确知晓何时发生内存复制，控制性能关键区域
   - 符合"C语言不会为你做任何你未明确要求的事"的理念

4. **语言标准与向后兼容性**
   - C标准（C89/C99）未定义数组赋值运算，后续添加会破坏兼容性
   - 实现数组赋值需增加编译器复杂度和运行时开销
   - C99引入的复合字面量（compound literals）可部分弥补这一限制：
     ```c
     int a[3];
     // a = {1,2,3};     // 错误
     a = (int[3]){1,2,3}; // C99允许，通过临时对象实现
     ```

5. **对比：结构体与数组的赋值差异**
   - 结构体支持整体赋值：编译器生成成员到成员的复制指令
   - 数组可通过包装在结构体中获得整体赋值能力：
     ```c
     typedef struct { int data[5]; } IntArray5;
     IntArray5 a = {{1,2,3,4,5}}, b;
     b = a;  // 合法，结构体赋值会复制内部数组
     ```
   - 这种差异体现了C语言类型系统的设计取舍

> 📝 **记忆要点**：数组不支持整体赋值的根本原因是它在C语言中不是完整的对象，而是一种会"衰变"为指针的特殊类型。这一设计虽然限制了便利性，但确保了内存操作的显式性和效率，符合C语言"贴近硬件"的设计哲学。

#### 正确的数组复制方式：

- **逐元素赋值**：明确且可控
  ```c
  int arr[5];
  arr[0] = 1; arr[1] = 2; arr[2] = 3; arr[3] = 4; arr[4] = 5;
  ```
  
- **使用循环**：适用于长数组或需要处理每个元素的情况
  ```c
  int arr[5];
  int temp[] = {1, 2, 3, 4, 5};
  for (int i = 0; i < 5; i++) {
      arr[i] = temp[i];
  }
  ```
  
- **使用标准库函数**：高效的内存块复制
  ```c
  #include <string.h>
  memcpy(arr, src, sizeof(arr)); // 源和目标不重叠时
  memmove(arr, src, sizeof(arr)); // 适用于重叠内存区域
  ```

- **C99复合字面量**：借助临时对象（仅限C99及以上）
  ```c
  int arr[3];
  // 使用复合字面量初始化已存在的数组
  memcpy(arr, (int[3]){10, 20, 30}, sizeof(arr));
  ```

### 数组下标

- 数组下标从**0**开始计数
- 最大有效下标为**数组大小减1**
- 使用方括号`[]`包含下标来访问元素

```c
int a[5];       // 定义大小为5的数组
a[0] = 10;      // 访问第一个元素
a[4] = 50;      // 访问最后一个元素
```

### 下标越界

C语言不会检查数组下标是否越界，使用了越界的下标可能导致：

- 程序崩溃（常见错误是Segmentation Fault）
- 无法预测的行为
- 数据损坏但程序继续运行

```c
int a[10];
a[10] = 0;  // 错误！越界访问（有效下标为0到9）
```

### 计算数组长度

可以使用`sizeof`运算符计算数组长度：

```c
int a[] = {1, 2, 3, 4, 5};
int length = sizeof(a) / sizeof(a[0]);  // 计算元素个数
```

## 数组遍历

遍历数组是最常见的操作之一，通常使用for循环：

```c
int a[5] = {10, 20, 30, 40, 50};
int sum = 0;

// 遍历数组
for (int i = 0; i < 5; i++) {
    sum += a[i];
}
```

常见遍历错误：
- 使用`<=`而非`<`作为循环条件
- 在循环外继续使用索引变量访问元素

## 代码示例

使用数组计算大于平均值的数：

```c
// 读入一系列整数，-1表示结束，输出大于平均值的数
int x;
int sum = 0;
int cnt = 0;
int number[100];  // 假设最多存储100个数

scanf("%d", &x);
while (x != -1) {
    number[cnt] = x;  // 存储输入的数
    sum += x;
    cnt++;
    scanf("%d", &x);
}

if (cnt > 0) {
    float avg = (float)sum / cnt;
    printf("平均值：%.1f\n", avg);
    
    // 输出大于平均值的数
    for (int i = 0; i < cnt; i++) {
        if (number[i] > avg) {
            printf("%d ", number[i]);
        }
    }
}
```

![../Assets/源代码/Array_平均数.c](../Assets/源代码/Array_平均数.c) 

[^1]: **大括号初始化及其设计目的**
	- 大括号 `{}`初始化是C语言的一种特殊语法，通常用于初始化聚合类型（如数组和结构体），仅允许在变量定义时使用。
	
	- 设计目的：1)简化代码，避免大量的单独赋值语句；2)提高效率，编译器可以优化初始化代码；3)牺牲一点点“显式控制”换取了巨大的便利性和可读性；
	
	C 语言的设计哲学强调语法的简洁性和明确性，追求最小可行性原则。若允许在赋值中使用 `{}`，就必须为聚合类型引入额外的赋值规则和处理机制，这不仅会增加语言本身的复杂度，也可能引发语义上的歧义。将 `{}` 严格限制在初始化阶段，有助于保持语法规则的一致性、清晰性和易于实现性，符合 C 语言“简而不杂”的设计理念。

[^2]: **C语言对数组设计的历史原因**：
	1. 设计初衷：Dennis Ritchie创建C语言时，注重简单高效，数组作为指向内存的"窗口"，不是完整的对象
	2. 内存模型：模拟了计算机硬件的寻址方式，而非抽象数据类型
	3. 影响：该设计使C语言高效但不如现代语言安全方便，后续语言如C++/Java引入了真正的数组对象

[^3]: "**对象**"指的是"执行环境中一段具备具体类型的存储区域"。