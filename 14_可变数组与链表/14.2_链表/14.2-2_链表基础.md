---
title: 链表基础
tags:
  - C语言
  - 链表
  - 数据结构
  - 动态内存
related_code:
  - "[[链表.c]]"
---

# 链表基础

## 链表的概念

链表是一种线性数据结构，它通过"节点"和"指针"的方式组织数据，每个节点包含数据部分和指向下一个节点的指针。与数组不同，链表中的元素在内存中不需要连续存储。

## 链表的基本结构

### 节点定义

链表的基本组成单元是节点，每个节点包含两部分：

```c
typedef struct _node
{
    int value;        // 数据部分
    struct _node *next; // 指向下一个节点的指针
} Node;
```

这个结构定义了一个包含整型数据和指向下一个节点指针的节点类型。

### 自引用结构

链表节点是一个"自引用结构"，即结构体内部包含指向同类型结构体的指针。在定义时需要使用结构体标签名：

```c
struct _node
{
    int value;
    struct _node *next; // 使用结构体标签名
};
```

由于在定义时结构体类型尚未完全确定，不能直接使用`Node *next`，必须使用结构体标签名`struct _node *next`。

### 链表表示

链表通常通过头指针来表示，头指针指向链表的第一个节点：

```c
Node *head = NULL; // 初始为空链表
```

完整的链表可以表示为：
```
head → [节点1] → [节点2] → [节点3] → ... → [节点n] → NULL
```

末尾节点的`next`指针设为`NULL`，表示链表结束。

## 链表的管理结构

为了更方便地管理链表，我们可以定义一个链表管理结构：

```c
typedef struct _list
{
    Node *head;  // 指向链表头部
    Node *tail;  // 指向链表尾部(可选)
} List;
```

添加尾指针的好处是可以在O(1)时间内完成尾部添加操作，而不需要每次都从头遍历到尾。

## 链表的优势

与数组相比，链表具有以下优势：

1. **动态大小**：链表可以在运行时动态增长，无需预先确定大小
2. **高效的插入和删除**：在已知位置插入或删除元素的时间复杂度为O(1)
3. **内存利用**：能够利用不连续的内存空间，减少内存碎片问题
4. **无需整体复制**：扩展时只需创建新节点并调整指针，不需要复制整个数据结构

## 链表的局限性

链表也有一些局限性：

1. **随机访问效率低**：无法像数组那样通过索引直接访问元素，需要从头遍历
2. **额外的内存开销**：每个节点都需要额外的指针空间
3. **缓存不友好**：由于内存不连续，无法充分利用CPU缓存

## 相关源代码

完整代码示例请参考：
[[../Assets/源代码/链表.c]] 