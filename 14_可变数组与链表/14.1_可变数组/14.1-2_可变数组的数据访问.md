---
title: 可变数组的数据访问
tags:
  - C语言
  - 可变数组
  - 数据访问
  - 封装
related_code:
  - "[[可变数组.c]]"
---

# 可变数组的数据访问

## 数组元素访问设计

在可变数组中，我们需要设计合适的方法来访问和修改数组元素。基本的需求包括：

1. **读取元素值**：获取指定位置的数据
2. **修改元素值**：更新指定位置的数据
3. **安全访问**：自动处理边界检查和扩容

## 元素访问函数实现

### 指针返回方式

可变数组最核心的访问函数是`array_at`，它返回指定位置元素的指针：

```c
int *array_at(Array *array, int index)
{
    if (index >= array->size) // 需要扩容
    {
        // 计算需要扩容的大小并调用扩容函数
        array_inflate(array, BLOCK_SIZE);
    }
    return &array->arr[index];
}
```

这个函数的特点：

- 返回**指针**而非值，使得该函数可以作为左值使用
- 自动检查边界并在需要时调用扩容函数
- 提供了类似原生数组的使用体验

### 为什么返回指针？

返回指针而非直接返回值的设计有两个关键优势：

1. **支持赋值操作**：允许将函数调用作为左值使用
2. **一致的接口**：同一个函数既可读取也可修改元素

使用示例：

```c
// 读取元素
int value = *array_at(&myArray, 5);

// 修改元素
*array_at(&myArray, 5) = 10;
```

## 替代设计：Get/Set函数

为了提供更直观的接口，我们也可以实现单独的get和set函数：

```c
// 获取元素值
int array_get(const Array *arr, int index)
{
    return arr->arr[index];
}

// 设置元素值
void array_set(Array *arr, int index, int num)
{
    arr->arr[index] = num;
}
```

这种设计的特点：

- 函数名更明确地表达了意图
- 分离读写操作，可以对读操作添加`const`限定
- 对于不熟悉指针操作的用户更友好

## 封装的价值

可变数组的数据访问设计体现了封装的重要价值：

- **隐藏实现细节**：用户无需关心内部存储结构
- **提供统一接口**：通过函数接口规范化访问方式
- **自动化管理**：处理边界检查和扩容等复杂逻辑

无论内部实现如何变化，只要保持接口不变，用户代码就不需要修改。

## 相关源代码

完整代码示例请参考：
[[../Assets/源代码/可变数组.c]] 