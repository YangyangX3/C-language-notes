---
title: 可变数组
tags:
  - C语言
  - 可变数组
  - 动态内存
  - 数据结构
related_code:
  - "[[可变数组.c]]"
---

# 可变数组

## 固定大小数组的局限性

在C语言中，传统数组具有以下局限性：

- **固定大小**：一旦定义，数组大小无法改变
- **空间预分配**：必须预先确定数组大小，可能造成内存浪费
- **空间不足**：如果预分配空间不足，无法继续存储数据

尽管C99标准允许使用变量定义数组大小，但数组一旦创建，其大小仍然无法在运行过程中改变。

## 可变数组的设计目标

为了解决传统数组的局限性，我们可以实现一个可变大小的数组数据结构，具有以下特点：

1. **自动扩容**：当空间不足时，能够自动增加容量
2. **容量查询**：提供方法获取当前数组容量
3. **元素访问**：提供便捷方法访问数组元素

## 可变数组的实现

### 数据结构定义

```c
typedef struct
{
    int *arr;    // 指向动态分配的数组内存
    int size;    // 当前数组的容量
} Array;
```

这个结构包含两个成员：
- `arr`：指向实际存储数据的内存区域
- `size`：记录当前数组的容量

### 核心函数设计

可变数组的实现需要以下核心函数：

1. **创建数组**：`array_create` - 分配初始内存
2. **释放数组**：`array_free` - 回收内存
3. **获取大小**：`array_size` - 返回当前容量
4. **访问元素**：`array_at` - 访问指定位置元素
5. **扩展数组**：`array_inflate` - 增加数组容量

### 创建数组

```c
Array array_create(int init_size)
{
    Array newArray;
    newArray.arr = (int *)malloc(init_size * sizeof(int));
    newArray.size = init_size;
    return newArray;
}
```

创建数组时，通过`malloc`分配指定大小的内存，并初始化结构体。

### 释放数组

```c
void array_free(Array *a)
{
    free(a->arr);
    a->arr = NULL;
    a->size = 0;
}
```

释放数组时，回收动态分配的内存并重置结构体成员，避免悬挂指针。

## 封装的重要性

在实现可变数组时，我们采用了封装（Encapsulation）的设计思想：

- 通过函数接口隐藏内部实现细节
- 用户无需关心扩容机制，只需使用提供的函数
- 便于未来升级和优化内部实现

例如，`array_size`函数虽然现在只是简单返回`size`成员，但将来可能会有更复杂的实现：

```c
int array_size(const Array *array)
{
    return array->size;
}
```

## 相关源代码

完整代码示例请参考：
[[../Assets/源代码/可变数组.c]] 