---
title: 指针基础
tags:
  - C语言
  - 指针
  - 内存地址
  - 指针与数组
  - 数组退化
related_code:
  - "[[指针.c]]"
  - "[[指针与数组.c]]"
---

# 指针基础

## 取地址运算符

在C语言中，每个变量都占据内存中的一块区域，而这块区域有一个唯一的地址。取地址运算符`&`用于获取变量的内存地址。

```c
int i = 6;
printf("i的地址是：%p\n", &i); // 使用&运算符获取i的地址
```

### 地址的表示

地址通常以十六进制形式表示，在输出时使用`%p`格式符。

```c
int i = 6;
printf("使用%%p格式：%p\n", &i);   // 正确的地址输出方式
printf("使用%%x格式：%x\n", &i);   // 不推荐，在64位系统可能显示不完整
```

### 取地址运算符的规则

1. **只能对变量取地址**：不能对表达式或常量取地址
   ```c
   int i = 6, j = 8;
   int *p;
   p = &i;      // 正确：对变量取地址
   p = &(i+j);  // 错误：不能对表达式取地址
   p = &6;      // 错误：不能对常量取地址
   ```

2. **地址大小与架构相关**：在32位系统上是4字节，在64位系统上是8字节
   ```c
   printf("sizeof(int) = %zu\n", sizeof(int));
   printf("sizeof(&i) = %zu\n", sizeof(&i));
   ```

## 指针变量

指针变量是用来存储内存地址的变量。指针变量指向的是内存中的某一位置。

### 指针的定义

```c
int *p;    // p是一个指向int类型的指针
double *q; // q是一个指向double类型的指针
```

> 注意：`*` 可以紧贴类型名或变量名，但通常建议紧贴变量名，以避免混淆。

### 指针的赋值

指针变量存储的是其他变量的地址：

```c
int i = 6;
int *p;
p = &i;  // p指向i，p中存储的是i的地址
```

> 此时我们说"p指向i"，意思是p中存储的值是i的地址。

### 通过指针访问变量

可以使用解引用运算符`*`来访问指针所指向的变量：

```c
int i = 6;
int *p = &i;
printf("i的值是：%d\n", i);
printf("通过指针访问i的值：%d\n", *p);  // *p就是i

*p = 26;  // 通过指针修改i的值
printf("修改后i的值：%d\n", i);  // 输出26
```

> `*p`作为左值时，可以修改p所指向的变量的值；作为右值时，可以获取p所指向的变量的值。

## 指针的主要用途

### 1. 交换变量的值

通过指针可以实现在函数中交换变量的值：

```c
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int x = 5, y = 6;
    swap(&x, &y);  // 传递x和y的地址
    printf("x = %d, y = %d\n", x, y);  // 输出：x = 6, y = 5
    return 0;
}
```

### 2. 函数返回多个值

C语言的函数只能通过返回值返回一个结果，但使用指针参数可以返回多个结果：

```c
void min_max(int a[], int len, int *min, int *max) {
    *min = *max = a[0];
    for (int i = 1; i < len; i++) {
        if (a[i] < *min) *min = a[i];
        if (a[i] > *max) *max = a[i];
    }
}

int main() {
    int a[] = {3, 5, 2, 8, 1, 4};
    int min, max;
    min_max(a, 6, &min, &max);
    printf("最小值：%d，最大值：%d\n", min, max);
    return 0;
}
```

### 3. 返回函数运算状态

使用返回值表示函数执行状态，使用指针参数返回实际结果：

```c
int divide(int a, int b, int *result) {
    if (b == 0) {
        return 0;  // 表示除法失败
    }
    *result = a / b;
    return 1;  // 表示除法成功
}

int main() {
    int a = 10, b = 0, c;
    if (divide(a, b, &c)) {
        printf("%d / %d = %d\n", a, b, c);
    } else {
        printf("除数不能为零\n");
    }
    return 0;
}
```

## 指针的常见错误

### 使用未初始化的指针[^1]

未初始化的指针指向的是一个随机的内存地址，使用这样的指针可能导致程序崩溃：

```c
int *p;       // 未初始化的指针
*p = 12;      // 危险！可能导致程序崩溃
```

### 正确的做法是确保指针在使用前已经指向一个有效的地址：

```c
int i = 6;
int *p = &i;  // 指针初始化，指向i
*p = 12;      // 安全：修改i的值为12
```

## 指针与数组

在函数参数中，数组其实是作为指针传递的：

```c
void print_array(int arr[], int size) {
    // arr实际上是一个指针，指向数组的第一个元素
    printf("在函数内部，sizeof(arr) = %zu\n", sizeof(arr));  // 输出指针的大小，而不是数组的大小
}

int main() {
    int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    printf("在main中，sizeof(a) = %zu\n", sizeof(a));       // 输出数组的实际大小
    print_array(a, 10);
    return 0;
}
```

### 函数参数中的数组与指针

以下四种函数原型在参数传递上是等价的：

```c
void func1(int arr[]);
void func2(int arr[10]);  // 括号中的数字被忽略
void func3(int *arr);
void func4(int * const arr);
```

数组变量可视为“**常量指针**”[^2]（不能修改指向），它指向数组的第一个元素：

```c
int a[5] = {1, 2, 3, 4, 5};
int *p = a;      // 等同于 p = &a[0]

// 以下表达式是等价的
a[0] == *a
a[1] == *(a+1)
```

> 注意：虽然数组名可以作为指针使用，但数组名是“常量指针”，不能被修改。即不能执行 a = p 这样的操作。 

<span></span>
### 数组退化现象

在C语言中，数组名在大多数表达式中会自动"退化"(decay)为指向其第一个元素的指针。这个过程称为"数组退化"：

```c
int numbers[5] = {10, 20, 30, 40, 50};
int *ptr = numbers;  // numbers退化为&numbers[0]
```

#### 数组退化的规则

1. **数组退化的情况**：
   - 数组名作为函数参数传递时
   - 数组名赋值给指针变量时
   - 数组名在大多数表达式中使用时

2. **数组退化的例外**：
   - 当数组名作为`sizeof`运算符的操作数时
   - 当数组名作为单目运算符`&`的操作数时
   - 当数组名是字符串字面量初始化字符数组的操作数时

3. **退化前后类型的差异**：
   ```c
   int arr[5];
   // 退化前：arr的类型是"含有5个int元素的数组"(int[5])
   // 退化后：arr的类型变为"指向int的指针"(int*)
   ```

#### 数组退化与sizeof

`sizeof`运算符能够清晰地展示数组退化现象：

```c
int numbers[5] = {10, 20, 30, 40, 50};
int *ptr = numbers;

printf("sizeof(numbers) = %zu\n", sizeof(numbers));  // 输出数组完整大小: 5 * sizeof(int)
printf("sizeof(ptr) = %zu\n", sizeof(ptr));          // 仅输出指针变量大小: 4或8字节
```

#### 数组退化与函数参数

当数组作为函数参数传递时，无论声明形式如何，实际接收的都是指针：

```c
// 以下三种声明在函数内部是完全等价的
void process_array(int arr[10]);  // 方括号中的数字被忽略
void process_array(int arr[]);    // 空方括号
void process_array(int *arr);     // 明确的指针形式

int main() {
    int data[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    process_array(data);  // data退化为指向data[0]的指针
    return 0;
}
```

在函数内部，无法通过`sizeof`获取原始数组的大小：

```c
void process_array(int arr[10]) {
    // 即使声明为int arr[10]，sizeof(arr)也只是指针的大小
    printf("sizeof(arr) = %zu\n", sizeof(arr));  // 4或8字节，而不是10 * sizeof(int)
}
```

#### 数组名与地址的细微差别

虽然数组名会退化为指针，但`&array`和`array`存在类型差异：

```c
int numbers[5];
// numbers退化后的类型是int*
// &numbers的类型是int(*)[5]，即"指向包含5个int元素的数组的指针"

printf("numbers: %p\n", numbers);        // 数组首元素地址
printf("&numbers: %p\n", &numbers);      // 整个数组的地址(数值上相同)
printf("numbers+1: %p\n", numbers+1);    // 移动一个int大小
printf("&numbers+1: %p\n", &numbers+1);  // 移动整个数组大小
```

这种差异在指针运算时尤为明显：`numbers+1`指向第二个元素，而`&numbers+1`则跳过整个数组。

## 相关源代码

完整代码示例请参考：![[../Assets/源代码/指针.c]]![[../Assets/源代码/指针与数组.c]] 

[^1]: 指针变量 `ptr` 本身会被分配在栈上的某个内存位置，但它所包含的值（即它指向的地址）是未定义的。在大多数系统中，这个值不会自动设为 NULL 或任何安全值，而是包含了该内存位置之前可能存在的任何数据，解引用它可能访问非法内存位置，导致程序崩溃或不可预测的行为。

[^2]: 在 C 语言中，数组名是一个**符号常量**，表示数组的起始内存地址。
	
	- ✅ **自动衰退（decay）**：在表达式中，数组名会自动转换为指向首元素的指针，但它本身不是变量，不能修改。
	    
	- ❌ **不可赋值**：数组名不是可修改的左值，不能作为赋值语句左侧（如 `arr1 = arr2;` 是非法的）。
	    
	- ⚠️**语义清晰**：禁止数组名赋值可以避免语义歧义，如“重新分配数组”或“修改地址”。
	    
	
	因此，数组名就像一个固定的地址标签，用于访问数组，而不是可以操作的变量。
	
