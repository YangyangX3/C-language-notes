---
title: 指针运算
tags:
  - C语言
  - 指针
  - 指针运算
  - 动态内存分配
related_code:
  - "[[指针运算.c]]"
  - "[[动态内存分配.c]]"
---

# 指针运算

指针不仅可以存储地址，还可以进行多种运算，使得C语言对内存的操作更加灵活。

## 指针的算术运算

### 指针加法

C语言允许对指针进行加法运算，但这与普通整数加法不同：

```c
int a[5] = {1, 2, 3, 4, 5};
int *p = a;  // p指向a[0]

printf("*p = %d\n", *p);        // 输出1，p指向a[0]
printf("*(p+1) = %d\n", *(p+1)); // 输出2，p+1指向a[1]
printf("*(p+2) = %d\n", *(p+2)); // 输出3，p+2指向a[2]
```

> **重要规则**：指针加法会根据指针类型自动调整偏移量。`p+1`表示向后移动一个元素，而不是一个字节。

### 指针减法

指针减法同样会根据类型进行调整：

```c
int a[5] = {1, 2, 3, 4, 5};
int *p = &a[3];  // p指向a[3]，值为4

printf("*p = %d\n", *p);        // 输出4
printf("*(p-1) = %d\n", *(p-1)); // 输出3，p-1指向a[2]
printf("*(p-2) = %d\n", *(p-2)); // 输出2，p-2指向a[1]
```

### 指针比较

指针之间可以进行比较运算，比较的是它们所指向的内存地址：

```c
int a[5] = {1, 2, 3, 4, 5};
int *p1 = &a[1];
int *p2 = &a[3];

if (p1 < p2) {
    printf("p1指向的位置在p2之前\n");
}

if (p2 - p1 == 2) {
    printf("p2和p1之间相隔2个元素\n");
}
```

### 指针与数组下标

指针运算与数组下标运算是等价的：

```c
int a[5] = {1, 2, 3, 4, 5};
int *p = a;

// 以下两种表达方式等价
printf("%d %d %d\n", a[0], a[1], a[2]);
printf("%d %d %d\n", *p, *(p+1), *(p+2));

// 指针也可以使用下标运算符
printf("%d %d %d\n", p[0], p[1], p[2]);
```

## 指针与const

C语言中可以通过`const`关键字限制指针的使用方式：

### 常量指针（指向常量的指针）

```c
const int *p;   // 或 int const *p;
```

这种指针指向的内容不能被修改，但指针本身可以指向其他位置：

```c
int i = 10, j = 20;
const int *p = &i;  // p指向i

// *p = 30;  // 错误：不能通过p修改i的值
p = &j;      // 正确：p可以指向其他位置
```

### 指针常量（指针本身是常量）

```c
int * const p = &i;
```

指针常量的指向不能被修改，但可以通过它修改所指向的内容：

```c
int i = 10, j = 20;
int * const p = &i;  // p指向i

*p = 30;    // 正确：可以通过p修改i的值
// p = &j;  // 错误：p的指向不能被修改
```

### 指向常量的指针常量

```c
const int * const p = &i;
```

这种指针既不能修改其指向，也不能通过它修改所指向的内容：

```c
int i = 10, j = 20;
const int * const p = &i;

// *p = 30;  // 错误：不能通过p修改i的值
// p = &j;   // 错误：p的指向不能被修改
```

## 动态内存分配

静态数组的大小在编译时必须确定，而动态内存分配允许在运行时根据需要分配内存。

### malloc函数[^1]

`malloc`函数用于分配指定大小的内存块：

```c
#include <stdlib.h>

int *p;
p = (int *)malloc(10 * sizeof(int));  // 分配可容纳10个int的内存块

if (p == NULL) {
    // 内存分配失败
    printf("内存分配失败\n");
    return 1;
}

// 使用分配的内存
for (int i = 0; i < 10; i++) {
    p[i] = i * 10;
}

// 访问分配的内存
for (int i = 0; i < 10; i++) {
    printf("%d ", p[i]);  // 输出: 0 10 20 30 40 50 60 70 80 90
}
```

> `malloc`函数返回`void *`类型，需要强制转换为具体的指针类型。  
> 始终检查`malloc`的返回值是否为`NULL`来处理内存分配失败的情况。

### free函数

当不再需要动态分配的内存时，应使用`free`函数释放它：

```c
free(p);  // 释放之前分配的内存
p = NULL; // 避免悬空指针（指向已释放内存的指针）
```

### 常见的动态内存错误

1. **内存泄漏**：忘记释放不再使用的内存
   ```c
   void memory_leak() {
       int *p = (int *)malloc(10 * sizeof(int));
       // 没有调用free(p)
   }  // p超出作用域，但分配的内存未释放
   ```

2. **使用已释放的内存**
   ```c
   int *p = (int *)malloc(sizeof(int));
   *p = 10;
   free(p);
   *p = 20;  // 错误：p指向已释放的内存
   ```

3. **内存越界访问**
   ```c
   int *p = (int *)malloc(5 * sizeof(int));
   p[10] = 100;  // 错误：越界访问，可能导致程序崩溃
   ```

### calloc与realloc

- **calloc**：分配内存并初始化为0
  ```c
  int *p = (int *)calloc(10, sizeof(int));  // 分配10个int，全部初始化为0
  ```

- **realloc**：调整已分配内存的大小
  ```c
  int *p = (int *)malloc(5 * sizeof(int));
  // 将数组扩展到10个元素
  p = (int *)realloc(p, 10 * sizeof(int));
  ```

## void指针

`void *`是一种特殊的指针类型，可以指向任何类型的数据，它提供了一种在不知道具体数据类型的情况下操作内存地址的机制。

但在使用前需要转换为具体类型：

```c
void *ptr;
int i = 10;
double d = 3.14;

ptr = &i;  // ptr指向int
printf("%d\n", *((int *)ptr));  // 必须先转换为int*才能解引用

ptr = &d;  // ptr指向double
printf("%f\n", *((double *)ptr));  // 必须先转换为double*才能解引用
```

`void *`常用于需要处理不同类型数据的函数，如内存分配函数和一些通用操作函数。 

## 相关源代码

完整代码示例请参考：![[../Assets/源代码/指针运算.c]]![[../Assets/源代码/动态内存分配.c]] 

[^1]: **作用**:
	
	- 在程序的**堆 (Heap)** 内存区域请求分配一块指定大小的连续内存空间。
	- 堆内存与栈内存不同。栈内存用于存储函数局部变量和函数调用信息，由编译器自动管理；堆内存的分配和释放则由程序员手动控制。
